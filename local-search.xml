<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>局域网互访虚机</title>
    <link href="/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/"/>
    <url>/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="局域网互访虚机"><a href="#局域网互访虚机" class="headerlink" title="局域网互访虚机"></a>局域网互访虚机</h1><ul><li><a href="https://yangtzeshore.github.io/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE">宿主机配置</a></li><li><a href="https://yangtzeshore.github.io/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/#%E8%99%9A%E6%9C%BA%E9%85%8D%E7%BD%AE">虚机配置</a></li><li><a href="https://yangtzeshore.github.io/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/#kvm%E9%85%8D%E7%BD%AE">kvm配置</a></li></ul><h2 id="宿主机配置"><a href="#宿主机配置" class="headerlink" title="宿主机配置"></a>宿主机配置</h2><p>找到&#x2F;etc&#x2F;network&#x2F;interfaces，在后面添加</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">auto</span> br0     //添加的桥接网卡，新的名字<br><span class="hljs-attribute">iface</span> br0 inet static<br><span class="hljs-attribute">address</span> <span class="hljs-number">10.0.1.60</span>    //宿主机IP<br><span class="hljs-attribute">netmask</span> <span class="hljs-number">255.255.254.0</span><br><span class="hljs-attribute">broadcast</span> <span class="hljs-number">10.0.1.255</span><br><span class="hljs-attribute">gateway</span> <span class="hljs-number">10.0.0.1</span><br><span class="hljs-attribute">dns</span>-nameservers <span class="hljs-number">114.114.114.114</span>  <br><span class="hljs-attribute">bridge_ports</span> enp0s31f6   //宿主机网卡名<br><span class="hljs-attribute">bridge_fd</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>然后在宿主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ifup br0<br></code></pre></td></tr></table></figure><h2 id="虚机配置"><a href="#虚机配置" class="headerlink" title="虚机配置"></a>虚机配置</h2><p>在 <strong>每台</strong> 虚机下配置</p><p>&#x2F;etc&#x2F;hostname<br>sysctl kernel.hostname&#x3D;yourhostname</p><p>打开&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0，依照以下修改，注意：ONBOOT&#x3D;yes和static。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">HWADDR</span>=<span class="hljs-number">52</span>:<span class="hljs-number">54</span>:<span class="hljs-number">00</span>:<span class="hljs-number">2</span>a:b9:f3<br><span class="hljs-attr">TYPE</span>=Ethernet  <br><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">NAME</span>=ens3   //虚机网卡名字<br><span class="hljs-attr">UUID</span>=f9c0608a-<span class="hljs-number">3290</span>-<span class="hljs-number">4</span>a44-b209-<span class="hljs-number">7</span>c25aaa7fec8<br><span class="hljs-attr">DEVICE</span>=ens3  //虚机网卡名字<br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>  //一定<span class="hljs-literal">yes</span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span>  //连外网必备<br><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.152</span>   //你要配的虚机网卡IP，<span class="hljs-number">0</span>网段<br><span class="hljs-attr">PREFIX</span>=<span class="hljs-number">23</span>  //。。<br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span>  //。。<br><span class="hljs-attr">IPV6_PEERDNS</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_PEERROUTES</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h2 id="kvm配置"><a href="#kvm配置" class="headerlink" title="kvm配置"></a>kvm配置</h2><p>打开每台虚机的kvm设置，点击感叹号，点击NIC，找到网络源，选择桥接br0，点击应用确定。然后强制关机再开机（你也可以等待重启）。然后就可以在局域网访问你的虚机了。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span><br></code></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="ubuntu环境设置DNS"><a href="#ubuntu环境设置DNS" class="headerlink" title="ubuntu环境设置DNS"></a>ubuntu环境设置DNS</h3><p>在Ubuntu环境下，打开网页非常缓慢，很可能是DNS设置异常的问题。</p><ul><li><p>方法1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vi /etc/network/interfaces<br>dns-nameservers 114.114.114.114<br></code></pre></td></tr></table></figure></li><li><p>方法2：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>resolvconf<span class="hljs-regexp">/resolv.conf/</span>base  <br>或者<span class="hljs-regexp">/etc/</span>resolvconf<span class="hljs-regexp">/resolv.conf.d/</span>base<br>修改为：<br>nameserver <span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span><br>nameserver <span class="hljs-number">8.8</span>.<span class="hljs-number">4.4</span><br>然后执行resolvconf -u  <br></code></pre></td></tr></table></figure><p>就能在&#x2F;etc&#x2F;resolv.conf文件中多出2行。<br>还有一种方式是修改&#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf&#x2F;head，不过这个文件系统不建议修改。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SingleNumberII</title>
    <link href="/2022/01/08/SingleNumberII/"/>
    <url>/2022/01/08/SingleNumberII/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字-II"><a href="#只出现一次的数字-II" class="headerlink" title="只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">只出现一次的数字 II</a></h1><ul><li><a href="https://yangtzeshore.github.io/2022/01/04/SingleNumberII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/04/SingleNumberII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="只出现一次的数字-II-1"><a href="#只出现一次的数字-II-1" class="headerlink" title="只出现一次的数字 II"></a>只出现一次的数字 II</h4><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">2,2,3,2</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,1,0,1,99]</span><br>输出：<span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li></ul><p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> ones = <span class="hljs-number">0</span>, twos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>    ones = ones ^ <span class="hljs-built_in">num</span> &amp; ~twos;<br>    twos = twos ^ <span class="hljs-built_in">num</span> &amp; ~ones;<br>&#125;<br><span class="hljs-keyword">return</span> ones;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 其实就是一个数学分析题，需要利用取余的方式来计算，中间由两个位的状态机来模拟此数据移动，然后找出规律。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CopyListWithRandomPointer</title>
    <link href="/2022/01/05/CopyListWithRandomPointer/"/>
    <url>/2022/01/05/CopyListWithRandomPointer/</url>
    
    <content type="html"><![CDATA[<h1 id="CopyListWithRandomPointer"><a href="#CopyListWithRandomPointer" class="headerlink" title="CopyListWithRandomPointer"></a>CopyListWithRandomPointer</h1><h1 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">复制带随机指针的链表</a></h1><ul><li><a href="https://yangtzeshore.github.io/2022/01/05/CopyListWithRandomPointer/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/05/CopyListWithRandomPointer/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="复制带随机指针的链表-1"><a href="#复制带随机指针的链表-1" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h4><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/e1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/e2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/e3.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li></ul><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs q">Map&lt;Node, Node&gt; map2 = new HashMap&lt;&gt;();<br>    public Node copyRandomList(Node head) &#123;<br><br>        if (head == <span class="hljs-built_in">null</span>) &#123;<br>            return <span class="hljs-built_in">null</span>;<br>        &#125;<br>        map2.clear();<br>        Node dumb = new Node(<span class="hljs-number">0</span>);<br>        Node cur = head;<br>        Node <span class="hljs-built_in">prev</span> = dumb;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;<br>            Node newNode = new Node(cur.val);<br>            map2.put(cur, newNode);<br>            <span class="hljs-built_in">count</span>++;<br>            <span class="hljs-built_in">prev</span>.<span class="hljs-built_in">next</span> = newNode;<br>            <span class="hljs-built_in">prev</span> = newNode;<br>            cur = cur.<span class="hljs-built_in">next</span>;<br>        &#125;<br><br>        cur = head;<br>        <span class="hljs-built_in">prev</span> = dumb;<br>        <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;<br>            if (cur.random != <span class="hljs-built_in">null</span>) &#123;<br>                <span class="hljs-built_in">prev</span>.<span class="hljs-built_in">next</span>.random = map2.<span class="hljs-built_in">get</span>(cur.random);<br>            &#125;<br>            <span class="hljs-built_in">count</span>++;<br>            <span class="hljs-built_in">prev</span> = <span class="hljs-built_in">prev</span>.<span class="hljs-built_in">next</span>;<br>            cur = cur.<span class="hljs-built_in">next</span>;<br>        &#125;<br>        return dumb.<span class="hljs-built_in">next</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，不难，就是需要记录random的映射关系。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SingleNumber</title>
    <link href="/2022/01/02/SingleNumber/"/>
    <url>/2022/01/02/SingleNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></h2><ul><li><a href="https://yangtzeshore.github.io/2022/01/02/SingleNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/02/SingleNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="只出现一次的数字-1"><a href="#只出现一次的数字-1" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h4><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleNumber</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            nums[<span class="hljs-number">0</span>] = nums[i] ^ nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        SingleNumber singleNumber = <span class="hljs-keyword">new</span> SingleNumber();<br>        <span class="hljs-built_in">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(singleNumber.singleNumber(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(singleNumber.singleNumber(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 就是很简单的数学题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Candy</title>
    <link href="/2022/01/01/Candy/"/>
    <url>/2022/01/01/Candy/</url>
    
    <content type="html"><![CDATA[<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></h2><ul><li><a href="https://yangtzeshore.github.io/2022/01/01/Candy/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/01/Candy/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="分发糖果-1"><a href="#分发糖果-1" class="headerlink" title="分发糖果"></a>分发糖果</h4><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1:</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,0,2]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,2,2]</span><br><span class="hljs-string">输出：4</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="hljs-string">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li>1&lt;&#x3D;n&lt;&#x3D;2∗104</li><li>0&lt;&#x3D;ratings[i]&lt;&#x3D;2∗104</li></ul><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Candy &#123;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> candy(<span class="hljs-type">int</span>[] ratings) &#123;<br>        <span class="hljs-type">int</span> n = ratings.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                right++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = <span class="hljs-number">1</span>;<br>            &#125;<br>            ret += Math.max(left[i], right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        Candy candy = <span class="hljs-built_in">new</span> Candy();<br>        <span class="hljs-type">int</span>[] rating = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(candy.candy(rating));<br><br>        rating = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(candy.candy(rating));<br><br>        rating = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(candy.candy(rating));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>4<br>7<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 其实蛮简单的，就是将规则拆开，左遍历和右遍历取max。看起来很诡异，其实只要明白不小于1的规则，以及升降的含义就好了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GasStation</title>
    <link href="/2021/12/26/GasStation/"/>
    <url>/2021/12/26/GasStation/</url>
    
    <content type="html"><![CDATA[<h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">加油站</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/12/26/GasStation/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/12/26/GasStation/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="加油站-1"><a href="#加油站-1" class="headerlink" title="加油站"></a>加油站</h4><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong></p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br><br>输出: 3<br><br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [2,3,4]<br>cost = [3,4,3]<br><br>输出: -1<br><br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> canCompleteCircuit(<span class="hljs-built_in">int</span>[] gas, <span class="hljs-built_in">int</span>[] cost) &#123;<br>        <span class="hljs-built_in">int</span> n = gas.length;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; <br><br>        <span class="hljs-comment">// 从头到尾遍历每个加油站，并且检查以该加油站为起点，能否行驶一周</span><br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            <span class="hljs-built_in">int</span> sumOfGas  = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总共加的油</span><br>            <span class="hljs-built_in">int</span> SumOfCost = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总共消费的油</span><br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 记录能走过几个站点</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">count</span> &lt; n)&#123;  <span class="hljs-comment">// 退出循环的条件是走过所有的站点</span><br>                <span class="hljs-built_in">int</span> j = (i + <span class="hljs-keyword">count</span>) % n; <span class="hljs-comment">// 加油站是环形的</span><br>                sumOfGas += gas[j];<br>                SumOfCost += cost[j];<br>                <span class="hljs-keyword">if</span>(SumOfCost &gt; sumOfGas)&#123; <span class="hljs-comment">// 如果这个站点发现油不够了</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">count</span>++; <span class="hljs-comment">// 这个站点满足情况</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> == n)&#123;  <span class="hljs-comment">// 如果能环绕一圈</span><br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 不行的话 从下一个站点开始 检查</span><br>                i = i + <span class="hljs-keyword">count</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有加油站作为起点都不满足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">3<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 自己写了一版，效率不高。主要还是有一个主思路：如果x到不了y+1（但能到y），那么从x到y的任一点出发都不可能到达y+1。 因为从其中任一点出发的话，相当于从0开始加油，而如果从x出发到该点则不一定是从0开始加油，&#x2F;&#x2F; 可能还有剩余的油。既然不从0开始都到不了y+1，那么从0开始就更不可能到达y+1了。另外，编码上，用count来计算遍历过的加油站数量，很微妙，然后再用这个计算终点，确实很优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CloneGraph</title>
    <link href="/2021/12/25/CloneGraph/"/>
    <url>/2021/12/25/CloneGraph/</url>
    
    <content type="html"><![CDATA[<h4 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/">克隆图</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/12/25/CloneGraph/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/12/25/CloneGraph/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="克隆图-1"><a href="#克隆图-1" class="headerlink" title="克隆图"></a>克隆图</h4><p>给你无向 <strong><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    public <span class="hljs-keyword">int</span> val;<br>    public List&lt;Node&gt; neighbors;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/133_clone_graph_question.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]<br>输出：[[2,4],[1,3],[2,4],[1,3]]<br>解释：<br>图中有<span class="hljs-number"> 4 </span>个节点。<br>节点<span class="hljs-number"> 1 </span>的值是 1，它有两个邻居：节点<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>节点<span class="hljs-number"> 2 </span>的值是 2，它有两个邻居：节点<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>。<br>节点<span class="hljs-number"> 3 </span>的值是 3，它有两个邻居：节点<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>节点<span class="hljs-number"> 4 </span>的值是 4，它有两个邻居：节点<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/graph.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：adjList = <span class="hljs-string">[[]]</span><br>输出：<span class="hljs-string">[[]]</span><br>解释：输入包含一个空列表。该图仅仅只有一个值为 <span class="hljs-number">1</span> 的节点，它没有任何邻居。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：adjList = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：这个图是空的，它不含任何节点。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/graph-1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：adjList = <span class="hljs-string">[[2],[1]]</span><br>输出：<span class="hljs-string">[[2],[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br>import java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CloneGraph</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">cloneGraph</span>(<span class="hljs-params">Node node</span>)</span> &#123;<br>        Set&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Node dfsNode = dfs(node, <span class="hljs-keyword">set</span>);<br>        node.neighbors = dfsNode.neighbors;<br>        <span class="hljs-keyword">return</span> dfsNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">dfs</span>(<span class="hljs-params">Node node, Set&lt;Integer&gt; <span class="hljs-keyword">set</span></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        List&lt;Node&gt; neighbors = node.neighbors;<br>        Node nodeNew = <span class="hljs-keyword">new</span> Node(node.val);<br>        <span class="hljs-keyword">for</span> (Node neighbor : neighbors) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">set</span>.contains(neighbor.val)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(neighbor.val);<br>            Node nextNode = dfs(neighbor, <span class="hljs-keyword">set</span>);<br>            <span class="hljs-keyword">if</span> (nodeNew.neighbors == <span class="hljs-literal">null</span>) &#123;<br>                List&lt;Node&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.<span class="hljs-keyword">add</span>(nextNode);<br>                nodeNew.neighbors = list;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nodeNew.neighbors.<span class="hljs-keyword">add</span>(nodeNew);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nodeNew;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        CloneGraph s = <span class="hljs-keyword">new</span> CloneGraph();<br>        Node node = <span class="hljs-literal">null</span>;<br>        Node result = s.cloneGraph(node);<br>        System.<span class="hljs-keyword">out</span>.println(result);<br><br>        node = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);<br>        result = s.cloneGraph(node);<br>        System.<span class="hljs-keyword">out</span>.println(result);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params">Node node</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(node.val);<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br>        <span class="hljs-keyword">public</span> List&lt;Node&gt; neighbors;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>()</span> &#123;<br>            val = <span class="hljs-number">0</span>;<br>            neighbors = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> _val</span>)</span> &#123;<br>            val = _val;<br>            neighbors = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> _val, ArrayList&lt;Node&gt; _neighbors</span>)</span> &#123;<br>            val = _val;<br>            neighbors = _neighbors;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 其实并不难，需要注意遍历然后记录遍历，还有就是返回遍历的克隆节点。如果是1-2这种，1的邻居当然是2，2的邻居当然也是1，需要注意将已经遍历收集到的邻居直接返回，不需要再次遍历邻居。好久没有做算法题，终于不忙了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PalindromePartitioning</title>
    <link href="/2021/09/21/PalindromePartitioning/"/>
    <url>/2021/09/21/PalindromePartitioning/</url>
    
    <content type="html"><![CDATA[<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/21/PalindromePartitioning/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/21/PalindromePartitioning/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="分割回文串-1"><a href="#分割回文串-1" class="headerlink" title="分割回文串"></a>分割回文串</h4><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-keyword">partition</span>(String s) &#123;<br>        <span class="hljs-type">int</span> len = s.length();<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        // Stack 这个类 Java 的文档里推荐写成 Deque&lt;<span class="hljs-type">Integer</span>&gt; stack = <span class="hljs-built_in">new</span> ArrayDeque&lt;<span class="hljs-type">Integer</span>&gt;();<br>        // 注意：只使用 stack 相关的接口<br>        Deque&lt;String&gt; stack = <span class="hljs-built_in">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        dfs(charArray, <span class="hljs-number">0</span>, len, stack, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param charArray</span><br><span class="hljs-comment">     * @param index     起始字符的索引</span><br><span class="hljs-comment">     * @param len       字符串 s 的长度，可以设置为全局变量</span><br><span class="hljs-comment">     * @param path      记录从根结点到叶子结点的路径</span><br><span class="hljs-comment">     * @param res       记录所有的结果</span><br><span class="hljs-comment">     */</span><br>    private <span class="hljs-type">void</span> dfs(<span class="hljs-type">char</span>[] charArray, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-type">int</span> len, Deque&lt;String&gt; <span class="hljs-type">path</span>, List&lt;List&lt;String&gt;&gt; res) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == len) &#123;<br>            res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">index</span>; i &lt; len; i++) &#123;<br>            // 因为截取字符串是消耗性能的，因此，采用传子串下标的方式判断一个子串是否是回文子串<br>            <span class="hljs-keyword">if</span> (!checkPalindrome(charArray, <span class="hljs-keyword">index</span>, i)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">path</span>.addLast(<span class="hljs-built_in">new</span> String(charArray, <span class="hljs-keyword">index</span>, i + <span class="hljs-number">1</span> - <span class="hljs-keyword">index</span>));<br>            dfs(charArray, i + <span class="hljs-number">1</span>, len, <span class="hljs-type">path</span>, res);<br>            <span class="hljs-type">path</span>.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这一步的时间复杂度是 O(N)，优化的解法是，先采用动态规划，把回文子串的结果记录在一个表格里</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param charArray</span><br><span class="hljs-comment">     * @param left      子串的左边界，可以取到</span><br><span class="hljs-comment">     * @param right     子串的右边界，可以取到</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    private <span class="hljs-type">boolean</span> checkPalindrome(<span class="hljs-type">char</span>[] charArray, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (charArray[left] != charArray[right]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right<span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 递归加深度遍历，主要是题目意思没有明白，其实还是很简单的，难度中等没毛病。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SurroundedRegions</title>
    <link href="/2021/09/16/SurroundedRegions/"/>
    <url>/2021/09/16/SurroundedRegions/</url>
    
    <content type="html"><![CDATA[<h4 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/16/SurroundedRegions/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/16/SurroundedRegions/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="被围绕的区域-1"><a href="#被围绕的区域-1" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h4><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/xogrid.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]<br>解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 都不会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。 任何不在边界上，或不与边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 相连的 <span class="hljs-string">&#x27;O&#x27;</span> 最终都会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 <br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：board = <span class="hljs-string">[[&quot;X&quot;]]</span><br>输出：<span class="hljs-string">[[&quot;X&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"> <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br><br>        m = board.length; <span class="hljs-comment">// 行</span><br>        n = board[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 列</span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dfs(board, <span class="hljs-number">0</span>, i);<br>            dfs(board, m - <span class="hljs-number">1</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            dfs(board, i, <span class="hljs-number">0</span>);<br>            dfs(board, i, n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)</span> </span>&#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; m - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; n - <span class="hljs-number">1</span> || board[x][y] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        board[x][y] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>        dfs(board, x + <span class="hljs-number">1</span>, y);<br>        dfs(board, x - <span class="hljs-number">1</span>, y);<br>        dfs(board, x, y + <span class="hljs-number">1</span>);<br>        dfs(board, x, y - <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 注意dfs的结束条件是不等于O，因为边界可能被来回dfs，O会被标记为A，不会来回标记。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SumRootToLeafNumbers</title>
    <link href="/2021/09/13/SumRootToLeafNumbers/"/>
    <url>/2021/09/13/SumRootToLeafNumbers/</url>
    
    <content type="html"><![CDATA[<h4 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">求根节点到叶节点数字之和</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/13/SumRootToLeafNumbers/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/13/SumRootToLeafNumbers/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="求根节点到叶节点数字之和-1"><a href="#求根节点到叶节点数字之和-1" class="headerlink" title="求根节点到叶节点数字之和"></a>求根节点到叶节点数字之和</h4><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/num1tree.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">25</span><br>解释：<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span> 代表数字 <span class="hljs-number">12</span><br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span> 代表数字 <span class="hljs-number">13</span><br>因此，数字总和 = <span class="hljs-number">12</span> + <span class="hljs-number">13</span> = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/num2tree.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：root = [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1026</span><br>解释：<br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">5</span> 代表数字 <span class="hljs-number">495</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">1</span> 代表数字 <span class="hljs-number">491</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> 代表数字 <span class="hljs-number">40</span><br>因此，数字总和 = <span class="hljs-number">495</span> + <span class="hljs-number">491</span> + <span class="hljs-number">40</span> = <span class="hljs-number">1026</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过 <code>10</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>    result = <span class="hljs-number">0</span>;<br>    dfs(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br><br>   <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>        result += cur * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>)&#123;<br>        dfs(root.left, cur * <span class="hljs-number">10</span> + root.val);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>        dfs(root.right, cur * <span class="hljs-number">10</span> + root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是简单的dfs。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestConsecutiveSequence</title>
    <link href="/2021/09/13/LongestConsecutiveSequence/"/>
    <url>/2021/09/13/LongestConsecutiveSequence/</url>
    
    <content type="html"><![CDATA[<h4 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/13/LongestConsecutiveSequence/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/13/LongestConsecutiveSequence/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="长连续序列"><a href="#长连续序列" class="headerlink" title="长连续序列"></a>长连续序列</h4><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0&lt;&#x3D;nums.length&lt;&#x3D;105</li><li>−109&lt;&#x3D;nums[i]&lt;&#x3D;109</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-built_in">int</span> longestConsecutive(<span class="hljs-built_in">int</span>[] nums) &#123;<br><br>    <span class="hljs-built_in">Set</span>&lt;Integer&gt; num_set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;<br>        num_set.add(<span class="hljs-built_in">num</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> longestStreak = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : num_set) &#123;<br>        <span class="hljs-keyword">if</span> (!num_set.contains(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-built_in">int</span> currentNum = <span class="hljs-built_in">num</span>;<br>            <span class="hljs-built_in">int</span> currentStreak = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (num_set.contains(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                currentNum += <span class="hljs-number">1</span>;<br>                currentStreak += <span class="hljs-number">1</span>;<br>            &#125;<br><br>            longestStreak = Math.max(longestStreak, currentStreak);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> longestStreak;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，主要还是if的判断，形象的理解就是，如果自己没有下限，就要往上累加；如果自己有下限，那就是已经被算计过了，这样避免了重复计算，达不到O(n)要求。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WordLadder</title>
    <link href="/2021/09/12/WordLadder/"/>
    <url>/2021/09/12/WordLadder/</url>
    
    <content type="html"><![CDATA[<h4 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/12/WordLadder/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/12/WordLadder/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="单词接龙-1"><a href="#单词接龙-1" class="headerlink" title="单词接龙"></a>单词接龙</h4><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 <code>beginWord</code> 。</li><li>序列中最后一个单词是 <code>endWord</code> 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 <code>wordList</code> 中的单词。</li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br>输出：<span class="hljs-number">5</span><br>解释：一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>, 返回它的长度 <span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li><li><code>beginWord != endWord</code></li><li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Map&lt;String, <span class="hljs-type">Integer</span>&gt; wordId = <span class="hljs-built_in">new</span> HashMap&lt;String, <span class="hljs-type">Integer</span>&gt;();<br>    List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; edge = <span class="hljs-built_in">new</span> ArrayList&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;();<br>    <span class="hljs-type">int</span> nodeNum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;<br>        <span class="hljs-keyword">for</span> (String word : wordList) &#123;<br>            addEdge(word);<br>        &#125;<br>        addEdge(beginWord);<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] disBegin = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nodeNum];<br>        Arrays.fill(disBegin, <span class="hljs-type">Integer</span>.MAX_VALUE);<br>        <span class="hljs-type">int</span> beginId = wordId.<span class="hljs-keyword">get</span>(beginWord);<br>        disBegin[beginId] = <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">Integer</span>&gt; queBegin = <span class="hljs-built_in">new</span> LinkedList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        queBegin.offer(beginId);<br>        <br>        <span class="hljs-type">int</span>[] disEnd = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nodeNum];<br>        Arrays.fill(disEnd, <span class="hljs-type">Integer</span>.MAX_VALUE);<br>        <span class="hljs-type">int</span> endId = wordId.<span class="hljs-keyword">get</span>(endWord);<br>        disEnd[endId] = <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">Integer</span>&gt; queEnd = <span class="hljs-built_in">new</span> LinkedList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        queEnd.offer(endId);<br><br>        <span class="hljs-keyword">while</span> (!queBegin.isEmpty() &amp;&amp; !queEnd.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> queBeginSize = queBegin.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queBeginSize; ++i) &#123;<br>                <span class="hljs-type">int</span> nodeBegin = queBegin.poll();<br>                <span class="hljs-keyword">if</span> (disEnd[nodeBegin] != <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">return</span> (disBegin[nodeBegin] + disEnd[nodeBegin]) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.<span class="hljs-keyword">get</span>(nodeBegin)) &#123;<br>                    <span class="hljs-keyword">if</span> (disBegin[it] == <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                        disBegin[it] = disBegin[nodeBegin] + <span class="hljs-number">1</span>;<br>                        queBegin.offer(it);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> queEndSize = queEnd.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queEndSize; ++i) &#123;<br>                <span class="hljs-type">int</span> nodeEnd = queEnd.poll();<br>                <span class="hljs-keyword">if</span> (disBegin[nodeEnd] != <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">return</span> (disBegin[nodeEnd] + disEnd[nodeEnd]) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.<span class="hljs-keyword">get</span>(nodeEnd)) &#123;<br>                    <span class="hljs-keyword">if</span> (disEnd[it] == <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                        disEnd[it] = disEnd[nodeEnd] + <span class="hljs-number">1</span>;<br>                        queEnd.offer(it);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(String word) &#123;<br>        addWord(word);<br>        <span class="hljs-type">int</span> id1 = wordId.<span class="hljs-keyword">get</span>(word);<br>        <span class="hljs-type">char</span>[] <span class="hljs-keyword">array</span> = word.toCharArray();<br>        <span class="hljs-type">int</span> length = <span class="hljs-keyword">array</span>.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">char</span> tmp = <span class="hljs-keyword">array</span>[i];<br>            <span class="hljs-keyword">array</span>[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            String newWord = <span class="hljs-built_in">new</span> String(<span class="hljs-keyword">array</span>);<br>            addWord(newWord);<br>            <span class="hljs-type">int</span> id2 = wordId.<span class="hljs-keyword">get</span>(newWord);<br>            edge.<span class="hljs-keyword">get</span>(id1).<span class="hljs-keyword">add</span>(id2);<br>            edge.<span class="hljs-keyword">get</span>(id2).<span class="hljs-keyword">add</span>(id1);<br>            <span class="hljs-keyword">array</span>[i] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addWord(String word) &#123;<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(word)) &#123;<br>            wordId.put(word, nodeNum++);<br>            edge.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，反而我觉得这道题应该排在上面一道题前面，也是图的算法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WordLadderII</title>
    <link href="/2021/09/11/WordLadderII/"/>
    <url>/2021/09/11/WordLadderII/</url>
    
    <content type="html"><![CDATA[<h4 id="单词接龙-II"><a href="#单词接龙-II" class="headerlink" title="单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">单词接龙 II</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/11/WordLadderII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/11/WordLadderII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="单词接龙-II-1"><a href="#单词接龙-II-1" class="headerlink" title="单词接龙 II"></a>单词接龙 II</h4><p>按字典 <code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>这样的单词序列，并满足：</p><ul><li>每对相邻的单词之间仅有单个字母不同。</li><li>转换过程中的每个单词 <code>si</code>（<code>1 &lt;= i &lt;= k</code>）必须是字典 <code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</li><li><code>sk == endWord</code></li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表<code>[beginWord, s1, s2, ..., sk]</code> 的形式返回。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br>输出：[[<span class="hljs-string">&quot;hit&quot;</span>,<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>],[<span class="hljs-string">&quot;hit&quot;</span>,<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]]<br>解释：存在 <span class="hljs-number">2</span> 种最短的转换序列：<br><span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span><br><span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;lot&quot;</span> -&gt; <span class="hljs-string">&quot;log&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br>输出：[]<br>解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典 wordList 中，所以不存在符合要求的转换序列。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 7</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li><li><code>beginWord != endWord</code></li><li><code>wordList</code> 中的所有单词 <strong>互不相同</strong></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-type">String</span>&gt;&gt; <span class="hljs-built_in">findLadders</span>(<span class="hljs-type">String</span> beginWord, <span class="hljs-type">String</span> endWord, List&lt;<span class="hljs-type">String</span>&gt; wordList) &#123;<br>        List&lt;List&lt;<span class="hljs-type">String</span>&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span><br>        Set&lt;<span class="hljs-type">String</span>&gt; dict = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordList);<br>        <span class="hljs-comment">// 特殊用例判断</span><br>        <span class="hljs-keyword">if</span> (!dict.<span class="hljs-built_in">contains</span>(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        dict.<span class="hljs-built_in">remove</span>(beginWord);<br><br>        <span class="hljs-comment">// 第 1 步：广度优先遍历建图</span><br>        <span class="hljs-comment">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层</span><br>        Map&lt;<span class="hljs-type">String</span>, Integer&gt; steps = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        steps.<span class="hljs-built_in">put</span>(beginWord, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span><br>        Map&lt;<span class="hljs-type">String</span>, List&lt;<span class="hljs-type">String</span>&gt;&gt; from = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> found = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> wordLen = beginWord.<span class="hljs-built_in">length</span>();<br>        Queue&lt;<span class="hljs-type">String</span>&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.<span class="hljs-built_in">offer</span>(beginWord);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">String</span> currWord = queue.<span class="hljs-built_in">poll</span>();<br>                <span class="hljs-type">char</span>[] charArray = currWord.<span class="hljs-built_in">toCharArray</span>();<br>                <span class="hljs-comment">// 将每一位替换成 26 个小写英文字母</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; wordLen; j++) &#123;<br>                    <span class="hljs-type">char</span> origin = charArray[j];<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++) &#123;<br>                        charArray[j] = c;<br>                        <span class="hljs-type">String</span> nextWord = <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(charArray);<br>                        <span class="hljs-keyword">if</span> (steps.<span class="hljs-built_in">containsKey</span>(nextWord) &amp;&amp; step == steps.<span class="hljs-built_in">get</span>(nextWord)) &#123;<br>                            from.<span class="hljs-built_in">get</span>(nextWord).<span class="hljs-built_in">add</span>(currWord);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (!dict.<span class="hljs-built_in">contains</span>(nextWord)) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span><br>                        dict.<span class="hljs-built_in">remove</span>(nextWord);<br>                        <span class="hljs-comment">// 这一层扩展出的单词进入队列</span><br>                        queue.<span class="hljs-built_in">offer</span>(nextWord);<br><br>                        <span class="hljs-comment">// 记录 nextWord 从 currWord 而来</span><br>                        from.<span class="hljs-built_in">putIfAbsent</span>(nextWord, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>                        from.<span class="hljs-built_in">get</span>(nextWord).<span class="hljs-built_in">add</span>(currWord);<br>                        <span class="hljs-comment">// 记录 nextWord 的 step</span><br>                        steps.<span class="hljs-built_in">put</span>(nextWord, step);<br>                        <span class="hljs-keyword">if</span> (nextWord.<span class="hljs-built_in">equals</span>(endWord)) &#123;<br>                            found = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                    charArray[j] = origin;<br>                &#125;<br>            &#125;<br>            step++;<br>            <span class="hljs-keyword">if</span> (found) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span><br>        <span class="hljs-keyword">if</span> (found) &#123;<br>            Deque&lt;<span class="hljs-type">String</span>&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>            path.<span class="hljs-built_in">add</span>(endWord);<br>            <span class="hljs-built_in">dfs</span>(from, path, beginWord, endWord, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Map&lt;<span class="hljs-type">String</span>, List&lt;<span class="hljs-type">String</span>&gt;&gt; from, Deque&lt;<span class="hljs-type">String</span>&gt; path, <span class="hljs-type">String</span> beginWord, <span class="hljs-type">String</span> cur, List&lt;List&lt;<span class="hljs-type">String</span>&gt;&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">equals</span>(beginWord)) &#123;<br>            res.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> precursor : from.<span class="hljs-built_in">get</span>(cur)) &#123;<br>            path.<span class="hljs-built_in">addFirst</span>(precursor);<br>            <span class="hljs-built_in">dfs</span>(from, path, beginWord, precursor, res);<br>            path.<span class="hljs-built_in">removeFirst</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，这是典型的图算法，算是入门。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidPalindrome</title>
    <link href="/2021/09/04/ValidPalindrome/"/>
    <url>/2021/09/04/ValidPalindrome/</url>
    
    <content type="html"><![CDATA[<h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h3><ul><li><a href="https://yangtzeshore.github.io/2021/09/04/ValidPalindrome/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/04/ValidPalindrome/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="验证回文串-1"><a href="#验证回文串-1" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;amanaplanacanalpanama&quot;</span> 是回文串<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;race a car&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;raceacar&quot;</span> 不是回文串<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;s.length&lt;&#x3D;2∗105</li><li>字符串 <code>s</code> 由 ASCII 字符组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nsis">public boolean isPalindrome(String s) &#123;<br>       s = s.toLowerCase()<span class="hljs-comment">;</span><br>       int <span class="hljs-literal">left</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>       int <span class="hljs-literal">right</span> = s.length() - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>       while (<span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>) &#123;<br>           while (<span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span> &amp;&amp; !isValidChar(s.charAt(<span class="hljs-literal">left</span>))) &#123;<br>               <span class="hljs-literal">left</span> ++<span class="hljs-comment">;</span><br>           &#125;<br>           while (<span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span> &amp;&amp; !isValidChar(s.charAt(<span class="hljs-literal">right</span>))) &#123;<br>               <span class="hljs-literal">right</span> --<span class="hljs-comment">;</span><br>           &#125;<br>           if (s.charAt(<span class="hljs-literal">left</span>) != s.charAt(<span class="hljs-literal">right</span>)) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>           &#125;<br>           <span class="hljs-literal">left</span>++<span class="hljs-comment">;</span><br>           <span class="hljs-literal">right</span>--<span class="hljs-comment">;</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br>   &#125;<br><br>   private boolean isValidChar(char x) &#123;<br>       <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || (x &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; x &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || (x &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<span class="hljs-comment">;</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实简单的题目实现起来才是最难的。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeMaximumPathSum</title>
    <link href="/2021/08/31/BinaryTreeMaximumPathSum/"/>
    <url>/2021/08/31/BinaryTreeMaximumPathSum/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/31/BinaryTreeMaximumPathSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/31/BinaryTreeMaximumPathSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树中的最大路径和-1"><a href="#二叉树中的最大路径和-1" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h4><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/exx1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/exx2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 [1,3∗104]</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xquery">int<span class="hljs-built_in"> max</span> = Integer.MIN_VALUE;<br>   public int maxPathSum(TreeNode<span class="hljs-built_in"> root</span>) &#123;<br>       maxGain<span class="hljs-built_in">(root</span>);<br>       <span class="hljs-keyword">return</span><span class="hljs-built_in"> max</span>;<br>   &#125;<br><br>   private int maxGain (TreeNode<span class="hljs-built_in"> root</span>) &#123;<br>       int gain;<br>       int maxPath;<br>       <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span> == null) &#123;<br>           <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.left == null &amp;&amp;<span class="hljs-built_in"> root</span>.right == null) &#123;<br>           gain = maxPath =<span class="hljs-built_in"> root</span>.val;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           int left = Math<span class="hljs-built_in">.max</span>(<span class="hljs-number">0</span>, maxGain<span class="hljs-built_in">(root</span>.left));<br>           int right = Math<span class="hljs-built_in">.max</span>(<span class="hljs-number">0</span>, maxGain<span class="hljs-built_in">(root</span>.right));<br>           maxPath =<span class="hljs-built_in"> root</span>.val + left +right;<br>           gain =<span class="hljs-built_in"> root</span>.val + Math<span class="hljs-built_in">.max</span>(left, right);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (maxPath &gt;<span class="hljs-built_in"> max</span>) &#123;<br>          <span class="hljs-built_in"> max</span> = maxPath;<br>       &#125;<br>       <span class="hljs-keyword">return</span> gain;<br>   &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，需要想通父节点的作用，一个是给上面节点贡献值，一个是自己也有可能是某条路径最大值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BestTimeToBuyAndSellStockII</title>
    <link href="/2021/08/23/BestTimeToBuyAndSellStockII/"/>
    <url>/2021/08/23/BestTimeToBuyAndSellStockII/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/23/BestTimeToBuyAndSellStockII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/23/BestTimeToBuyAndSellStockII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="买卖股票的最佳时机-II-1"><a href="#买卖股票的最佳时机-II-1" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h4><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>1&lt;&#x3D;prices.length&lt;&#x3D;3∗104</li><li>0&lt;&#x3D;prices[i]&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl">public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">length</span> = prices.<span class="hljs-built_in">length</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">length</span>; i++) &#123;<br>            ans += Math.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，非常简单。只是大晚上写代码好困。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BestTimeToBuyAndSellStock</title>
    <link href="/2021/08/22/BestTimeToBuyAndSellStock/"/>
    <url>/2021/08/22/BestTimeToBuyAndSellStock/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/19/BestTimeToBuyAndSellStock/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/19/BestTimeToBuyAndSellStock/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="买卖股票的最佳时机-1"><a href="#买卖股票的最佳时机-1" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>1&lt;&#x3D;prices.length&lt;&#x3D;105</li><li>0&lt;&#x3D;prices[i]&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl">public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">length</span> = prices.<span class="hljs-built_in">length</span>;<br>        <span class="hljs-type">int</span> minPrice = Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) &#123;<br>                minPrice = prices[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                maxProfit = Math.<span class="hljs-built_in">max</span>(maxProfit, prices[i] - minPrice);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，非常简单。最近入职新公司了，没时间写算法了，以后996只能抽空写了，好累。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Triangle</title>
    <link href="/2021/08/17/Triangle/"/>
    <url>/2021/08/17/Triangle/</url>
    
    <content type="html"><![CDATA[<h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/17/Triangle/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/17/Triangle/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="三角形最小路径和-1"><a href="#三角形最小路径和-1" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></h4><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong>与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标<code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span><br>输出：<span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li>−104&lt;&#x3D;triangle[i][j]&lt;&#x3D;104</li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> minimumTotal(List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; triangle) &#123;<br><span class="hljs-type">int</span> n = triangle.size();<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        f[<span class="hljs-number">0</span>] = triangle.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + triangle.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">get</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; <span class="hljs-comment">--j) &#123;</span><br>                f[j] = Math.min(f[j - <span class="hljs-number">1</span>], f[j]) + triangle.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">get</span>(j);<br>            &#125;<br>            f[<span class="hljs-number">0</span>] += triangle.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> minTotal = f[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            minTotal = Math.min(minTotal, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minTotal;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，非常简单的一道动态规划。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PascalsTriangleII</title>
    <link href="/2021/08/14/PascalsTriangleII/"/>
    <url>/2021/08/14/PascalsTriangleII/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a>杨辉三角 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/14/PascalsTriangleII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/14/PascalsTriangleII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="杨辉三角-II-1"><a href="#杨辉三角-II-1" class="headerlink" title="杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">杨辉三角 II</a></h4><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: rowIndex = 3</span><br><span class="hljs-section">输出: [1,3,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: rowIndex = 0</span><br><span class="hljs-section">输出: [1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: rowIndex = 1</span><br><span class="hljs-section">输出: [1,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 33</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PascalsTriangleII &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;<span class="hljs-type">Integer</span>&gt; getRow(<span class="hljs-type">int</span> rowIndex) &#123;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; prev = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        prev.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>        List&lt;<span class="hljs-type">Integer</span>&gt; cur = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= rowIndex) &#123;<br>            cur = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (j &lt;= i) &#123;<br>                <span class="hljs-keyword">if</span> (j &lt;= <span class="hljs-number">0</span> || j == i) &#123;<br>                    cur.<span class="hljs-keyword">add</span>(prev.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cur.<span class="hljs-keyword">add</span>(prev.<span class="hljs-keyword">get</span>(j) + prev.<span class="hljs-keyword">get</span>(j - <span class="hljs-number">1</span>));<br>                &#125;<br>                j++;<br>            &#125;<br>            i++;<br>            prev = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getRow(<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。一定要懂杨辉三角的原理。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PascalsTriangle</title>
    <link href="/2021/08/11/PascalsTriangle/"/>
    <url>/2021/08/11/PascalsTriangle/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/11/PascalsTriangle/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/11/PascalsTriangle/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="杨辉三角-1"><a href="#杨辉三角-1" class="headerlink" title="杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/">杨辉三角</a></h4><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: numRows = 5<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: numRows = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PascalsTriangle &#123;<br><br>    // 边界条件很好算，就是<span class="hljs-number">1</span>，其余的不要看三角形，直接顶格对齐，就会发现规律是自己的位置和减一<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; generate(<span class="hljs-type">int</span> numRows) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; rowTemp = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || j == i) &#123;<br>                    rowTemp.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; lastRow = ans.<span class="hljs-keyword">get</span>(i - <span class="hljs-number">1</span>);<br>                    rowTemp.<span class="hljs-keyword">add</span>(lastRow.<span class="hljs-keyword">get</span>(j) + lastRow.<span class="hljs-keyword">get</span>(j - <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            ans.<span class="hljs-keyword">add</span>(rowTemp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。一定要懂杨辉三角的原理。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PopulatingNextRightPointersInEachNodeII</title>
    <link href="/2021/08/07/PopulatingNextRightPointersInEachNodeII/"/>
    <url>/2021/08/07/PopulatingNextRightPointersInEachNodeII/</url>
    
    <content type="html"><![CDATA[<h3 id="填充每个节点的下一个右侧节点指针-II"><a href="#填充每个节点的下一个右侧节点指针-II" class="headerlink" title="填充每个节点的下一个右侧节点指针 II"></a>填充每个节点的下一个右侧节点指针 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/07/PopulatingNextRightPointersInEachNodeII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/07/PopulatingNextRightPointersInEachNodeII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="填充每个节点的下一个右侧节点指针-II-1"><a href="#填充每个节点的下一个右侧节点指针-II-1" class="headerlink" title="填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针 II</a></h4><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例 ：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/117_sample.png" alt="img"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-meta">#,2,3,#,4,5,7,#]</span><br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="hljs-keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 <span class="hljs-keyword">next</span> 指针连接），<span class="hljs-string">&#x27;#&#x27;</span> 表示每层的末尾。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">package algorithm;<br><br>public class PopulatingNextRightPointersInEachNodeII &#123;<br><br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">last</span> = null, nextStart = null;<br><br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">connect</span>(<span class="hljs-keyword">Node</span> <span class="hljs-title">root</span>) &#123;<br>        if (root == null) &#123;<br>            return null;<br>        &#125;<br>        <span class="hljs-keyword">Node</span> <span class="hljs-title">start</span> = root;<br>        while (<span class="hljs-literal">start</span> != null) &#123;<br>            last = null;<br>            nextStart = null;<br>            for (<span class="hljs-keyword">Node</span> <span class="hljs-title">p</span> = <span class="hljs-literal">start</span>; p != null; p = p.next) &#123;<br>                if (p.left != null) &#123;<br>                    handle(p.left);<br>                &#125;<br>                if (p.right != null) &#123;<br>                    handle(p.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-literal">start</span> = nextStart;<br>        &#125;<br>        return root;<br>    &#125;<br><br>    public void handle(<span class="hljs-keyword">Node</span> <span class="hljs-title">p</span>) &#123;<br>        if (last != null) &#123;<br>            last.next = p;<br>        &#125;<br>        if (nextStart == null) &#123;<br>            nextStart = p;<br>        &#125;<br>        last = p;<br>    &#125;<br><br>    class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">        public</span> int val;<br>        public <span class="hljs-keyword">Node</span> <span class="hljs-title">left</span>;<br>        public <span class="hljs-keyword">Node</span> <span class="hljs-title">right</span>;<br>        public <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;<br><br>        public <span class="hljs-keyword">Node</span><span class="hljs-title">() &#123;&#125;</span><br><span class="hljs-title"></span><br><span class="hljs-title">        public</span> <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> _val) &#123;<br>            val = _val;<br>        &#125;<br><br>        public <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> _val, <span class="hljs-keyword">Node</span> <span class="hljs-title">_left</span>, <span class="hljs-keyword">Node</span> <span class="hljs-title">_right</span>, <span class="hljs-keyword">Node</span> <span class="hljs-title">_next</span>) &#123;<br>            val = _val;<br>            left = _left;<br>            right = _right;<br>            next = _next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实是利用两个节点承载前后关系。受上题影响，居然没写出来，哎。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PopulatingNextRightPointersInEachNode</title>
    <link href="/2021/08/04/PopulatingNextRightPointersInEachNode/"/>
    <url>/2021/08/04/PopulatingNextRightPointersInEachNode/</url>
    
    <content type="html"><![CDATA[<h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/04/PopulatingNextRightPointersInEachNode/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/04/PopulatingNextRightPointersInEachNode/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="填充每个节点的下一个右侧节点指针-1"><a href="#填充每个节点的下一个右侧节点指针-1" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></h4><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例 ：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/116_sample.png" alt="img"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-meta">#,2,3,#,4,5,6,7,#]</span><br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="hljs-keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 <span class="hljs-keyword">next</span> 指针连接，<span class="hljs-string">&#x27;#&#x27;</span> 标志着每一层的结束。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量少于 <code>4096</code></li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PopulatingNextRightPointersInEachNode</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Node connect(Node root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">// 从根节点开</span><br>        Node leftmost = root;<br><br>        <span class="hljs-keyword">while</span> (leftmost.left != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span><br>            Node head = leftmost;<br><br>            <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br><br>                <span class="hljs-comment">// CONNECTION 1</span><br>                head.left.<span class="hljs-keyword">next</span> = head.right;<br><br>                <span class="hljs-comment">// CONNECTION 2</span><br>                <span class="hljs-keyword">if</span> (head.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>                    head.right.<span class="hljs-keyword">next</span> = head.<span class="hljs-keyword">next</span>.left;<br>                &#125;<br><br>                <span class="hljs-comment">// 指针向后移动</span><br>                head = head.<span class="hljs-keyword">next</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 去下一层的最左的节点</span><br>            leftmost = leftmost.left;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>        <span class="hljs-keyword">public</span> Node <span class="hljs-keyword">next</span>;<br><br>        <span class="hljs-keyword">public</span> Node() &#123;&#125;<br><br>        <span class="hljs-keyword">public</span> Node(<span class="hljs-built_in">int</span> _val) &#123;<br>            val = _val;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Node(<span class="hljs-built_in">int</span> _val, Node _left, Node _right, Node _next) &#123;<br>            val = _val;<br>            left = _left;<br>            right = _right;<br>            <span class="hljs-keyword">next</span> = _next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，利用完美二叉树特点和上层已经链接的线索，这道题这么简单，看了答案，看来编程需要努力。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DistinctSubsequences</title>
    <link href="/2021/08/01/DistinctSubsequences/"/>
    <url>/2021/08/01/DistinctSubsequences/</url>
    
    <content type="html"><![CDATA[<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/01/DistinctSubsequences/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/01/DistinctSubsequences/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同的子序列-1"><a href="#不同的子序列-1" class="headerlink" title="不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h4><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;rabbbit&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;rabbit&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">3</span> 种可以从 s 中得到 <span class="hljs-string">&quot;rabbit&quot;</span> 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：s = <span class="hljs-string">&quot;babgbag&quot;</span>, t = <span class="hljs-string">&quot;bag&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">5</span> 种可以从 s 中得到 <span class="hljs-string">&quot;bag&quot;</span> 的方案。 <br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DistinctSubsequences &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> numDistinct(String s, String t) &#123;<br>        <span class="hljs-type">int</span> m = t.length();<br>        <span class="hljs-type">int</span> n = s.length();<br>        <span class="hljs-type">int</span>[][] <span class="hljs-keyword">array</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        Arrays.fill(<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(j - <span class="hljs-number">1</span>) == t.charAt(i - <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">array</span>[i][j] = <span class="hljs-keyword">array</span>[i][j - <span class="hljs-number">1</span>] + <span class="hljs-keyword">array</span>[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">array</span>[i][j] = <span class="hljs-keyword">array</span>[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>[m][n];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        numDistinct(&quot;rabbbit&quot;, &quot;rabbit&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单。动态规划。不过我的效率一般，需要优化。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FlattenBinaryTreeToLinkedList</title>
    <link href="/2021/07/31/FlattenBinaryTreeToLinkedList/"/>
    <url>/2021/07/31/FlattenBinaryTreeToLinkedList/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/31/FlattenBinaryTreeToLinkedList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/31/FlattenBinaryTreeToLinkedList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树展开为链表-1"><a href="#二叉树展开为链表-1" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/flaten.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlattenBinaryTreeToLinkedList</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        queue.clear();<br>        dfs(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">lamb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">while</span> (queue.size() &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            node.left = <span class="hljs-literal">null</span>;<br>            node.right = <span class="hljs-literal">null</span>;<br>            lamb.right = node;<br>            lamb = lamb.right;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        queue.offer(root);<br>        dfs(root.left);<br>        dfs(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 1,2,3,3,4,4,5</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n2.left = n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>        n2.right = n5;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>);<br>        n3.right = n6;<br><br>        flatten(n1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单。效率当然也是一般。后续有时间可以优化一下思路。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PathSum</title>
    <link href="/2021/07/26/PathSum/"/>
    <url>/2021/07/26/PathSum/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/26/PathSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/26/PathSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="路径总和-1"><a href="#路径总和-1" class="headerlink" title="路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></h4><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], targetSum = <span class="hljs-number">5</span><br>输出<span class="hljs-built_in">：false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], targetSum = <span class="hljs-number">0</span><br>输出<span class="hljs-built_in">：false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathSum</span> &#123;<br><br>    <span class="hljs-keyword">private</span> boolean flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> boolean hasPathSum(TreeNode root, int targetSum) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        dfs(root, targetSum, root.<span class="hljs-keyword">val</span>);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void dfs(TreeNode root, int targetSum, int sumTemp) &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sumTemp == targetSum) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            dfs(root.left, targetSum, sumTemp + root.left.<span class="hljs-keyword">val</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            dfs(root.right, targetSum, sumTemp + root.right.<span class="hljs-keyword">val</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，递归调用分解问题。对于递归的理解需要加强。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumDepthOfBinaryTree</title>
    <link href="/2021/07/25/MinimumDepthOfBinaryTree/"/>
    <url>/2021/07/25/MinimumDepthOfBinaryTree/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/25/MinimumDepthOfBinaryTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/25/MinimumDepthOfBinaryTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/balance_1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 [0,105] 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinimumDepthOfBinaryTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> int minDepth(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        int min_depth = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            min_depth = Math.min(minDepth(root.left), min_depth);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            min_depth = Math.min(minDepth(root.right), min_depth);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min_depth + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，递归调用分解问题。对于递归的理解需要加强。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BalancedBinaryTree</title>
    <link href="/2021/07/19/BalancedBinaryTree/"/>
    <url>/2021/07/19/BalancedBinaryTree/</url>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/19/BalancedBinaryTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/19/BalancedBinaryTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/balance_1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/balance_2.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = []<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li>−104&lt;&#x3D;Node.val&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BalancedBinaryTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> boolean isBalanced(TreeNode root) &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> boolean dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        int left = deep(root.left);<br>        int right = deep(root.right);<br>        <span class="hljs-keyword">if</span> (Math.abs(left - right) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dfs(root.left)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dfs(root.right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> int deep(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int left = deep(root.left) + <span class="hljs-number">1</span>;<br>        int right = deep(root.right) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.max(left, right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，两次递归。先遍历，然后找出相应节点的深度。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConvertSortedListToBinarySearchTree</title>
    <link href="/2021/07/18/ConvertSortedListToBinarySearchTree/"/>
    <url>/2021/07/18/ConvertSortedListToBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h3 id="有序链表转换二叉搜索树"><a href="#有序链表转换二叉搜索树" class="headerlink" title="有序链表转换二叉搜索树"></a>有序链表转换二叉搜索树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/18/ConvertSortedListToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/18/ConvertSortedListToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="有序链表转换二叉搜索树-1"><a href="#有序链表转换二叉搜索树-1" class="headerlink" title="有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定的有序链表： [<span class="hljs-string">-10</span>, <span class="hljs-string">-3</span>, 0, 5, 9],<br><br>一个可能的答案是：[0, <span class="hljs-string">-3</span>, 9, <span class="hljs-string">-10</span>, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br><br>      0<br>     / \<br>   <span class="hljs-string">-3</span>   9<br>   /   /<br> <span class="hljs-string">-10</span>  5<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConvertSortedListToBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-keyword">return</span> dfs(dummy, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(ListNode left, ListNode right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-keyword">while</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next != right) &#123;<br>            cur = cur.next;<br><br>            next = next.next;<br>            <span class="hljs-keyword">if</span> (next == right || next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next = next.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(cur.val);<br>        <span class="hljs-keyword">if</span> (left.next != cur) &#123;<br>            root.left = dfs(left, cur);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.next != right) &#123;<br>            root.right = dfs(cur, right);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">3</span>);<br>        n1.next = n2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> n1.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        n2.next = n3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n3.next = n4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">9</span>);<br>        n4.next = n5;<br>        sortedListToBST(n1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实借鉴了之前的算法题。也很简单，如果是用递归的话。就是链表调试麻烦。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConvertSortedArrayToBinarySearchTree</title>
    <link href="/2021/07/17/ConvertSortedArrayToBinarySearchTree/"/>
    <url>/2021/07/17/ConvertSortedArrayToBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/17/ConvertSortedArrayToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/17/ConvertSortedArrayToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="将有序数组转换为二叉搜索树-1"><a href="#将有序数组转换为二叉搜索树-1" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/btree1.jpg" alt="img"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/btree2.jpg" alt="img"></p><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/btree.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;104</li><li>−104&lt;&#x3D;nums[i]&lt;&#x3D;104</li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConvertSortedArrayToBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left +right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> nums[mid];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root);<br>        node.left = dfs(nums, left, mid - <span class="hljs-number">1</span>);<br>        node.right = dfs(nums, mid +<span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实借鉴了之前的算法题。也很简单，如果是用递归的话。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeLevelOrderTraversalII</title>
    <link href="/2021/07/16/BinaryTreeLevelOrderTraversalII/"/>
    <url>/2021/07/16/BinaryTreeLevelOrderTraversalII/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的层序遍历-II"><a href="#二叉树的层序遍历-II" class="headerlink" title="二叉树的层序遍历 II"></a>二叉树的层序遍历 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/16/BinaryTreeLevelOrderTraversalII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/16/BinaryTreeLevelOrderTraversalII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的层序遍历-II-1"><a href="#二叉树的层序遍历-II-1" class="headerlink" title="二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历 II</a></h4><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其自底向上的层序遍历为：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeLevelOrderTraversalII</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp.add(node.val);<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(node.right);<br>                &#125;<br>            &#125;<br>            ans.add(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(temp));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">9</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">20</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">15</span>);<br>        n2.left = <span class="hljs-literal">null</span>;<br>        n2.right = <span class="hljs-literal">null</span>;<br>        n3.left = n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">7</span>);<br>        n3.right = n5;<br><br>        levelOrderBottom(n1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实和z字形很类似。只不过借助于java的api实现头插入。以后可以试试Go或者C的写法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConstructBinaryTreeFromInorderAndPostorderTraversal</title>
    <link href="/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/"/>
    <url>/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="从中序与后序遍历序列构造二叉树-1"><a href="#从中序与后序遍历序列构造二叉树-1" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>后序遍历 postorder = <span class="hljs-string">[9,15,7,20,3]</span><br></code></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructBinaryTreeFromInorderAndPostorderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(inorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> inorderLeft, <span class="hljs-type">int</span> inorderRight,</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> postOrderLeft, <span class="hljs-type">int</span> postOrderRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inorderLeft &gt; inorderRight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> postorder[postOrderRight];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSubTreeSize</span> <span class="hljs-operator">=</span> index - inorderLeft;<br><br>        rootNode.left = dfs(inorder, postorder, inorderLeft, index - <span class="hljs-number">1</span>,<br>                postOrderLeft, postOrderLeft + leftSubTreeSize - <span class="hljs-number">1</span>);<br>        rootNode.right = dfs(inorder, postorder, inorderLeft + leftSubTreeSize + <span class="hljs-number">1</span>, inorderRight,<br>                postOrderLeft + leftSubTreeSize, postOrderRight - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> rootNode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，寻找根的节点位置，利用节点值唯一的特性。然后，递归构造树结构。其实也是抄上一道题的思路。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConstructBinaryTreeFromPreorderAndInorderTraversal</title>
    <link href="/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/"/>
    <url>/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="从前序与中序遍历序列构造二叉树-1"><a href="#从前序与中序遍历序列构造二叉树-1" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h4><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/tree.jpg" alt="img"></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">Input</span>: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br><span class="hljs-keyword">Output</span>: [3,9,20,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,15,7]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span><br>Output: <span class="hljs-comment">[-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> 保证为二叉树的前序遍历序列</li><li><code>inorder</code> 保证为二叉树的中序遍历序列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructBinaryTreeFromPreorderAndInorderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorderLeft, <span class="hljs-type">int</span> preorderRight,</span><br><span class="hljs-params">                                <span class="hljs-type">int</span> inorderLeft, <span class="hljs-type">int</span> inorderRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorderLeft &gt; preorderRight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorderRoot</span> <span class="hljs-operator">=</span> preorderLeft;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorderRoot</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorderRoot]);<br><br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorderRoot]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sizeLeftSubtree</span> <span class="hljs-operator">=</span> inorderRoot - inorderLeft;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder, inorder,preorderLeft + <span class="hljs-number">1</span>,<br>                preorderLeft + sizeLeftSubtree, inorderLeft, inorderRoot - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder, inorder, preorderLeft + sizeLeftSubtree + <span class="hljs-number">1</span>,<br>                            preorderRight, inorderRoot + <span class="hljs-number">1</span>, inorderRight);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，寻找根的节点位置，利用节点值唯一的特性。然后，递归构造树结构。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeZigzagLevelOrderTraversal</title>
    <link href="/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/"/>
    <url>/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的锯齿形层序遍历-1"><a href="#二叉树的锯齿形层序遍历-1" class="headerlink" title="二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[20,9]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeZigzagLevelOrderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; nodeQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        nodeQueue.offer(root);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isOrderLeft</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">while</span> (!nodeQueue.isEmpty()) &#123;<br>            Deque&lt;Integer&gt; levelList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nodeQueue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-comment">// 从头取</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curNode</span> <span class="hljs-operator">=</span> nodeQueue.poll();<br>                <span class="hljs-keyword">if</span> (isOrderLeft) &#123;<br>                    levelList.offerLast(curNode.val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    levelList.offerFirst(curNode.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (curNode.left != <span class="hljs-literal">null</span>) &#123;<br>                    nodeQueue.offer(curNode.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (curNode.right != <span class="hljs-literal">null</span>) &#123;<br>                    nodeQueue.offer(curNode.right);<br>                &#125;<br>            &#125;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(levelList));<br>            isOrderLeft = !isOrderLeft;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>        n2.left = n4;<br>        n2.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>        n3.right = n5;<br>        n3.left = <span class="hljs-literal">null</span>;<br><br>        List&lt;List&lt;Integer&gt;&gt; lists = zigzagLevelOrder(n1);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : lists) &#123;<br>            <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>                System.out.print(integer + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，利用了java的linkedqueue的队列特性，而且是两个队列。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeLevelOrderTraversal</title>
    <link href="/2021/07/10/BinaryTreeLevelOrderTraversal/"/>
    <url>/2021/07/10/BinaryTreeLevelOrderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/10/BinaryTreeLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/10/BinaryTreeLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的层序遍历-1"><a href="#二叉树的层序遍历-1" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong></p><p>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层序遍历结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeLevelOrderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        union(root, <span class="hljs-number">0</span>);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;<br>            List&lt;Integer&gt; value = entry.getValue();<br>            ans.add(value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.get(count) == <span class="hljs-literal">null</span>) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            list.add(root.val);<br>            map.put(count, list);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;Integer&gt; list = map.get(count);<br>            list.add(root.val);<br>        &#125;<br>        union(root.left, count + <span class="hljs-number">1</span>);<br>        union(root.right, count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">9</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">20</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">15</span>);<br>        n3.left =n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">7</span>);<br>        n3.right = n5;<br><br>        List&lt;List&lt;Integer&gt;&gt; lists = levelOrder(n1);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : lists) &#123;<br>            <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>                System.out.print(integer + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">9 </span><span class="hljs-number">20</span> <br><span class="hljs-symbol">15 </span><span class="hljs-number">7</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单了，就是增加深度这个维度，最后统计出来。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SymmetricTree</title>
    <link href="/2021/07/09/SymmetricTree/"/>
    <url>/2021/07/09/SymmetricTree/</url>
    
    <content type="html"><![CDATA[<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/09/SymmetricTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/09/SymmetricTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="对称二叉树-1"><a href="#对称二叉树-1" class="headerlink" title="对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">1</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymmetricTree</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root.left, root.right)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(p != <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (dfs(p.left, q.right) &amp;&amp; p.val == q.val) &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">dfs</span><span class="hljs-params">(p.right, q.left)</span></span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">check</span><span class="hljs-params">(root, root)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode u, TreeNode v)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        q.offer(u);<br>        q.offer(v);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            u = q.poll();<br>            v = q.poll();<br>            <span class="hljs-keyword">if</span> (u == <span class="hljs-keyword">null</span> &amp;&amp; v == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((u == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span>) || (u.val != v.val)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            q.offer(u.left);<br>            q.offer(v.right);<br><br>            q.offer(u.right);<br>            q.offer(v.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-keyword">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单了，就是递归比对。如果是迭代，需要栈来承载比对的数据。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SameTree</title>
    <link href="/2021/07/08/SameTree/"/>
    <url>/2021/07/08/SameTree/</url>
    
    <content type="html"><![CDATA[<h4 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/08/SameTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/08/SameTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="相同的树-1"><a href="#相同的树-1" class="headerlink" title="相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></h4><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ex1.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,3]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,2,3]</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,null,2]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ex3.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,1]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,1,2]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li>−104&lt;&#x3D;Node.val&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SameTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static boolean isSameTree(TreeNode p, TreeNode q) &#123;<br>        <span class="hljs-keyword">return</span> dfs(p, q);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static boolean dfs(TreeNode p, TreeNode q) &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span> &amp;&amp; p.<span class="hljs-keyword">val</span> == q.<span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(p.left, q.left)) &#123;<br>                <span class="hljs-keyword">return</span> dfs(p.right, q.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，中序遍历，然后挨个判断，非常简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RecoverBinarySearchTree</title>
    <link href="/2021/07/06/RecoverBinarySearchTree/"/>
    <url>/2021/07/06/RecoverBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/06/RecoverBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/06/RecoverBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="恢复二叉搜索树-1"><a href="#恢复二叉搜索树-1" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">恢复二叉搜索树</a></h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p><strong>进阶：</strong>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/recover1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是<span class="hljs-number"> 1 </span>左孩子，因为<span class="hljs-number"> 3 </span>&gt;<span class="hljs-number"> 1 </span>。交换<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>使二叉搜索树有效。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/recover2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [3,1,4,null,null,2]<br>输出：[2,1,4,null,null,3]<br>解释：2 不能在<span class="hljs-number"> 3 </span>的右子树中，因为<span class="hljs-number"> 2 </span>&lt;<span class="hljs-number"> 3 </span>。交换<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>使二叉搜索树有效。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecoverBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> void recoverTree(TreeNode root) &#123;<br><br>        TreeNode x = <span class="hljs-literal">null</span>, y = <span class="hljs-literal">null</span>, pred = <span class="hljs-literal">null</span>, predecessor;<br><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span><br>                predecessor = root.left;<br>                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-literal">null</span> &amp;&amp; predecessor.right != root) &#123;<br>                    predecessor = predecessor.right;<br>                &#125;<br><br>                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span><br>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-literal">null</span>) &#123;<br>                    predecessor.right = root;<br>                    root = root.left;<br>                &#125;<br>                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-keyword">val</span> &lt; pred.<span class="hljs-keyword">val</span>) &#123;<br>                        y = root;<br>                        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                            x = pred;<br>                        &#125;<br>                    &#125;<br>                    pred = root;<br><br>                    predecessor.right = <span class="hljs-literal">null</span>;<br>                    root = root.right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-keyword">val</span> &lt; pred.<span class="hljs-keyword">val</span>) &#123;<br>                    y = root;<br>                    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                        x = pred;<br>                    &#125;<br>                &#125;<br>                pred = root;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        swap(x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> void swap(TreeNode x, TreeNode y) &#123;<br>        int tmp = x.<span class="hljs-keyword">val</span>;<br>        x.<span class="hljs-keyword">val</span> = y.<span class="hljs-keyword">val</span>;<br>        y.<span class="hljs-keyword">val</span> = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，可定都会想到中序遍历了，无论是递归还是非递归都是不会常数空间复杂度的。morris遍历，是进阶题解的方法。目前对于Morris算法不是和熟悉，需要多联系。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidateBinarySearchTree</title>
    <link href="/2021/07/06/ValidateBinarySearchTree/"/>
    <url>/2021/07/06/ValidateBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/04/ValidateBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/04/ValidateBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="验证二叉搜索树-1"><a href="#验证二叉搜索树-1" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br>解释: 输入为: [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]。<br>     根节点的值为 <span class="hljs-number">5</span> ，但是其右子节点值为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidateBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n1.right = n3;<br><br>        System.out.println(isValidBST(n1));<br><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        n1.left = n2;<br>        n3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n3.left = n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>);<br>        n3.right = n5;<br>        System.out.println(isValidBST(n1));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，递归判断range。中序遍历是第一个想到的，可能比较抽象了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InterleavingString</title>
    <link href="/2021/07/03/InterleavingString/"/>
    <url>/2021/07/03/InterleavingString/</url>
    
    <content type="html"><![CDATA[<h4 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/03/InterleavingString/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/03/InterleavingString/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="交错字符串-1"><a href="#交错字符串-1" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串</a></h4><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p><p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/interleave.jpg" alt="img"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbcbcac&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbbaccc&quot;</span><br>输出：falsexxxxxxxxxx 输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbbaccc&quot;</span>输出：false输入：n = <span class="hljs-number">1</span>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>0 &lt;= s3.length &lt;= 200</code></li><li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterleavingString</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(<span class="hljs-type">String</span> s1, <span class="hljs-type">String</span> s2, <span class="hljs-type">String</span> s3)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> n = s<span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> m = s<span class="hljs-number">2.l</span>ength();<br>        <span class="hljs-type">int</span> t = s<span class="hljs-number">3.l</span>ength();<br><br>        <span class="hljs-keyword">if</span> (n + m != t) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 注意索引从0开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-type">int</span> p = i + j - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 主要是i和j可能都大于1，这是需要或</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = f[i][j] || (f[i - <span class="hljs-number">1</span>][j] &amp;&amp; s<span class="hljs-number">1.</span><span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == s<span class="hljs-number">3.</span><span class="hljs-built_in">charAt</span>(p));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = f[i][j] || (f[i][j - <span class="hljs-number">1</span>] &amp;&amp; s<span class="hljs-number">2.</span><span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>) == s<span class="hljs-number">3.</span><span class="hljs-built_in">charAt</span>(p));<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span> s1 = <span class="hljs-string">&quot;aabcc&quot;</span>;<br>        <span class="hljs-type">String</span> s2 = <span class="hljs-string">&quot;dbbca&quot;</span>;<br>        <span class="hljs-type">String</span> s3 = <span class="hljs-string">&quot;aadbbcbcac&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isInterleave</span>(s1, s2, s3));<br><br>        s3 = <span class="hljs-string">&quot;aadbbbaccc&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isInterleave</span>(s1, s2, s3));<br><br>        s1 = <span class="hljs-string">&quot;&quot;</span>;<br>        s2 = <span class="hljs-string">&quot;&quot;</span>;<br>        s3 = <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isInterleave</span>(s1, s2, s3));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，动态规划。主要是要注意边界为0的情况。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniqueBinarySearchTrees</title>
    <link href="/2021/07/01/UniqueBinarySearchTrees/"/>
    <url>/2021/07/01/UniqueBinarySearchTrees/</url>
    
    <content type="html"><![CDATA[<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/01/UniqueBinarySearchTrees/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/01/UniqueBinarySearchTrees/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同的二叉搜索树-1"><a href="#不同的二叉搜索树-1" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h4><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/uniquebstn3.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UniqueBinarySearchTrees</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">numTrees</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br><br>        <span class="hljs-built_in">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];<br>        G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> G[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        System.<span class="hljs-keyword">out</span>.println(numTrees(<span class="hljs-number">3</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numTrees(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，动态规划了。数学确实是工具，官方题解二的卡特兰数确实也厉害。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniqueBinarySearchTreesII</title>
    <link href="/2021/06/29/UniqueBinarySearchTreesII/"/>
    <url>/2021/06/29/UniqueBinarySearchTreesII/</url>
    
    <content type="html"><![CDATA[<h4 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/29/UniqueBinarySearchTreesII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/29/UniqueBinarySearchTreesII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同的二叉搜索树-II-1"><a href="#不同的二叉搜索树-II-1" class="headerlink" title="不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h4><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/uniquebstn3.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniqueBinarySearchTreesII</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateTrees</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        List&lt;TreeNode&gt; allTrees = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>            allTrees.<span class="hljs-built_in">add</span>(null);<br>            <span class="hljs-keyword">return</span> allTrees;<br>        &#125;<br><br>        <span class="hljs-comment">// 枚举可行根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// 获得所有可行的左子树集合</span><br>            List&lt;TreeNode&gt; leftTrees = <span class="hljs-built_in">generateTrees</span>(start, i - <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 获得所有可行的右子树集合</span><br>            List&lt;TreeNode&gt; rightTrees = <span class="hljs-built_in">generateTrees</span>(i + <span class="hljs-number">1</span>, end);<br><br>            <span class="hljs-comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br>            <span class="hljs-keyword">for</span> (TreeNode left : leftTrees) &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode right : rightTrees) &#123;<br>                    TreeNode currTree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>                    currTree.left = left;<br>                    currTree.right = right;<br>                    allTrees.<span class="hljs-built_in">add</span>(currTree);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> allTrees;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">generateTrees</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">generateTrees</span>(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        <span class="hljs-built_in">TreeNode</span>() &#123;<br>        &#125;<br><br>        <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，面向答案编程。其实分左右递归答案我是想出来了，但是怎么合并和返回没想好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeInorderTraversal</title>
    <link href="/2021/06/27/BinaryTreeInorderTraversal/"/>
    <url>/2021/06/27/BinaryTreeInorderTraversal/</url>
    
    <content type="html"><![CDATA[<h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/27/BinaryTreeInorderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/27/BinaryTreeInorderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的中序遍历-1"><a href="#二叉树的中序遍历-1" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/inorder_1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/inorder_4.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/inorder_5.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeInorderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        ans.add(root.val);<br>        dfs(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n1.left = <span class="hljs-literal">null</span>;<br>        n1.right = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n2.left = n3;<br>        System.out.println(Arrays.toString(inorderTraversal(n1).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        System.out.println(Arrays.toString(inorderTraversal(n4).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(inorderTraversal(n5).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>((<span class="hljs-number">2</span>));<br>        n6.left = n7;<br>        System.out.println(Arrays.toString(inorderTraversal(n6).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n8.right = n9;<br>        System.out.println(Arrays.toString(inorderTraversal(n8).toArray()));<br>        ans.clear();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1, 3, 2]</span><br><span class="hljs-string">[]</span><br><span class="hljs-string">[1]</span><br><span class="hljs-string">[2, 1]</span><br><span class="hljs-string">[1, 2]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，太简单了。我决定下次面试的时候，让候选者写一个。确实不难，而且也能判断这个人是否写过代码。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RestoreIpAddresses</title>
    <link href="/2021/06/27/RestoreIpAddresses/"/>
    <url>/2021/06/27/RestoreIpAddresses/</url>
    
    <content type="html"><![CDATA[<h4 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/26/RestoreIpAddresses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/26/RestoreIpAddresses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="复原-IP-地址-1"><a href="#复原-IP-地址-1" class="headerlink" title="复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原 IP 地址</a></h4><p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 <code>s</code> 获得的 <strong>有效 IP 地址</strong> 。你可以按任何顺序返回答案。</p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 <strong>有效</strong> IP 地址，但是”0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#x2e;&#49;">&#49;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#x2e;&#49;</a>” 是 <strong>无效</strong> IP 地址。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span><br>输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0000&quot;</span><br>输出：[<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span><br>输出：[<span class="hljs-string">&quot;1.1.1.1&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;010010&quot;</span><br>输出：[<span class="hljs-string">&quot;0.10.0.10&quot;</span>,<span class="hljs-string">&quot;0.100.1.0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;101023&quot;</span><br>输出：[<span class="hljs-string">&quot;1.0.10.23&quot;</span>,<span class="hljs-string">&quot;1.0.102.3&quot;</span>,<span class="hljs-string">&quot;10.1.0.23&quot;</span>,<span class="hljs-string">&quot;10.10.2.3&quot;</span>,<span class="hljs-string">&quot;101.0.2.3&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 3000</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestoreIpAddresses</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEG_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SEG_COUNT];<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SEG_COUNT];<br>        dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> segId, <span class="hljs-type">int</span> segStart)</span> &#123;<br>        <span class="hljs-comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span><br>        <span class="hljs-keyword">if</span> (segId == SEG_COUNT) &#123;<br>            <span class="hljs-keyword">if</span> (segStart == s.length()) &#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ipAddr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SEG_COUNT; ++i) &#123;<br>                    ipAddr.append(segments[i]);<br>                    <span class="hljs-keyword">if</span> (i != SEG_COUNT - <span class="hljs-number">1</span>) &#123;<br>                        ipAddr.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                    &#125;<br>                &#125;<br>                ans.add(ipAddr.toString());<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span><br>        <span class="hljs-keyword">if</span> (segStart == s.length()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span><br>        <span class="hljs-keyword">if</span> (s.charAt(segStart) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            segments[segId] = <span class="hljs-number">0</span>;<br>            dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 一般情况，枚举每一种可能性并递归</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">segEnd</span> <span class="hljs-operator">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;<br>            addr = addr * <span class="hljs-number">10</span> + (s.charAt(segEnd) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span>) &#123;<br>                segments[segId] = addr;<br>                dfs(s, segId + <span class="hljs-number">1</span>, segEnd + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">255.255.11.135</span>, <span class="hljs-number">255.255.111.35</span>]<br>[<span class="hljs-number">0.0.0.0</span>]<br>[<span class="hljs-number">1.1.1.1</span>]<br>[<span class="hljs-number">0.10.0.10</span>, <span class="hljs-number">0.100.1.0</span>]<br>[<span class="hljs-number">1.0.10.23</span>, <span class="hljs-number">1.0.102.3</span>, <span class="hljs-number">10.1.0.23</span>, <span class="hljs-number">10.10.2.3</span>, <span class="hljs-number">101.0.2.3</span>]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，面向答案编程。虽然想到了大致的思路，但是dfs一致是弱项，最近算法写的都很烂，看来这一段时间的题目，都只能积累了，单凭简单的训练还是不够的。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ReverseLinkedListII</title>
    <link href="/2021/06/24/ReverseLinkedListII/"/>
    <url>/2021/06/24/ReverseLinkedListII/</url>
    
    <content type="html"><![CDATA[<h4 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/24/ReverseLinkedListII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/24/ReverseLinkedListII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="反转链表-II-1"><a href="#反转链表-II-1" class="headerlink" title="反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></h4><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/rev2ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseLinkedListII</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode reverseBetween(ListNode head, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right) &#123;<br><br>        <span class="hljs-comment">// 设置 dummyNode 是这一类问题的一般做法</span><br>        ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        dummyNode.<span class="hljs-keyword">next</span> = head;<br>        ListNode pre = dummyNode;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        ListNode cur = pre.<span class="hljs-keyword">next</span>;<br>        ListNode <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>            <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>            cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;<br>            pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.<span class="hljs-keyword">next</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        ListNode n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode n2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        n1.<span class="hljs-keyword">next</span> = n2;<br>        ListNode n3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        n2.<span class="hljs-keyword">next</span> = n3;<br>        ListNode n4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        n3.<span class="hljs-keyword">next</span> = n4;<br>        ListNode n5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        n4.<span class="hljs-keyword">next</span> = n5;<br><br>        <span class="hljs-keyword">print</span>(reverseBetween(n1, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br><br>        n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">print</span>(reverseBetween(n1, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>-&gt;<br><span class="hljs-number">5</span>-&gt;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，虽然想的差不多，但是做出来，还是差的很远。尤其是，如果不切断链条，可能是出现环或者不好拼接。官方给出的解法二，三个指针，不断的将后续的节点往前抛，确实很厉害。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DecodeWays</title>
    <link href="/2021/06/22/DecodeWays/"/>
    <url>/2021/06/22/DecodeWays/</url>
    
    <content type="html"><![CDATA[<h4 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/22/DecodeWays/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/22/DecodeWays/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="解码方法-1"><a href="#解码方法-1" class="headerlink" title="解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;226&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：没有字符映射到以 <span class="hljs-number">0</span> 开头的数字。<br>含有 <span class="hljs-number">0</span> 的有效映射是 <span class="hljs-string">&#x27;J&#x27;</span> -&gt; <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&#x27;T&#x27;</span>-&gt; <span class="hljs-string">&quot;20&quot;</span> 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;06&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">&quot;06&quot;</span> 不能映射到 <span class="hljs-string">&quot;F&quot;</span> ，因为字符串含有前导 <span class="hljs-number">0</span>（<span class="hljs-string">&quot;6&quot;</span> 和 <span class="hljs-string">&quot;06&quot;</span> 在映射中并不等价）。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DecodeWays</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">numDecodings</span>(<span class="hljs-params">String s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = s.length();<br>        <span class="hljs-comment">// a = f[i-2], b = f[i-1], c=f[i]</span><br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                c += b;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(i - <span class="hljs-number">2</span>) != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ((s.charAt(i - <span class="hljs-number">2</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s.charAt(i - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>)) &#123;<br>                c += a;<br>            &#125;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;12&quot;</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;226&quot;</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;0&quot;</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;06&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br>0<br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，dp了。没有想出来，最近跳槽结束很忙，状态不是很好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SubsetsII</title>
    <link href="/2021/06/19/SubsetsII/"/>
    <url>/2021/06/19/SubsetsII/</url>
    
    <content type="html"><![CDATA[<h4 id="子集-II"><a href="#子集-II" class="headerlink" title="子集 II"></a>子集 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/19/SubsetsII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/19/SubsetsII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="子集-II-1"><a href="#子集-II-1" class="headerlink" title="子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsetsII</span> &#123;<br><br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        dfs(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">boolean</span> choosePre, <span class="hljs-type">int</span> cur, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(t));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(<span class="hljs-literal">false</span>, cur + <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-keyword">if</span> (!choosePre &amp;&amp; cur &gt; <span class="hljs-number">0</span> &amp;&amp; nums[cur - <span class="hljs-number">1</span>] == nums[cur]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t.add(nums[cur]);<br>        dfs(<span class="hljs-literal">true</span>, cur + <span class="hljs-number">1</span>, nums);<br>        t.remove(t.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>        System.out.println(subsetsWithDup(nums));<br><br>        t.clear();<br>        ans.clear();<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        System.out.println(subsetsWithDup(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[2, 2]</span>, <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[1, 2]</span>, <span class="hljs-comment">[1, 2, 2]</span>]</span><br><span class="hljs-comment">[<span class="hljs-comment">[]</span>, <span class="hljs-comment">[0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，直接copy了官方的深度递归了。位移的解法实在难以理解。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GrayCode</title>
    <link href="/2021/06/17/GrayCode/"/>
    <url>/2021/06/17/GrayCode/</url>
    
    <content type="html"><![CDATA[<h4 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/17/GrayCode/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/17/GrayCode/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="格雷编码-1"><a href="#格雷编码-1" class="headerlink" title="格雷编码"></a><a href="https://leetcode-cn.com/problems/gray-code/">格雷编码</a></h4><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><br><span class="hljs-section">输出: [0,1,3,2]</span><br><span class="hljs-section">解释:</span><br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2<br><br>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。<br><br>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> <span class="hljs-number">0</span><br>输出<span class="hljs-symbol">:</span> [<span class="hljs-number">0</span>]<br>解释<span class="hljs-symbol">:</span> 我们定义格雷编码序列必须以 <span class="hljs-number">0</span> 开头。<br>     给定编码总位数为 <span class="hljs-built_in">n</span> 的格雷编码序列，其长度为 <span class="hljs-number">2</span><span class="hljs-built_in">n</span>。当 <span class="hljs-built_in">n</span> = <span class="hljs-number">0</span> 时，长度为 <span class="hljs-number">20</span> = <span class="hljs-number">1</span>。<br>     因此，当 <span class="hljs-built_in">n</span> = <span class="hljs-number">0</span> 时，其格雷编码序列为 [<span class="hljs-number">0</span>]。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GrayCode</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">grayCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, n);<br>        <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][n];<br>        arr[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                        System.arraycopy(arr[i - <span class="hljs-number">1</span>],<span class="hljs-number">0</span>, arr[i],<span class="hljs-number">0</span>, n);<br>                        arr[i][j - <span class="hljs-number">1</span>] = arr[i][j - <span class="hljs-number">1</span>] ^ <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.arraycopy(arr[i - <span class="hljs-number">1</span>],<span class="hljs-number">0</span>, arr[i],<span class="hljs-number">0</span>, n);<br>                arr[i][n - <span class="hljs-number">1</span>] = arr[i][n - <span class="hljs-number">1</span>] ^ <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : arr) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ints.length; i++) &#123;<br>                result += ints[i] * Math.pow(<span class="hljs-number">2</span>, ints.length - i - <span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 镜像法</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">grayCode1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123; add(<span class="hljs-number">0</span>); &#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 多少轮镜像，这个要看维基了解下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 每次都要遍历一遍已有集合，用镜像法算出本轮的值：开头1+已有值，</span><br>            <span class="hljs-comment">// 值得注意，每轮都会留下上一轮的数据</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> res.size() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                res.add(head + res.get(j));<br>            &#125;<br>            <span class="hljs-comment">// head = head &lt;&lt; 1; 相当于每次加了一个1开头的大数，完成镜像</span><br>            head &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(grayCode(<span class="hljs-number">2</span>));<br><br>        System.out.println(grayCode(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[0, 1, 3, 2]</span><br><span class="hljs-string">[0]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，我用了暴力破解。当然，dp我也想到了，但是没有好的办法实现。格雷码还是需要看下维基，了解下，才好写解法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeSortedArray</title>
    <link href="/2021/06/15/MergeSortedArray/"/>
    <url>/2021/06/15/MergeSortedArray/</url>
    
    <content type="html"><![CDATA[<h4 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a>扰乱字符串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/15/MergeSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/15/MergeSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></h4><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中<em>，</em>使 <code>nums1</code> 成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code>的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MergeSortedArray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> merge(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">System</span>.arraycopy(nums2, <span class="hljs-number">0</span>, nums1, m, n);<br>        Arrays.sort(nums1);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] nums1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] nums2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        merge(nums1, <span class="hljs-number">3</span>, nums2, <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(nums1));<br><br>        nums1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        nums2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>        merge(nums1, <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(nums1));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1, 2, 2, 3, 5, 6]</span><br><span class="hljs-string">[1]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，我偷懒了。逆双指针不是没想到，只是懒了，警戒下。需要好好对待每道题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ScrambleString</title>
    <link href="/2021/06/15/ScrambleString/"/>
    <url>/2021/06/15/ScrambleString/</url>
    
    <content type="html"><![CDATA[<h4 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a>扰乱字符串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/12/ScrambleString/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/12/ScrambleString/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="扰乱字符串-1"><a href="#扰乱字符串-1" class="headerlink" title="扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/">扰乱字符串</a></h4><p>使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：</p><ol><li>如果字符串的长度为 1 ，算法停止</li><li>如果字符串的长度 &gt; 1 ，执行下述步骤：<ul><li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li><li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li><li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li></ul></li></ol><p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;great&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;rgeat&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s1</span> 上可能发生的一种情形是：<br><span class="hljs-string">&quot;great&quot;</span> --&gt; <span class="hljs-string">&quot;gr/eat&quot;</span> <span class="hljs-comment">// 在一个随机下标处分割得到两个子字符串</span><br><span class="hljs-string">&quot;gr/eat&quot;</span> --&gt; <span class="hljs-string">&quot;gr/eat&quot;</span> <span class="hljs-comment">// 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="hljs-string">&quot;gr/eat&quot;</span> --&gt; <span class="hljs-string">&quot;g/r / e/at&quot;</span> <span class="hljs-comment">// 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span><br><span class="hljs-string">&quot;g/r / e/at&quot;</span> --&gt; <span class="hljs-string">&quot;r/g / e/at&quot;</span> <span class="hljs-comment">// 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span><br><span class="hljs-string">&quot;r/g / e/at&quot;</span> --&gt; <span class="hljs-string">&quot;r/g / e/ a/t&quot;</span> <span class="hljs-comment">// 继续递归执行此算法，将 &quot;at&quot; 分割得到 &quot;a/t&quot;</span><br><span class="hljs-string">&quot;r/g / e/ a/t&quot;</span> --&gt; <span class="hljs-string">&quot;r/g / e/ a/t&quot;</span> <span class="hljs-comment">// 随机决定：「保持这两个子字符串的顺序不变」</span><br>算法终止，结果字符串和 <span class="hljs-built_in">s2</span> 相同，都是 <span class="hljs-string">&quot;rgeat&quot;</span><br>这是一种能够扰乱 <span class="hljs-built_in">s1</span> 得到 <span class="hljs-built_in">s2</span> 的情形，可以认为 <span class="hljs-built_in">s2</span> 是 <span class="hljs-built_in">s1</span> 的扰乱字符串，返回 true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;caebd&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s1.length == s2.length</code></li><li><code>1 &lt;= s1.length &lt;= 30</code></li><li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrambleString</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-comment">// 记忆化搜索存储状态的数组</span><br>        <span class="hljs-comment">// -1 表示 false，1 表示 true，0 表示未计算</span><br>        <span class="hljs-type">int</span>[][][] memo;<br>        String s1, s2;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isScramble</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s1.length();<br>            <span class="hljs-built_in">this</span>.memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][length][length + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">this</span>.s1 = s1;<br>            <span class="hljs-built_in">this</span>.s2 = s2;<br>            <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, length);<br>        &#125;<br><br>        <span class="hljs-comment">// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> length)</span> &#123;<br>            <span class="hljs-keyword">if</span> (memo[i1][i2][length] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 判断已经判断过的是否和谐</span><br>                <span class="hljs-keyword">return</span> memo[i1][i2][length] == <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断两个子串是否相等</span><br>            <span class="hljs-keyword">if</span> (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) &#123;<br>                memo[i1][i2][length] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断是否存在字符 c 在两个子串中出现的次数不同</span><br>            <span class="hljs-keyword">if</span> (!checkIfSimilar(i1, i2, length)) &#123;<br>                memo[i1][i2][length] = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 枚举分割位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>                <span class="hljs-comment">// 不交换的情况</span><br>                <span class="hljs-keyword">if</span> (dfs(i1, i2, i) &amp;&amp; dfs(i1 + i, i2 + i, length - i)) &#123;<br>                    memo[i1][i2][length] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 交换的情况</span><br>                <span class="hljs-keyword">if</span> (dfs(i1, i2 + length - i, i) &amp;&amp; dfs(i1 + i, i2, length - i)) &#123;<br>                    memo[i1][i2][length] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            memo[i1][i2][length] = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断两个字符串的字符数量一致</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIfSimilar</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> length)</span> &#123;<br>            Map&lt;Character, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i1; i &lt; i1 + length; ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s1.charAt(i);<br>                freq.put(c, freq.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i2; i &lt; i2 + length; ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s2.charAt(i);<br>                freq.put(c, freq.getOrDefault(c, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>                <span class="hljs-keyword">if</span> (value != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        System.out.println(solution.isScramble(<span class="hljs-string">&quot;great&quot;</span>, <span class="hljs-string">&quot;rgeat&quot;</span>));<br><br>        System.out.println(solution.isScramble(<span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-string">&quot;caebd&quot;</span>));<br><br>        System.out.println(solution.isScramble(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，官方的答案很多词并不新鲜，但是解法确实抽丝剥茧，没做出来，确实有难度。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PartitionList</title>
    <link href="/2021/06/10/PartitionList/"/>
    <url>/2021/06/10/PartitionList/</url>
    
    <content type="html"><![CDATA[<h4 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/10/PartitionList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/10/PartitionList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="分隔链表-1"><a href="#分隔链表-1" class="headerlink" title="分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/">分隔链表</a></h4><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/partition.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,4,3,2,5,2]</span>, <span class="hljs-attribute">x</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-selector-attr">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[2,1]</span>, <span class="hljs-attribute">x</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-selector-attr">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>-200 &lt;= x &lt;= 200</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PartitionList</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">smallHead</span> <span class="hljs-operator">=</span> small;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">large</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">largeHead</span> <span class="hljs-operator">=</span> large;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head.val &lt; x) &#123;<br>                small.next = head;<br>                small = small.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                large.next = head;<br>                large = large.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        large.next = <span class="hljs-literal">null</span>;<br>        small.next = largeHead.next;<br>        <span class="hljs-keyword">return</span> smallHead.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        node1.next = node2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        node2.next = node3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        node3.next = node4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        node4.next = node5;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        node5.next = node6;<br>        node6.next = <span class="hljs-literal">null</span>;<br>        print(partition(node1, <span class="hljs-number">3</span>));<br><br>        node1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        node2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        node1.next = node2;<br>        node2.next = <span class="hljs-literal">null</span>;<br>        print(partition(node1, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(head.val + <span class="hljs-string">&quot; &quot;</span>);<br>            head = head.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，双链表实在太巧妙了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MaximalRectangle</title>
    <link href="/2021/06/08/MaximalRectangle/"/>
    <url>/2021/06/08/MaximalRectangle/</url>
    
    <content type="html"><![CDATA[<h4 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/08/MaximalRectangle/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/08/MaximalRectangle/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最大矩形-1"><a href="#最大矩形-1" class="headerlink" title="最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a></h4><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/maximal.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：matrix <span class="hljs-operator">=</span> []<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;1&quot;]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;,&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>0 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaximalRectangle</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 左边连续1的数量</span><br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 注意是括号+1</span><br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> left[i][j];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> width;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    width = Math.min(width, left[k][j]);<br>                    area = Math.max(area, (i - k + <span class="hljs-number">1</span>) * width);<br>                &#125;<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调函数版，主要是基于列，将图翻转90°就是上一题了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle1</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-comment">// 需要算出最长宽度，与上个算法一致</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 对于每一列，使用基于柱状图的方法，可以理解为列从0-n使用上题的解法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 上边界</span><br>            <span class="hljs-type">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>            <span class="hljs-comment">// 下边界</span><br>            <span class="hljs-type">int</span>[] down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br><br>            Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                up[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                stack.push(i);<br>            &#125;<br>            stack.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                down[i] = stack.isEmpty() ? m : stack.peek();<br>                stack.push(i);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> down[i] - up[i] - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> height * left[i][j];<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;1&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>0<br>0<br>1<br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，第一种解法固然简单了。后续基于单调函数的解法很是巧妙。这类题目也是一种类型，熟悉了才能理解的深吧。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LargestRectangleInHistogram</title>
    <link href="/2021/06/05/LargestRectangleInHistogram/"/>
    <url>/2021/06/05/LargestRectangleInHistogram/</url>
    
    <content type="html"><![CDATA[<h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/05/LargestRectangleInHistogram/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/05/LargestRectangleInHistogram/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="柱状图中最大的矩形-1"><a href="#柱状图中最大的矩形-1" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,1,5,6,2,3]</span><br><span class="hljs-section">输出: 10</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LargestRectangleInHistogram &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> largestRectangleArea(<span class="hljs-type">int</span>[] heights) &#123;<br>        Stack&lt;<span class="hljs-type">Integer</span>&gt; stack = <span class="hljs-built_in">new</span> Stack&lt;&gt;();<br>        <span class="hljs-type">int</span> length = heights.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[length];<br>        <span class="hljs-type">int</span>[] right = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[length];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;<br>                stack.pop();<br>            &#125;<br>            left[i] = stack.isEmpty() ? <span class="hljs-number">-1</span> : stack.peek();<br>            stack.push(i);<br>        &#125;<br><br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;<br>                stack.pop();<br>            &#125;<br>            right[i] = stack.isEmpty() ? length : stack.peek();<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] heights= <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(largestRectangleArea(heights));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>如果只是求解，倒是不难，双指针枚举，不过效率太低，可能过不了，所以采用了单调栈的方法。思路也是异常的简单和巧妙，就是遍历过程中，记录每个值左边和右边的边界。主要是每次比较的过程中，上一个已经帮我们筛选了一次，这一次，只需要比较自己和上一个值，以及上一个值的边界即可。详细的解释，可以参考其他答案，官网的解释有点费解。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedList</title>
    <link href="/2021/06/03/RemoveDuplicatesFromSortedList/"/>
    <url>/2021/06/03/RemoveDuplicatesFromSortedList/</url>
    
    <content type="html"><![CDATA[<h4 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/03/RemoveDuplicatesFromSortedList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/03/RemoveDuplicatesFromSortedList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="删除排序链表中的重复元素-1"><a href="#删除排序链表中的重复元素-1" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h4><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/list1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/list2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2,3,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDuplicatesFromSortedList</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode deleteDuplicates(ListNode head) &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.<span class="hljs-keyword">next</span>.val) &#123;<br>                cur.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是遍历并修改指向的重复节点。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedListII</title>
    <link href="/2021/06/01/RemoveDuplicatesFromSortedListII/"/>
    <url>/2021/06/01/RemoveDuplicatesFromSortedListII/</url>
    
    <content type="html"><![CDATA[<h4 id="删除排序链表中的重复元素-II"><a href="#删除排序链表中的重复元素-II" class="headerlink" title="删除排序链表中的重复元素 II"></a>删除排序链表中的重复元素 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/01/RemoveDuplicatesFromSortedListII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/01/RemoveDuplicatesFromSortedListII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="删除排序链表中的重复元素-II-1"><a href="#删除排序链表中的重复元素-II-1" class="headerlink" title="删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></h4><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/linkedlist1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,3,4,4,5]</span><br>输出：<span class="hljs-comment">[1,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/linkedlist2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,1,2,3]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDuplicatesFromSortedListII</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur.next.val;<br>                <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == x) &#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1,2,3,3,4,4,5</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n1.next = n2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n2.next = n3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n3.next = n4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n4.next = n5;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n5.next = n6;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n6.next = n7;<br>        print(deleteDuplicates(n1));<br><br>        <span class="hljs-comment">// 1,1,1,2,3</span><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n1.next = n2;<br>        n3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2.next = n3;<br>        n4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n3.next = n4;<br>        n5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n4.next = n5;<br>        print(deleteDuplicates(n1));<br><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n1.next = n2;<br>        print(deleteDuplicates(n1));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(head.val + <span class="hljs-string">&quot; &quot;</span>);<br>            head = head.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是加一个哑节点。注意，不要思考过于复杂。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchInRotatedSortedArrayII</title>
    <link href="/2021/05/27/SearchInRotatedSortedArrayII/"/>
    <url>/2021/05/27/SearchInRotatedSortedArrayII/</url>
    
    <content type="html"><![CDATA[<h4 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a>搜索旋转排序数组 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/27/SearchInRotatedSortedArrayII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/27/SearchInRotatedSortedArrayII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索旋转排序数组-II-1"><a href="#搜索旋转排序数组-II-1" class="headerlink" title="搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li>−104&lt;&#x3D;nums[i]&lt;&#x3D;104</li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li>−104&lt;&#x3D;target&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SearchInRotatedSortedArrayII &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> <span class="hljs-keyword">search</span>(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;<br>                ++l;<br>                <span class="hljs-comment">--r;</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;<br>                <span class="hljs-keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="hljs-number">1</span>]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">search</span>(nums, target));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        target = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">search</span>(nums, target));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>        target = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">search</span>(nums, target));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是比之前多了一个是否首尾中一致的判断。其实也是很巧妙了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedArrayII</title>
    <link href="/2021/05/25/RemoveDuplicatesFromSortedArrayII/"/>
    <url>/2021/05/25/RemoveDuplicatesFromSortedArrayII/</url>
    
    <content type="html"><![CDATA[<h4 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a>删除有序数组中的重复项 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/25/RemoveDuplicatesFromSortedArrayII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/25/RemoveDuplicatesFromSortedArrayII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="删除有序数组中的重复项-II-1"><a href="#删除有序数组中的重复项-II-1" class="headerlink" title="删除有序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II</a></h4><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    <span class="hljs-built_in">print</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,1,1,2,2,3]</span><br>输出：<span class="hljs-number">5</span>, nums = <span class="hljs-string">[1,1,2,2,3]</span><br>解释：函数应返回新长度 length = <span class="hljs-number">5</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> 。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,1,2,3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">7</span>, nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>解释：函数应返回新长度 length = <span class="hljs-number">7</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> 。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;3∗104</li><li>−104&lt;&#x3D;nums[i]&lt;&#x3D;104</li><li><code>nums</code> 已按升序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RemoveDuplicatesFromSortedArrayII &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> removeDuplicates(<span class="hljs-keyword">int</span>[] nums) &#123;<br><br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> slow = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> fast = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[slow - <span class="hljs-number">2</span>] != nums[fast]) &#123;<br>                nums[slow] = nums[fast];<br>                slow ++;<br>            &#125;<br>            fast++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.<span class="hljs-keyword">println</span>(removeDuplicates(nums));<br>        <span class="hljs-keyword">print</span>(nums);<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.<span class="hljs-keyword">println</span>(removeDuplicates(nums));<br>        <span class="hljs-keyword">print</span>(nums);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是双指针，然后复制交换。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WordSearch</title>
    <link href="/2021/05/22/WordSearch/"/>
    <url>/2021/05/22/WordSearch/</url>
    
    <content type="html"><![CDATA[<h4 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/22/WordSearch/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/22/WordSearch/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="单词搜索-1"><a href="#单词搜索-1" class="headerlink" title="单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">单词搜索</a></h4><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/word-1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;SEE&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/word3.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCB&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordSearch</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> m = board.length;<br>        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[i].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-type">word</span>.<span class="hljs-built_in">charAt</span>(<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, <span class="hljs-number">0</span>, i, j, m, n)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">String</span> <span class="hljs-type">word</span>, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((row &lt; <span class="hljs-number">0</span> || row &gt;= m) || (col &lt; <span class="hljs-number">0</span> || col &gt;= n) || visited[row][col]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">word</span>.<span class="hljs-built_in">charAt</span>(index) == board[row][col] &amp;&amp; <span class="hljs-type">word</span>.<span class="hljs-built_in">length</span>() == index + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">word</span>.<span class="hljs-built_in">charAt</span>(index) == board[row][col]) &#123;<br>            visited[row][col] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row + <span class="hljs-number">1</span>, col, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row - <span class="hljs-number">1</span>, col, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row, col + <span class="hljs-number">1</span>, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row, col - <span class="hljs-number">1</span>, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            visited[row][col] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-type">word</span> = <span class="hljs-string">&quot;ABCCED&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">exist</span>(board, <span class="hljs-type">word</span>));<br><br>        board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;&#125;;<br>        <span class="hljs-type">word</span> = <span class="hljs-string">&quot;SEE&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">exist</span>(board, <span class="hljs-type">word</span>));<br><br>        board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;&#125;;<br>        <span class="hljs-type">word</span> = <span class="hljs-string">&quot;ABCB&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">exist</span>(board, <span class="hljs-type">word</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。但是因为一直对深度搜索和递归不是很熟，所以意外的一次性通过了。当然效率还是不太高，后续有时间再优化下。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Subsets</title>
    <link href="/2021/05/20/Subsets/"/>
    <url>/2021/05/20/Subsets/</url>
    
    <content type="html"><![CDATA[<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/20/Subsets/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/20/Subsets/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="子集-1"><a href="#子集-1" class="headerlink" title="子集"></a><a href="https://leetcode-cn.com/problems/subsets/">子集</a></h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Subsets &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; subsets(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        ans.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-type">int</span> max = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; max; i++) &#123;<br>            ans.<span class="hljs-keyword">add</span>(compute(i, nums));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private static List&lt;<span class="hljs-type">Integer</span>&gt; compute(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span>[] nums) &#123;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num !=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = num % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> == <span class="hljs-number">1</span>) &#123;<br>                list.<span class="hljs-keyword">add</span>(nums[count]);<br>            &#125;<br>            count++;<br>            num /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; nums) &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;<span class="hljs-type">Integer</span>&gt; num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> : num) &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(<span class="hljs-type">integer</span> + &quot; &quot;);<br>            &#125;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        print(subsets(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        print(subsets(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">2 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <br><br><span class="hljs-symbol">0 </span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是数字二进制化，就可以找到所有的组合。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumWindowSubstring</title>
    <link href="/2021/05/18/MinimumWindowSubstring/"/>
    <url>/2021/05/18/MinimumWindowSubstring/</url>
    
    <content type="html"><![CDATA[<h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/18/MinimumWindowSubstring/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/18/MinimumWindowSubstring/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最小覆盖子串-1"><a href="#最小覆盖子串-1" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MinimumWindowSubstring &#123;<br><br>    static Map&lt;<span class="hljs-type">Character</span>, <span class="hljs-type">Integer</span>&gt; ori = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>    static Map&lt;<span class="hljs-type">Character</span>, <span class="hljs-type">Integer</span>&gt; cnt = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-built_in">public</span> static String minWindow(String s, String t) &#123;<br>        <span class="hljs-type">int</span> tLen = t.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;<br>            <span class="hljs-type">char</span> c = t.charAt(i);<br>            ori.put(c, ori.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-type">Integer</span>.MAX_VALUE, ansL = <span class="hljs-number">-1</span>, ansR = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> sLen = s.length();<br>        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;<br>            ++r;<br>            <span class="hljs-keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;<br>                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">check</span>() &amp;&amp; l &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    ansL = l;<br>                    ansR = l + len;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;<br>                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ansL == <span class="hljs-number">-1</span> ? &quot;&quot; : s.substring(ansL, ansR);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> <span class="hljs-keyword">check</span>() &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;<span class="hljs-type">Character</span>, <span class="hljs-type">Integer</span>&gt; entry : ori.entrySet()) &#123;<br>            <span class="hljs-type">Character</span> key = entry.getKey();<br>            <span class="hljs-type">Integer</span> val = entry.getValue();<br>            <span class="hljs-keyword">if</span> (cnt.getOrDefault(key, <span class="hljs-number">0</span>) &lt; val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>//        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(minWindow(&quot;ADOBECODEBANC&quot;, &quot;ABC&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(minWindow(&quot;a&quot;, &quot;a&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路：官方的提示有点坑，需要O(n)的时间，但是明显答案不满足这个条件，所以没有找到好的解题方法，看了官方答案，才明白和自己想的差不多，双指针思路。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Combinations</title>
    <link href="/2021/05/15/Combinations/"/>
    <url>/2021/05/15/Combinations/</url>
    
    <content type="html"><![CDATA[<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/15/Combinations/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/15/Combinations/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a><a href="https://leetcode-cn.com/problems/combinations/">组合</a></h4><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: n = 4, k = 2<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs irpf90">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Combinations &#123;<br><br>    static List&lt;<span class="hljs-keyword">Integer</span>&gt; <span class="hljs-keyword">unit</span> = new ArrayList&lt;&gt;();<br>    static List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; ans = new ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> static List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combine(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k) &#123;<br>        dfs(<span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static void dfs(<span class="hljs-built_in">int</span> cur, <span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">unit</span>.<span class="hljs-built_in">size</span>()  + (n - cur + <span class="hljs-number">1</span>) &lt; k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">unit</span>.<span class="hljs-built_in">size</span>() == k) &#123;<br>            ans.add(new ArrayList&lt;&gt;(<span class="hljs-keyword">unit</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">unit</span>.add(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">unit</span>.remove(<span class="hljs-keyword">unit</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        <span class="hljs-built_in">print</span>(combine(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static void <span class="hljs-built_in">print</span>(List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; ans) &#123;<br>        for (List&lt;<span class="hljs-keyword">Integer</span>&gt; an : ans) &#123;<br>            for (<span class="hljs-keyword">Integer</span> <span class="hljs-keyword">integer</span> : an) &#123;<br>                System.<span class="hljs-keyword">out</span>.<span class="hljs-built_in">print</span>(<span class="hljs-keyword">integer</span>);<br>                System.<span class="hljs-keyword">out</span>.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.<span class="hljs-keyword">out</span>.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路深度递归很简单，官方给出的另外的解法其实很巧妙，不过最近忙练车，没时间研究了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumWindowSubstring</title>
    <link href="/2021/05/13/SortColors/"/>
    <url>/2021/05/13/SortColors/</url>
    
    <content type="html"><![CDATA[<h4 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/13/SortColors/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/13/SortColors/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="颜色分类-1"><a href="#颜色分类-1" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h4><p>给定一个包含红色、白色和蓝色，一共 <code>n</code> 个元素的数组，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,0,1]</span><br>输出：<span class="hljs-comment">[0,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SortColors &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> sortColors(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> red = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> white = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> blue = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>                red++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                white++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                blue++;<br>            &#125;<br>        &#125;<br>        Arrays.fill(nums, <span class="hljs-number">0</span>, red, <span class="hljs-number">0</span>);<br>        Arrays.fill(nums, red, red + white, <span class="hljs-number">1</span>);<br>        Arrays.fill(nums, red + white, red + white + blue, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> sortColors1(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p1];<br>                nums[p1] = <span class="hljs-keyword">temp</span>;<br>                ++p1;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = <span class="hljs-keyword">temp</span>;<br>                <span class="hljs-keyword">if</span> (p0 &lt; p1) &#123;<br>                    <span class="hljs-keyword">temp</span> = nums[i];<br>                    nums[i] = nums[p1];<br>                    nums[p1] = <span class="hljs-keyword">temp</span>;<br>                &#125;<br>                ++p0;<br>                ++p1;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> sortColors2(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= p2; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p2];<br>                nums[p2] = <span class="hljs-keyword">temp</span>;<br>                <span class="hljs-comment">--p2;</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = <span class="hljs-keyword">temp</span>;<br>                ++p0;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">0</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">1</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(num);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(&quot; &quot;);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">0 </span><br><span class="hljs-symbol">1 </span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路统计并填充法很简单，但是双指针也很巧妙。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SetMatrixZeroes</title>
    <link href="/2021/05/11/SetMatrixZeroes/"/>
    <url>/2021/05/11/SetMatrixZeroes/</url>
    
    <content type="html"><![CDATA[<h4 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/08/SetMatrixZeroes/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/08/SetMatrixZeroes/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="矩阵置零-1"><a href="#矩阵置零-1" class="headerlink" title="矩阵置零"></a><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">矩阵置零</a></h4><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法。</p><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用 <code>O(m x n)</code> 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 <code>O(m + n)</code> 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个仅使用常量空间的解决方案吗？</li></ul><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat73-1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-string">[[1,0,1],[0,0,0],[1,0,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat73-2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br>输出：<span class="hljs-string">[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li>−231&lt;&#x3D;matrix[i][j]&lt;&#x3D;231−1</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetMatrixZeroes</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">colFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-comment">// 存第一列是否为0的标志</span><br>            <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>                colFlag = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 在第一行或者第一列保存判0的标志</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始从后往前逆序置0，保证初始化的正确性</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> col - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化第一列</span><br>        <span class="hljs-keyword">if</span> (colFlag) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        setZeroes(matrix);<br>        print(matrix);<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>        setZeroes(matrix);<br>        print(matrix);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.out.print(anInt);<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路其实很巧妙，但是题目本身的描述也给了答案，就是常量空间，那一定是要利用数组本身的空间了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchA2dMatrix</title>
    <link href="/2021/05/11/SearchA2dMatrix/"/>
    <url>/2021/05/11/SearchA2dMatrix/</url>
    
    <content type="html"><![CDATA[<h4 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/11/SearchA2dMatrix/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/11/SearchA2dMatrix/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索二维矩阵-1"><a href="#搜索二维矩阵-1" class="headerlink" title="搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵</a></h4><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mats2d1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mats2d2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">13</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li>−104&lt;&#x3D;matrix[i][j],target&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchA2dMatrix</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> row = matrix.length;<br>        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">int</span> rowLow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rowHigh = row - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> midRow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (rowLow &lt;= rowHigh) &#123;<br>            midRow = (rowLow + rowHigh) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[midRow][<span class="hljs-number">0</span>] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(matrix[midRow][<span class="hljs-number">0</span>] &gt; <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>                rowHigh = midRow - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                rowLow = midRow + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (matrix[midRow][<span class="hljs-number">0</span>] &gt; <span class="hljs-keyword">target</span>) &#123;<br>            midRow -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (midRow &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> colLeft = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> colRight = col - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> midCol;<br>        <span class="hljs-keyword">while</span> (colLeft &lt;= colRight) &#123;<br>            midCol = (colLeft + colRight) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[midRow][midCol] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(matrix[midRow][midCol] &gt; <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>                colRight = midCol - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                colLeft = midCol + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">23</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">60</span>&#125;&#125;;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span>;<br>        System.out.println(searchMatrix(matrix, <span class="hljs-keyword">target</span>));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">23</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">60</span>&#125;&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">13</span>;<br>        System.out.println(searchMatrix(matrix, <span class="hljs-keyword">target</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是二分搜索。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EditDistance</title>
    <link href="/2021/05/06/EditDistance/"/>
    <url>/2021/05/06/EditDistance/</url>
    
    <content type="html"><![CDATA[<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/06/EditDistance/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/06/EditDistance/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="编辑距离-1"><a href="#编辑距离-1" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h4><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EditDistance</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-type">String</span> word1, <span class="hljs-type">String</span> word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-type">word</span><span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> m = <span class="hljs-type">word</span><span class="hljs-number">2.l</span>ength();<br><br>        <span class="hljs-comment">// 有一个字符串为空串</span><br>        <span class="hljs-keyword">if</span> (n * m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> n + m;<br>        &#125;<br><br>        <span class="hljs-comment">// DP 数组</span><br>        <span class="hljs-type">int</span>[][] D = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 边界状态初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            D[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>            D[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算所有 DP 值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">int</span> left = D[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> down = D[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left_down = D[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">word</span><span class="hljs-number">1.</span><span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) != <span class="hljs-type">word</span><span class="hljs-number">2.</span><span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>)) &#123;<br>                    left_down += <span class="hljs-number">1</span>;<br>                &#125;<br>                D[i][j] = Math.<span class="hljs-built_in">min</span>(left, Math.<span class="hljs-built_in">min</span>(down, left_down));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> D[n][m];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">minDistance</span>(<span class="hljs-string">&quot;horse&quot;</span>, <span class="hljs-string">&quot;ros&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">minDistance</span>(<span class="hljs-string">&quot;intention&quot;</span>, <span class="hljs-string">&quot;execution&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>5<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路是抄了官方答案，这个问题没遇到过，动态规划其实还简单了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SimplifyPath</title>
    <link href="/2021/05/04/SimplifyPath/"/>
    <url>/2021/05/04/SimplifyPath/</url>
    
    <content type="html"><![CDATA[<h4 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/04/SimplifyPath/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/04/SimplifyPath/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="简化路径-1"><a href="#简化路径-1" class="headerlink" title="简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/">简化路径</a></h4><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li><li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li></ul><p>返回简化后得到的 <strong>规范路径</strong> 。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home/&quot;</span><br>输出：<span class="hljs-string">&quot;/home&quot;</span><br>解释：注意，最后一个目录名后面没有斜杠。 <br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/../&quot;</span><br>输出：<span class="hljs-string">&quot;/&quot;</span><br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home//foo/&quot;</span><br>输出：<span class="hljs-string">&quot;/home/foo&quot;</span><br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/a/./b/../../c/&quot;</span><br>输出：<span class="hljs-string">&quot;/c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= path.length &lt;= 3000</code></li><li><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li><li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplifyPath</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">simplifyPath</span><span class="hljs-params">(<span class="hljs-type">String</span> path)</span> </span>&#123;<br><br>        LinkedList&lt;<span class="hljs-type">String</span>&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-type">char</span>[] chars = path.<span class="hljs-built_in">toCharArray</span>();<br>        List&lt;<span class="hljs-type">String</span>&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> end = <span class="hljs-number">0</span>; end &lt; chars.length; end++) &#123;<br>            <span class="hljs-keyword">if</span> (chars[end] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (end &gt; start) &#123;<br>                    strings.<span class="hljs-built_in">add</span>(path.<span class="hljs-built_in">substring</span>(start, end));<br>                &#125;<br>                strings.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end == chars.length - <span class="hljs-number">1</span>) &#123;<br>                strings.<span class="hljs-built_in">add</span>(path.<span class="hljs-built_in">substring</span>(start, end + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> string : strings) &#123;<br>            <span class="hljs-keyword">switch</span> (string) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.<span class="hljs-built_in">get</span>(stack.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>).<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        stack.<span class="hljs-built_in">add</span>(string);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.&quot;</span>:<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;..&quot;</span>:<br>                    <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>                        stack.<span class="hljs-built_in">removeLast</span>();<br>                        stack.<span class="hljs-built_in">removeLast</span>();<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    stack.<span class="hljs-built_in">add</span>(string);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; stack.<span class="hljs-built_in">getLast</span>().<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>            stack.<span class="hljs-built_in">removeLast</span>();<br>        &#125;<br><br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> s : stack) &#123;<br>            stringBuilder.<span class="hljs-built_in">append</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/home&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/../&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/home//foo/&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/a/./b/../../c/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/home<br>/<br>/home/foo<br>/c<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是挨个匹配。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mySqrt</title>
    <link href="/2021/05/01/mySqrt/"/>
    <url>/2021/05/01/mySqrt/</url>
    
    <content type="html"><![CDATA[<h4 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/01/mySqrt/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/01/mySqrt/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="x-的平方根-1"><a href="#x-的平方根-1" class="headerlink" title="x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></h4><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 4</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 8</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">说明: 8 的平方根是 2.82842..., </span><br>     由于返回类型是整数，小数部分将被舍去。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.<span class="hljs-built_in">sqrt</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">mySqrt</span>(<span class="hljs-number">4</span>));<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">mySqrt</span>(<span class="hljs-number">8</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路就是一道数学题，官方给出了3种数学解法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ClimbingStairs</title>
    <link href="/2021/05/01/ClimbingStairs/"/>
    <url>/2021/05/01/ClimbingStairs/</url>
    
    <content type="html"><![CDATA[<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/01/ClimbingStairs/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/01/ClimbingStairs/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClimbingStairs</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br><br>        <span class="hljs-comment">// f[n] = f[n-1] + f[n-2]</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(climbStairs(<span class="hljs-number">2</span>));<br>        System.<span class="hljs-keyword">out</span>.println(climbStairs(<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路就是一道简单的动态方程。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TextJustification</title>
    <link href="/2021/04/29/TextJustification/"/>
    <url>/2021/04/29/TextJustification/</url>
    
    <content type="html"><![CDATA[<h4 id="文本左右对齐"><a href="#文本左右对齐" class="headerlink" title="文本左右对齐"></a>文本左右对齐</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/29/TextJustification/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/29/TextJustification/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="文本左右对齐-1"><a href="#文本左右对齐-1" class="headerlink" title="文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">文本左右对齐</a></h4><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p><p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p><p><strong>说明:</strong></p><ul><li>单词是指由非空格字符组成的字符序列。</li><li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li><li>输入单词数组 <code>words</code> 至少包含一个单词。</li></ul><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>]<br>maxWidth = 16<br><span class="hljs-section">输出:</span><br>[<br>   <span class="hljs-string">&quot;This    is    an&quot;</span>,<br>   <span class="hljs-string">&quot;example  of text&quot;</span>,<br>   <span class="hljs-string">&quot;justification.  &quot;</span><br>]<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;What&quot;</span>,<span class="hljs-string">&quot;must&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;acknowledgment&quot;</span>,<span class="hljs-string">&quot;shall&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>]<br>maxWidth = 16<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;What   must   be&quot;</span>,<br>  <span class="hljs-string">&quot;acknowledgment  &quot;</span>,<br>  <span class="hljs-string">&quot;shall be        &quot;</span><br>]<br><span class="hljs-section">解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span><br>     因为最后一行应为左对齐，而不是左右两端对齐。       <br>     第二行同样为左对齐，这是因为这行只包含一个单词。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;Science&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;what&quot;</span>,<span class="hljs-string">&quot;we&quot;</span>,<span class="hljs-string">&quot;understand&quot;</span>,<span class="hljs-string">&quot;well&quot;</span>,<span class="hljs-string">&quot;enough&quot;</span>,<span class="hljs-string">&quot;to&quot;</span>,<span class="hljs-string">&quot;explain&quot;</span>,<br>         <span class="hljs-string">&quot;to&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;computer.&quot;</span>,<span class="hljs-string">&quot;Art&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;everything&quot;</span>,<span class="hljs-string">&quot;else&quot;</span>,<span class="hljs-string">&quot;we&quot;</span>,<span class="hljs-string">&quot;do&quot;</span>]<br>maxWidth = 20<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;Science  is  what we&quot;</span>,<br>  <span class="hljs-string">&quot;understand      well&quot;</span>,<br>  <span class="hljs-string">&quot;enough to explain to&quot;</span>,<br>  <span class="hljs-string">&quot;a  computer.  Art is&quot;</span>,<br>  <span class="hljs-string">&quot;everything  else  we&quot;</span>,<br>  <span class="hljs-string">&quot;do                  &quot;</span><br>]<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 先取出一行能够容纳的单词，将这些单词根据规则填入一行</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 计算出额外空格的数量 spaceCount，额外空格就是正常书写用不到的空格</span><br><span class="hljs-comment"> * 2.1. 由总长度算起</span><br><span class="hljs-comment"> * 2.2. 除去每个单词末尾必须的空格，为了统一处理可以在结尾虚拟加上一个长度</span><br><span class="hljs-comment"> * 2.3. 除去所有单词的长度</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 按照单词的间隙数量 wordCount - 1，简单来说就是商和余数的计算</span><br><span class="hljs-comment"> * 3.1 对于每个词填充之后，需要填充的空格数量等于 spaceSuffix + spaceAvg + ((i - bg) &lt; spaceExtra)</span><br><span class="hljs-comment"> * spaceSuffix 【单词尾部固定的空格，就是1】</span><br><span class="hljs-comment"> * spaceAvg 【额外空格的平均值，每个间隙都要填入 spaceAvg 个空格】</span><br><span class="hljs-comment"> * ((i - bg) &lt; spaceExtra) 【额外空格的余数，前 spaceExtra 个间隙需要多 1 个空格】，这个是补偿给前面的间隙的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 特殊处理</span><br><span class="hljs-comment"> * 4.1. 一行只有一个单词，单词左对齐，右侧填满空格</span><br><span class="hljs-comment"> * 4.2. 最后一行，所有单词左对齐，中间只有一个空格，最后一个单词右侧填满空格</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextJustification</span> &#123;<br><br>    <span class="hljs-comment">// 行整理函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">fillWords</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex, <span class="hljs-type">int</span> maxWidth, <span class="hljs-type">boolean</span> lastLine)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wordCount</span> <span class="hljs-operator">=</span> endIndex - startIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 除去每个单词尾部空格， + 1 是最后一个单词的尾部空格的特殊处理，就是实际减去间隙的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceCount</span> <span class="hljs-operator">=</span> maxWidth + <span class="hljs-number">1</span> - wordCount;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= endIndex; i++) &#123;<br>            <span class="hljs-comment">// 除去所有单词的长度</span><br>            spaceCount -= words[i].length();<br>        &#125;<br><br>        <span class="hljs-comment">// 词尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceSuffix</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 额外空格的平均值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceAvg</span> <span class="hljs-operator">=</span> (wordCount == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : spaceCount / (wordCount - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 额外空格的余数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceExtra</span> <span class="hljs-operator">=</span> (wordCount == <span class="hljs-number">1</span>) ? <span class="hljs-number">0</span> : spaceCount % (wordCount - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; endIndex; i++) &#123;<br>            <span class="hljs-comment">// 填入单词</span><br>            ans.append(words[i]);<br>            <span class="hljs-comment">// 特殊处理最后一行，需要左对齐且空格一个</span><br>            <span class="hljs-keyword">if</span> (lastLine) &#123;<br>                ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 根据计算结果补上空格</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> spaceSuffix + spaceAvg;<br>            <span class="hljs-keyword">if</span> ((i - startIndex) &lt; spaceExtra) &#123;<br>                temp += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (temp-- &gt; <span class="hljs-number">0</span>) &#123;<br>                ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 填入最后一个单词</span><br>        ans.append(words[endIndex]);<br>        <span class="hljs-comment">// 补上这一行最后的空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> maxWidth - ans.length();<br>        <span class="hljs-keyword">while</span> (temp-- &gt; <span class="hljs-number">0</span>) &#123;<br>            ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lineLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            lineLength += words[i].length() + <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果是最后一个单词，或者加上下一个词就超过长度了，即可凑成一行</span><br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == words.length || lineLength + words[i + <span class="hljs-number">1</span>].length() &gt; maxWidth) &#123;<br>                ans.add(fillWords(words, startIndex, i, maxWidth, i + <span class="hljs-number">1</span> == words.length));<br>                startIndex = i + <span class="hljs-number">1</span>;<br>                lineLength = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxWidth</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>        System.out.println(fullJustify(words, maxWidth));<br><br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;What&quot;</span>, <span class="hljs-string">&quot;must&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;acknowledgment&quot;</span>, <span class="hljs-string">&quot;shall&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>&#125;;<br>        maxWidth = <span class="hljs-number">16</span>;<br>        System.out.println(fullJustify(words, maxWidth));<br><br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Science&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;what&quot;</span>, <span class="hljs-string">&quot;we&quot;</span>, <span class="hljs-string">&quot;understand&quot;</span>, <span class="hljs-string">&quot;well&quot;</span>, <span class="hljs-string">&quot;enough&quot;</span>, <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;explain&quot;</span>,<br>                <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;computer.&quot;</span>, <span class="hljs-string">&quot;Art&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;everything&quot;</span>, <span class="hljs-string">&quot;else&quot;</span>, <span class="hljs-string">&quot;we&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>&#125;;<br>        maxWidth = <span class="hljs-number">20</span>;<br>        System.out.println(fullJustify(words, maxWidth));<br><br><span class="hljs-comment">//        String[] words = new String[]&#123;&quot;What&quot;, &quot;must&quot;, &quot;bexx&quot;, &quot;a&quot;&#125;;</span><br><span class="hljs-comment">//        int maxWidth = 16;</span><br><span class="hljs-comment">//        System.out.println(fullJustify(words, maxWidth));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[This    <span class="hljs-keyword">is</span>    an, example  <span class="hljs-keyword">of</span> <span class="hljs-type">text</span>, justification.  ]<br>[What   must   be, acknowledgment  , shall be        ]<br>[Science  <span class="hljs-keyword">is</span>  what we, understand      well, enough <span class="hljs-keyword">to</span> <span class="hljs-keyword">explain</span> <span class="hljs-keyword">to</span>, a  computer.  Art <span class="hljs-keyword">is</span>, everything  <span class="hljs-keyword">else</span>  we, <span class="hljs-keyword">do</span>    <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>参考了其他的答主，主要是将空间拆开成三部分，很巧妙，可以参考下图。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AddBinary</title>
    <link href="/2021/04/27/AddBinary/"/>
    <url>/2021/04/27/AddBinary/</url>
    
    <content type="html"><![CDATA[<h4 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/27/AddBinary/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/27/AddBinary/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二进制求和-1"><a href="#二进制求和-1" class="headerlink" title="二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/">二进制求和</a></h4><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出: <span class="hljs-string">&quot;100&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1011&quot;</span><br>输出: <span class="hljs-string">&quot;10101&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddBinary</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-type">String</span> a, <span class="hljs-type">String</span> b)</span> </span>&#123;<br><br>        <span class="hljs-type">char</span>[] charsA = a.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-type">char</span>[] charsB = b.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = a.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = b.<span class="hljs-built_in">length</span>();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-type">int</span> max = Math.<span class="hljs-built_in">max</span>(m, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (m - i &gt;= <span class="hljs-number">0</span>) &#123;<br>                sum += charsA[m - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n - i &gt;= <span class="hljs-number">0</span>) &#123;<br>                sum += charsB[n - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            sum += step;<br>            StringBuilder temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>().<span class="hljs-built_in">append</span>(sum % <span class="hljs-number">2</span>);<br>            sb = temp.<span class="hljs-built_in">append</span>(sb);<br>            step = sum / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (step == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span> + sb;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">addBinary</span>(<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">addBinary</span>(<span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-string">&quot;1011&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">100<br>10101<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PlusOne</title>
    <link href="/2021/04/25/PlusOne/"/>
    <url>/2021/04/25/PlusOne/</url>
    
    <content type="html"><![CDATA[<h4 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/25/PlusOne/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/25/PlusOne/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="加一-1"><a href="#加一-1" class="headerlink" title="加一"></a><a href="https://leetcode-cn.com/problems/plus-one/">加一</a></h4><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,2,4]</span><br>解释：输入数组表示数字 123。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：digits = [<span class="hljs-number">4,3,2,1</span>]<br>输出：[<span class="hljs-number">4,3,2,2</span>]<br>解释：输入数组表示数字 <span class="hljs-number">4321</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PlusOne &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] plusOne(<span class="hljs-keyword">int</span>[] digits) &#123;<br><br>        <span class="hljs-keyword">int</span> length = digits.length;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">step</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> temp = digits[i];<br>            digits[i] = (temp + <span class="hljs-keyword">step</span>) % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">step</span> = (temp + <span class="hljs-keyword">step</span>) / <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">step</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span>[] digitss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length + <span class="hljs-number">1</span>];<br>            digitss[<span class="hljs-number">0</span>] = <span class="hljs-keyword">step</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                digitss[i + <span class="hljs-number">1</span>] = digits[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> digitss;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">int</span>[] digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br><br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br><br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br><br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">9</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(<span class="hljs-keyword">int</span>[] digits) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> digit : digits) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(digit);<br>            System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidNumber</title>
    <link href="/2021/04/22/ValidNumber/"/>
    <url>/2021/04/22/ValidNumber/</url>
    
    <content type="html"><![CDATA[<h4 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/22/ValidNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/22/ValidNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="有效数字-1"><a href="#有效数字-1" class="headerlink" title="有效数字"></a><a href="https://leetcode-cn.com/problems/valid-number/">有效数字</a></h4><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：</p><ul><li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li></ul><p>部分无效数字列举如下：</p><ul><li><code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></li></ul><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;e&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.1&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">package algorithm;</span><br><span class="language-xml"></span><br><span class="language-xml">import java.util.HashMap;</span><br><span class="language-xml">import java.util.Map;</span><br><span class="language-xml"></span><br><span class="language-xml">public class ValidNumber &#123;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static boolean isNumber(String s) &#123;</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = new HashMap<span class="hljs-tag">&lt;&gt;</span>();</span><br><span class="language-xml"></span><br><span class="language-xml">        // 开始的字符，以及这个字符目前所处的状态</span><br><span class="language-xml">        Map&lt;CharType, State&gt; initialMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_INTEGER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_POINT</span>, State.STATE_POINT_WITHOUT_INT);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_SIGN</span>, State.STATE_INT_SIGN);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        // 开始状态所包含的下一步能含有的字符及状态，下面依次类推</span><br><span class="language-xml">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // +/-，以及这个字符目前所处的状态</span><br><span class="language-xml">        Map&lt;CharType, State&gt; intSignMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_INTEGER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_POINT</span>, State.STATE_POINT_WITHOUT_INT);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // 0-9</span><br><span class="language-xml">        Map&lt;CharType, State&gt; integerMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_INTEGER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_EXP</span>, State.STATE_EXP);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_POINT</span>, State.STATE_POINT);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // .</span><br><span class="language-xml">        Map&lt;CharType, State&gt; pointMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_FRACTION);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_EXP</span>, State.STATE_EXP);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // .</span><br><span class="language-xml">        Map&lt;CharType, State&gt; pointWithoutIntMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_FRACTION);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;CharType, State&gt; fractionMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_FRACTION);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_EXP</span>, State.STATE_EXP);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // E/e</span><br><span class="language-xml">        Map&lt;CharType, State&gt; expMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_EXP_NUMBER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_SIGN</span>, State.STATE_EXP_SIGN);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;CharType, State&gt; expSignMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_EXP_NUMBER);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;CharType, State&gt; expNumberMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_EXP_NUMBER);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        int length = s.length();</span><br><span class="language-xml">        State state = State.STATE_INITIAL;</span><br><span class="language-xml"></span><br><span class="language-xml">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="language-xml">            CharType type = toCharType(s.charAt(i));</span><br><span class="language-xml">            if (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="language-xml">                return false;</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            state = transfer.get(state).get(type);</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">        return state == State.STATE_INTEGER || state == State.STATE_POINT</span><br><span class="language-xml">                || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER</span><br><span class="language-xml">                || state == State.STATE_END;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static CharType toCharType(char ch) &#123;</span><br><span class="language-xml">        if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_NUMBER;</span><br><span class="language-xml">        &#125; else if (ch == &#x27;e&#x27; || ch == &#x27;E&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_EXP;</span><br><span class="language-xml">        &#125; else if (ch == &#x27;.&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_POINT;</span><br><span class="language-xml">        &#125; else if (ch == &#x27;+&#x27; || ch == &#x27;-&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_SIGN;</span><br><span class="language-xml">        &#125; else &#123;</span><br><span class="language-xml">            return CharType.CHAR_ILLEGAL;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    enum State &#123;</span><br><span class="language-xml">        // 初始</span><br><span class="language-xml">        STATE_INITIAL,</span><br><span class="language-xml">        // 符号位+/-</span><br><span class="language-xml">        STATE_INT_SIGN,</span><br><span class="language-xml">        // 整数部分</span><br><span class="language-xml">        STATE_INTEGER,</span><br><span class="language-xml">        // 左侧有整数的小数点</span><br><span class="language-xml">        STATE_POINT,</span><br><span class="language-xml">        // 左侧无整数的小数点</span><br><span class="language-xml">        STATE_POINT_WITHOUT_INT,</span><br><span class="language-xml">        // 小数部分</span><br><span class="language-xml">        STATE_FRACTION,</span><br><span class="language-xml">        // 字符e</span><br><span class="language-xml">        STATE_EXP,</span><br><span class="language-xml">        // 指数部分的符号位+/-</span><br><span class="language-xml">        STATE_EXP_SIGN,</span><br><span class="language-xml">        // 指数部分的整数部分</span><br><span class="language-xml">        STATE_EXP_NUMBER,</span><br><span class="language-xml">        // 结束</span><br><span class="language-xml">        STATE_END,</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    enum CharType &#123;</span><br><span class="language-xml">        CHAR_NUMBER,</span><br><span class="language-xml">        CHAR_EXP,</span><br><span class="language-xml">        CHAR_POINT,</span><br><span class="language-xml">        CHAR_SIGN,</span><br><span class="language-xml">        CHAR_ILLEGAL,</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static void main(String[] args) &#123;</span><br><span class="language-xml">        System.out.println(isNumber(&quot;0&quot;));</span><br><span class="language-xml">        System.out.println(isNumber(&quot;e&quot;));</span><br><span class="language-xml">        System.out.println(isNumber(&quot;.&quot;));</span><br><span class="language-xml">        System.out.println(isNumber(&quot;.1&quot;));</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上直接抄了官方，虽然效率不是很高，主要是解题方式是有限状态机的设计。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumPathSum</title>
    <link href="/2021/04/20/MinimumPathSum/"/>
    <url>/2021/04/20/MinimumPathSum/</url>
    
    <content type="html"><![CDATA[<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/20/MinimumPathSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/20/MinimumPathSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最小路径和-1"><a href="#最小路径和-1" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/minpath.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs inform7">package algorithm;<br><br>public class MinimumPathSum &#123;<br><br>    public static int minPathSum(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> grid) &#123;<br><br>        int m = grid.length;<br>        int n = grid<span class="hljs-comment">[0]</span>.length;<br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> score = new int<span class="hljs-comment">[grid.length]</span><span class="hljs-comment">[grid<span class="hljs-comment">[0]</span>.length]</span>;<br>        score<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>;<br><br>        for (int i = 1; i &lt; m; i++) &#123;<br>            score<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = score<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>;<br>        &#125;<br>        for (int i = 1; i &lt; n; i++) &#123;<br>            score<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = score<span class="hljs-comment">[0]</span><span class="hljs-comment">[i - 1]</span> + grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>;<br>        &#125;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            for (int j = 1; j &lt; n; j++) &#123;<br>                score<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> + Math.min(score<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, score<span class="hljs-comment">[i]</span><span class="hljs-comment">[j -1]</span>);<br>            &#125;<br>        &#125;<br><br>        return score<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br><br>    public static void main(String<span class="hljs-comment">[]</span> args) &#123;<br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> grid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;1,3,1&#125;, &#123;1,5,1&#125;, &#123;4,2,1&#125;&#125;;<br>        System.out.println(minPathSum(grid));<br><br>        grid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;;<br>        System.out.println(minPathSum(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">7<br>12<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路不是很难，就是写个动态方程求解。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniquePathsII</title>
    <link href="/2021/04/17/UniquePathsII/"/>
    <url>/2021/04/17/UniquePathsII/</url>
    
    <content type="html"><![CDATA[<h4 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/17/UniquePathsII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/17/UniquePathsII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同路径-II-1"><a href="#不同路径-II-1" class="headerlink" title="不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II</a></h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot_maze.png" alt="img"></p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot1.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>m &#x3D;&#x3D; obstacleGrid.length</li><li>n &#x3D;&#x3D; obstacleGrid[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs inform7">package algorithm;<br><br>public class UniquePathsII &#123;<br><br>    public static int uniquePathsWithObstacles(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;<br>        int m = obstacleGrid.length;<br>        int n = obstacleGrid<span class="hljs-comment">[0]</span>.length;<br><br>        if (obstacleGrid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> == 1 || obstacleGrid<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span> == 1) &#123;<br>            return 0;<br>        &#125;<br><br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> path = new int<span class="hljs-comment">[m]</span><span class="hljs-comment">[n]</span>;<br>        path<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> == 0) &#123;<br>                path<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = path<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span>;<br>            &#125; else &#123;<br>                path<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = 0;<br>            &#125;<br>        &#125;<br>        for (int i = 1; i &lt; n; i++) &#123;<br>            if (obstacleGrid<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> == 0) &#123;<br>                path<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = path<span class="hljs-comment">[0]</span><span class="hljs-comment">[i - 1]</span>;<br>            &#125; else &#123;<br>                path<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = 0;<br>            &#125;<br>        &#125;<br><br>        for (int i = 1; i &lt; m; i++) &#123;<br>            for (int j = 1; j &lt; n; j++) &#123;<br>                if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> == 1) &#123;<br>                    path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 0;<br>                &#125; else &#123;<br>                    path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = path<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return path<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br><br>    public int uniquePathsWithObstacles1(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;<br>        int n = obstacleGrid.length, m = obstacleGrid<span class="hljs-comment">[0]</span>.length;<br>        int<span class="hljs-comment">[]</span> f = new int<span class="hljs-comment">[m]</span>;<br><br>        // 存储列，其实存储行也一样，默认的第一列后面的元素不计算，因为本身就是1，<br>        // 因为有置0的存在，所以不必担心其中有障碍物的情况<br>        f<span class="hljs-comment">[0]</span> = obstacleGrid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> == 0 ? 1 : 0;<br>        for (int i = 0; i &lt; n; ++i) &#123;<br>            for (int j = 0; j &lt; m; ++j) &#123;<br>                if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> == 1) &#123;<br>                    f<span class="hljs-comment">[j]</span> = 0;<br>                    continue;<br>                &#125;<br>                // 其实本格子就是左和上，上也就是上个f<span class="hljs-comment">[j]</span>，左就是f<span class="hljs-comment">[j-1]</span>，这个需要思考下，所以这是滚动数组<br>                if (j - 1 &gt;= 0 &amp;&amp; obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span> == 0) &#123;<br>                    f<span class="hljs-comment">[j]</span> += f<span class="hljs-comment">[j - 1]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return f<span class="hljs-comment">[m - 1]</span>;<br>    &#125;<br><br>    public static void main(String<span class="hljs-comment">[]</span> args) &#123;<br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;0,0,0&#125;,&#123;0,1,0&#125;,&#123;0,0,0&#125;&#125;;<br>        System.out.println(uniquePathsWithObstacles(obstacleGrid));<br><br>        obstacleGrid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;0,1&#125;,&#123;0,0&#125;&#125;;<br>        System.out.println(uniquePathsWithObstacles(obstacleGrid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>代码给了两种解法，一种是基于上一题的延伸，一种是官方的解法，更加精炼，而且用到了滚动数组。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniquePaths</title>
    <link href="/2021/04/16/UniquePaths/"/>
    <url>/2021/04/16/UniquePaths/</url>
    
    <content type="html"><![CDATA[<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/16/UniquePaths/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/16/UniquePaths/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同路径-1"><a href="#不同路径-1" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot_maze.png" alt="img"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 2∗109</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UniquePaths &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> uniquePaths(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m][n];<br>        <span class="hljs-type">path</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">path</span>[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">path</span>[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">path</span>[i][j] = <span class="hljs-type">path</span>[i - <span class="hljs-number">1</span>][j] + <span class="hljs-type">path</span>[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">path</span>[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">28<br>3<br>28<br>6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。写出动态方程就解决了。不过另外的解法，太过简单，巧妙的是居然这是一道数学题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RotateList</title>
    <link href="/2021/04/13/RotateList/"/>
    <url>/2021/04/13/RotateList/</url>
    
    <content type="html"><![CDATA[<h4 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/13/RotateList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/13/RotateList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="旋转链表-1"><a href="#旋转链表-1" class="headerlink" title="旋转链表"></a><a href="https://leetcode-cn.com/problems/rotate-list/">旋转链表</a></h4><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/rotate1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/roate2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4<br>输出：<span class="hljs-comment">[2,0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 2 * 109</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RotateList &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode rotateRight(ListNode head, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>) &#123;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>            length++;<br>        &#125;<br>        ListNode tail = cur;<br><br>        <span class="hljs-keyword">int</span> position = length - k % length;<br>        <span class="hljs-keyword">if</span> (position == length) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">step</span> = <span class="hljs-number">0</span>;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>) &#123;<br>            prev = cur;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">step</span> == position) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        tail.<span class="hljs-keyword">next</span> = head;<br>        prev.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-comment">// 输入：head = [1,2,3,4,5], k = 2</span><br>        <span class="hljs-comment">// 输出：[4,5,1,2,3]</span><br>        ListNode node5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>);<br>        ListNode node4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>, node5);<br>        ListNode node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>, node4);<br>        ListNode node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>, node3);<br>        ListNode node1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>, node2);<br>        <span class="hljs-keyword">print</span>(rotateRight(node1, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 输入：head = [0,1,2], k = 4</span><br>        <span class="hljs-comment">// 输出：[2,0,1]</span><br>        node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>);<br>        node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>, node3);<br>        node1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, node2);<br>        <span class="hljs-keyword">print</span>(rotateRight(node1, <span class="hljs-number">4</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> ListNode &#123;<br>        <span class="hljs-keyword">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-keyword">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-keyword">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<br><span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。官方排的困难有些其实很简单，有些就很难了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PermutationSequence</title>
    <link href="/2021/04/11/PermutationSequence/"/>
    <url>/2021/04/11/PermutationSequence/</url>
    
    <content type="html"><![CDATA[<h4 id="排列序列"><a href="#排列序列" class="headerlink" title="排列序列"></a>排列序列</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/11/PermutationSequence/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/11/PermutationSequence/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="排列序列-1"><a href="#排列序列-1" class="headerlink" title="排列序列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/">排列序列</a></h4><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p><p><strong>示例1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;213&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">4</span>, k = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">&quot;2314&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li><code>1 &lt;= k &lt;= n!</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PermutationSequence &#123;<br><br>    <span class="hljs-built_in">public</span> static String getPermutation(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] factorial = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        // 记录n!有多少个数字组合<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            factorial[i] = factorial[i - <span class="hljs-number">1</span>] * i;<br>        &#125;<br><br>        <span class="hljs-comment">--k;</span><br>        StringBuffer ans = <span class="hljs-built_in">new</span> StringBuffer();<br>        <span class="hljs-type">int</span>[] <span class="hljs-keyword">valid</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(<span class="hljs-keyword">valid</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            // 找到第一个位置，k<span class="hljs-number">-1</span>是为了防止整除越界，因为一定会加<span class="hljs-number">1</span><br>            // 如果k整除又加<span class="hljs-number">1</span>，会最后一个多一位，下面也是如此<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">order</span> = k / factorial[n - i] + <span class="hljs-number">1</span>;<br>            // 记录目前使用的数字，已经使用过的当然跳过，<br>            // 不是说<span class="hljs-keyword">order</span>等于<span class="hljs-number">3</span>就选<span class="hljs-number">3</span>，而是选目前剩下的排第三的，<br>            // 所以这个<span class="hljs-keyword">order</span>算法太巧妙了<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">order</span> -= <span class="hljs-keyword">valid</span>[j];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">order</span> == <span class="hljs-number">0</span>) &#123;<br>                    ans.append(j);<br>                    <span class="hljs-keyword">valid</span>[j] = <span class="hljs-number">0</span>;<br>                    break;<br>                &#125;<br>            &#125;<br>            // 注意是i，不是<span class="hljs-number">1</span>，这里没有用公式+<span class="hljs-number">1</span>，相当于k自动减一，很巧妙<br>            k %= factorial[n - i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getPermutation(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getPermutation(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getPermutation(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">213</span><br><span class="hljs-number">2314</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是一道数学题呗。不过，官方的解题技巧太妙了，可以反复看。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpiralMatrixII</title>
    <link href="/2021/04/08/SpiralMatrixII/"/>
    <url>/2021/04/08/SpiralMatrixII/</url>
    
    <content type="html"><![CDATA[<h4 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/08/SpiralMatrixII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/08/SpiralMatrixII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="螺旋矩阵-II-1"><a href="#螺旋矩阵-II-1" class="headerlink" title="螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵 II</a></h4><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/spiraln.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SpiralMatrixII &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n][n];<br><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> column = left; <span class="hljs-keyword">column</span> &lt;= right; <span class="hljs-keyword">column</span>++) &#123;<br>                ans[top][<span class="hljs-keyword">column</span>] = ++num;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = top + <span class="hljs-number">1</span>; <span class="hljs-keyword">row</span> &lt;= bottom; <span class="hljs-keyword">row</span>++) &#123;<br>                ans[<span class="hljs-keyword">row</span>][right] = ++num;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> column = right - <span class="hljs-number">1</span>; <span class="hljs-keyword">column</span> &gt; left; <span class="hljs-keyword">column</span><span class="hljs-comment">--) &#123;</span><br>                    ans[bottom][<span class="hljs-keyword">column</span>] = ++num;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = bottom; <span class="hljs-keyword">row</span> &gt; top; <span class="hljs-keyword">row</span><span class="hljs-comment">--) &#123;</span><br>                    ans[<span class="hljs-keyword">row</span>][left] = ++num;<br>                &#125;<br>            &#125;<br>            left++;<br>            right<span class="hljs-comment">--;</span><br>            bottom<span class="hljs-comment">--;</span><br>            top++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        print(generateMatrix(<span class="hljs-number">3</span>));<br><br>        print(generateMatrix(<span class="hljs-number">1</span>));<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(anInt);<br>            &#125;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">123<br>894<br>765<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，和螺旋矩阵1很类似。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LengthOfLastWord</title>
    <link href="/2021/04/06/LengthOfLastWord/"/>
    <url>/2021/04/06/LengthOfLastWord/</url>
    
    <content type="html"><![CDATA[<h4 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/06/LengthOfLastWord/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/06/LengthOfLastWord/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最后一个单词的长度-1"><a href="#最后一个单词的长度-1" class="headerlink" title="最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a></h4><p>给你一个字符串 <code>s</code>，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;s.length&lt;&#x3D;104</li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LengthOfLastWord &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> lengthOfLastWord(String s) &#123;<br><br>        <span class="hljs-type">int</span> end = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">end</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(<span class="hljs-keyword">end</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span> &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-keyword">end</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(<span class="hljs-keyword">start</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">start</span><span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span> - <span class="hljs-keyword">start</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLastWord(&quot;Hello World&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLastWord(&quot; &quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，属于简单题目，看代码即可。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InsertInterval</title>
    <link href="/2021/04/01/InsertInterval/"/>
    <url>/2021/04/01/InsertInterval/</url>
    
    <content type="html"><![CDATA[<h4 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a>插入区间</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/01/InsertInterval/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/01/InsertInterval/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="插入区间-1"><a href="#插入区间-1" class="headerlink" title="插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/">插入区间</a></h4><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[12,16]</span>]</span>, newInterval = <span class="hljs-comment">[4,8]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,10]</span>,<span class="hljs-comment">[12,16]</span>]</span><br>解释：这是因为新的区间 <span class="hljs-comment">[4,8]</span> 与 <span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span> 重叠。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = [], newInterval = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-string">[[5,7]]</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,5]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-string">[[1,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,5]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-string">[[1,7]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0&lt;&#x3D;intervals.length&lt;&#x3D;104</li><li><code>intervals[i].length == 2</code></li><li>0&lt;&#x3D;intervals[i][0]&lt;&#x3D;intervals[i][1]&lt;&#x3D;105</li><li><code>intervals</code> 根据 <code>intervals[i][0]</code> 按 <strong>升序</strong> 排列</li><li><code>newInterval.length == 2</code></li><li>0&lt;&#x3D;newInterval[0]&lt;&#x3D;newInterval[1]&lt;&#x3D;105</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">InsertInterval</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">int</span>[][] insert(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals, <span class="hljs-built_in">int</span>[] newInterval) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals == <span class="hljs-literal">null</span> || <span class="hljs-built_in">int</span>ervals.length == <span class="hljs-number">0</span> || <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> new <span class="hljs-built_in">int</span>[][]&#123;&#123;newInterval[<span class="hljs-number">0</span>], newInterval[<span class="hljs-number">1</span>]&#125;&#125;;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> left = newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">int</span> right = newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 1 插入</span><br>        <span class="hljs-comment">// 2 合并，包括跨一个，和多个</span><br>        <span class="hljs-comment">// 想象成游标右移</span><br>        List&lt;<span class="hljs-built_in">int</span>[]&gt; ans = new ArrayList&lt;&gt;();<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-built_in">int</span>ervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &lt; left) &#123;<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-built_in">int</span>ervals.length - <span class="hljs-number">1</span>) &#123;<br>                    ans.add(new <span class="hljs-built_in">int</span>[]&#123;left, right&#125;);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;left, right&#125;);<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &gt;= right) &#123;<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;Math.min(left, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = Math.min(left, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]);<br>                i++;<br>                <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">int</span>ervals.length &amp;&amp; right &gt;= <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]) &#123;<br>                    i++;<br>                &#125;<br>                i--;<br>                right = Math.max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]);<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;left, right&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (++i &lt; <span class="hljs-built_in">int</span>ervals.length) &#123;<br>            ans.add(new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.toArray(new <span class="hljs-built_in">int</span>[ans.size()][]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br>        <span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;&#125;;<br>        <span class="hljs-built_in">int</span>[] newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">12</span>, <span class="hljs-number">16</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">8</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [], newInterval = [5,7]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [[1,5]], newInterval = [2,3]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [[1,5]], newInterval = [2,7]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">7</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[1, 5], [6, 9]]</span><br><span class="hljs-string">[[1, 2], [3, 10], [12, 16]]</span><br><span class="hljs-string">[[5, 7]]</span><br><span class="hljs-string">[[1, 5]]</span><br><span class="hljs-string">[[1, 7]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，可以将插入的值作为游标滑动在原数组上。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LowestCommonAncestorOfABinarySearchTree</title>
    <link href="/2021/03/31/LowestCommonAncestorOfABinarySearchTree/"/>
    <url>/2021/03/31/LowestCommonAncestorOfABinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/31/LowestCommonAncestorOfABinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/31/LowestCommonAncestorOfABinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉搜索树的最近公共祖先-1"><a href="#二叉搜索树的最近公共祖先-1" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/binarysearchtree_improved.png" alt="img"></p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="hljs-section">输出: 6 </span><br><span class="hljs-section">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LowestCommonAncestorOfABinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;<br><br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> == p.<span class="hljs-keyword">val</span> || root.<span class="hljs-keyword">val</span> == q.<span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> &lt; Math.min(p.<span class="hljs-keyword">val</span>, q.<span class="hljs-keyword">val</span>)) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> &gt; Math.max(p.<span class="hljs-keyword">val</span>, q.<span class="hljs-keyword">val</span>)) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode(int x) &#123;<br>            <span class="hljs-keyword">val</span> = x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是题目说的，简单。提前做这道题的缘由是看到微软的面试有，所以看下，没想到这么简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeIntervals</title>
    <link href="/2021/03/29/MergeIntervals/"/>
    <url>/2021/03/29/MergeIntervals/</url>
    
    <content type="html"><![CDATA[<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/29/MergeIntervals/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/29/MergeIntervals/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="合并区间-1"><a href="#合并区间-1" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h4><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 intervals[i]&#x3D;[starti,endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;intervals.length&lt;&#x3D;104</li><li><code>intervals[i].length == 2</code></li><li>0&lt;&#x3D;starti&lt;&#x3D;endi&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MergeIntervals</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">int</span>[][] merge(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals) &#123;<br><br>        <span class="hljs-comment">// 排序+合并</span><br>        Arrays.sort(<span class="hljs-built_in">int</span>ervals, (<span class="hljs-built_in">int</span>erval1, <span class="hljs-built_in">int</span>erval2) -&gt; <span class="hljs-built_in">int</span>erval1[<span class="hljs-number">0</span>] - <span class="hljs-built_in">int</span>erval2[<span class="hljs-number">0</span>]);<br><br>        List&lt;<span class="hljs-built_in">int</span>[]&gt; ans = new ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>ervals.length; i++) &#123;<br>            <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ans.size() == <span class="hljs-number">0</span> || ans.<span class="hljs-keyword">get</span>(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                ans.add(<span class="hljs-built_in">int</span>ervals[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-keyword">get</span>(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(ans.<span class="hljs-keyword">get</span>(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toArray(new <span class="hljs-built_in">int</span>[ans.size()][]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">18</span>&#125;&#125;;<br>        print(merge(<span class="hljs-built_in">int</span>ervals));<br><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>        print(merge(<span class="hljs-built_in">int</span>ervals));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static <span class="hljs-built_in">void</span> print(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>erval : <span class="hljs-built_in">int</span>ervals) &#123;<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;[&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-built_in">int</span>erval[<span class="hljs-number">0</span>]);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;,&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-built_in">int</span>erval[<span class="hljs-number">1</span>]);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[1,6]</span><span class="hljs-selector-attr">[8,10]</span><span class="hljs-selector-attr">[15,18]</span>, <span class="hljs-selector-attr">[1,5]</span>, <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是排序和比较，不过效率很低。后续有时间，写一个效率好一点的算法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JumpGame</title>
    <link href="/2021/03/28/JumpGame/"/>
    <url>/2021/03/28/JumpGame/</url>
    
    <content type="html"><![CDATA[<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/28/JumpGame/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/28/JumpGame/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="跳跃游戏-1"><a href="#跳跃游戏-1" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></h4><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为<span class="hljs-number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="hljs-number"> 0 </span>， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;3∗104</li><li>0&lt;&#x3D;nums[i]&lt;&#x3D;105</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JumpGame</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> last = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lastFlag = last;<br>        <span class="hljs-type">boolean</span>[] flags = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = last; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (i + nums[i] &gt;= lastFlag) &#123;<br>                flags[i] = <span class="hljs-literal">true</span>;<br>                lastFlag = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> flags[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">canJump</span>(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">canJump</span>(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是一个简单的动态规划方程。官方的贪吃当然效率会更好一点。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpiralMatrix</title>
    <link href="/2021/03/28/SpiralMatrix/"/>
    <url>/2021/03/28/SpiralMatrix/</url>
    
    <content type="html"><![CDATA[<h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/27/SpiralMatrix/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/27/SpiralMatrix/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="螺旋矩阵-1"><a href="#螺旋矩阵-1" class="headerlink" title="螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵</a></h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/spiral1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/spiral.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>m &#x3D;&#x3D; matrix.length</li><li>n &#x3D;&#x3D; matrix[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 10</li><li>-100 &lt;&#x3D; matrix[i][j]&lt;&#x3D; 100</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">package algorithm;</span><br><span class="language-xml"></span><br><span class="language-xml">import java.util.ArrayList;</span><br><span class="language-xml">import java.util.List;</span><br><span class="language-xml"></span><br><span class="language-xml">public class SpiralMatrix &#123;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static List<span class="hljs-tag">&lt;<span class="hljs-name">Integer</span>&gt;</span> spiralOrder(int[][] matrix) &#123;</span><br><span class="language-xml">        List<span class="hljs-tag">&lt;<span class="hljs-name">Integer</span>&gt;</span> ans = new ArrayList<span class="hljs-tag">&lt;&gt;</span>();</span><br><span class="language-xml">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="language-xml">            return ans;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">        int rows = matrix.length;</span><br><span class="language-xml">        int cols = matrix[0].length;</span><br><span class="language-xml">        int left = 0;</span><br><span class="language-xml">        int right = cols - 1;</span><br><span class="language-xml">        int top = 0;</span><br><span class="language-xml">        int bottom = rows - 1;</span><br><span class="language-xml">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="language-xml">            for (int column = left; column &lt;= right; column ++) &#123;</span><br><span class="language-xml">                ans.add(matrix[top][column]);</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            for (int row = top + 1; row &lt;= bottom; row ++) &#123;</span><br><span class="language-xml">                ans.add(matrix[row][right]);</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="language-xml">                for (int column = right - 1; column &gt; left; column --) &#123;</span><br><span class="language-xml">                    ans.add(matrix[bottom][column]);</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">                for (int row = bottom; row &gt; top; row --) &#123;</span><br><span class="language-xml">                    ans.add(matrix[row][left]);</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            top ++;</span><br><span class="language-xml">            right --;</span><br><span class="language-xml">            bottom --;</span><br><span class="language-xml">            left ++;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">        return ans;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static void main(String[] args) &#123;</span><br><span class="language-xml">        int[][] matrix = new int[][]</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        System.out.println(spiralOrder(matrix));</span><br><span class="language-xml"></span><br><span class="language-xml">        matrix = new int[][] </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        System.out.println(spiralOrder(matrix));</span><br><span class="language-xml"></span><br><span class="language-xml">        matrix = new int[][]</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        System.out.println(spiralOrder(matrix));</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 2, 3, 6, 9, 8, 7, 4, 5]</span><br><span class="hljs-string">[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</span><br><span class="hljs-string">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是把一个矩形成一个一个外在的框。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MaximumSubarray</title>
    <link href="/2021/03/27/MaximumSubarray/"/>
    <url>/2021/03/27/MaximumSubarray/</url>
    
    <content type="html"><![CDATA[<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/25/MaximumSubarray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/25/MaximumSubarray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最大子序和-1"><a href="#最大子序和-1" class="headerlink" title="最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></h4><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;3∗104</li><li>−105&lt;&#x3D;nums[i]&lt;&#x3D;105</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MaximumSubarray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> maxSubArray(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-type">Integer</span>.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            prev = Math.max(prev + nums[i], nums[i]);<br>            <span class="hljs-keyword">if</span> (max &lt; prev) &#123;<br>                max = prev;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-100000</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">6<br>1<br>0<br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-100000</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是一个简单的动态规划方程，至于发散开来的线段树目前没有写出来。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NQueensII</title>
    <link href="/2021/03/23/NQueensII/"/>
    <url>/2021/03/23/NQueensII/</url>
    
    <content type="html"><![CDATA[<h4 id="N皇后-II"><a href="#N皇后-II" class="headerlink" title="N皇后 II"></a>N皇后 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/23/NQueensII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/23/NQueensII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="N皇后-II-1"><a href="#N皇后-II-1" class="headerlink" title="N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">N皇后 II</a></h4><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/queens.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NQueensII &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> totalNQueens(<span class="hljs-type">int</span> n) &#123;<br><br>        <span class="hljs-type">int</span>[] queens = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        Arrays.fill(queens, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span> = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br><br>        // 从第<span class="hljs-number">0</span>行开始<br>        <span class="hljs-keyword">return</span> track(queens, n, <span class="hljs-number">0</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br>    &#125;<br><br>    private static <span class="hljs-type">Integer</span> track(<span class="hljs-type">int</span>[] queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>,<br>                              <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span>, <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1,<br>                              <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            // 每一行都要从第<span class="hljs-number">0</span>列开始遍历<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">columns</span>.contains(i)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = <span class="hljs-keyword">row</span> - i;<br>                <span class="hljs-keyword">if</span> (diagonals1.contains(diagonal1)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = <span class="hljs-keyword">row</span> + i;<br>                <span class="hljs-keyword">if</span> (diagonals2.contains(diagonal2)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[<span class="hljs-keyword">row</span>] = i;<br>                <span class="hljs-keyword">columns</span>.<span class="hljs-keyword">add</span>(i);<br>                diagonals1.<span class="hljs-keyword">add</span>(diagonal1);<br>                diagonals2.<span class="hljs-keyword">add</span>(diagonal2);<br>                count += track(queens, n, <span class="hljs-keyword">row</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br>                queens[<span class="hljs-keyword">row</span>] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">columns</span>.remove(i);<br>                diagonals1.remove(diagonal1);<br>                diagonals2.remove(diagonal2);<br>            &#125;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(totalNQueens(<span class="hljs-number">4</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(totalNQueens(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是回溯，把上一个的解法稍微改一下。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NQueens</title>
    <link href="/2021/03/21/NQueens/"/>
    <url>/2021/03/21/NQueens/</url>
    
    <content type="html"><![CDATA[<h4 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/21/NQueens/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/21/NQueens/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="N-皇后-1"><a href="#N-皇后-1" class="headerlink" title="N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/">N 皇后</a></h4><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/queens.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[&quot;Q&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NQueens &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-type">int</span> n) &#123;<br>        List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span>[] queens = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        Arrays.fill(queens, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span> = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br><br>        // 从第<span class="hljs-number">0</span>行开始<br>        track(ans, queens, n, <span class="hljs-number">0</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> track(List&lt;List&lt;String&gt;&gt; ans, <span class="hljs-type">int</span>[] queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>,<br>                                            <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span>, <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1,<br>                                            <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == n) &#123;<br>            List&lt;String&gt; strings = generateBoard(n, queens);<br>            ans.<span class="hljs-keyword">add</span>(strings);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // 每一行都要从第<span class="hljs-number">0</span>列开始遍历<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">columns</span>.contains(i)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = <span class="hljs-keyword">row</span> - i;<br>                <span class="hljs-keyword">if</span> (diagonals1.contains(diagonal1)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = <span class="hljs-keyword">row</span> + i;<br>                <span class="hljs-keyword">if</span> (diagonals2.contains(diagonal2)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[<span class="hljs-keyword">row</span>] = i;<br>                <span class="hljs-keyword">columns</span>.<span class="hljs-keyword">add</span>(i);<br>                diagonals1.<span class="hljs-keyword">add</span>(diagonal1);<br>                diagonals2.<span class="hljs-keyword">add</span>(diagonal2);<br>                track(ans, queens, n, <span class="hljs-keyword">row</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br>                queens[<span class="hljs-keyword">row</span>] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">columns</span>.remove(i);<br>                diagonals1.remove(diagonal1);<br>                diagonals2.remove(diagonal2);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    private static List&lt;String&gt; generateBoard(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] queens) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span>[] <span class="hljs-keyword">row</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[n];<br>            Arrays.fill(<span class="hljs-keyword">row</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-keyword">row</span>[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            String s = <span class="hljs-built_in">new</span> String(<span class="hljs-keyword">row</span>);<br>            result.<span class="hljs-keyword">add</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(solveNQueens(<span class="hljs-number">4</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(solveNQueens(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[.Q.., ...Q, Q..., ..Q.], [..Q., Q..., ...Q, .Q..]]</span><br><span class="hljs-string">[[Q]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是回溯。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pow(x, n)</title>
    <link href="/2021/03/20/PowxN/"/>
    <url>/2021/03/20/PowxN/</url>
    
    <content type="html"><![CDATA[<h4 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/20/PowxN/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/20/PowxN/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="Pow-x-n-1"><a href="#Pow-x-n-1" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。</p><p><strong>示例1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.00000</span>, n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1024.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.10000</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">9.26100</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.00000</span>, n = -<span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.25000</span><br>解释：<span class="hljs-number">2</span>-<span class="hljs-number">2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0</span>.<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li>−231&lt;&#x3D;n&lt;&#x3D;231−1</li><li>−104&lt;&#x3D;xn&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowxN</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">myPow</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">int</span> n</span>)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> n &gt;= <span class="hljs-number">0</span> ? getMulti(x, n) :  <span class="hljs-number">1.0</span> / getMulti(x, -(<span class="hljs-built_in">long</span>) n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getMulti</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">long</span> n</span>)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">double</span> multi = getMulti(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? multi * multi * x : multi * multi;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        <span class="hljs-built_in">double</span> x = <span class="hljs-number">2.00000</span>;<br>        <span class="hljs-built_in">int</span> n = <span class="hljs-number">10</span>;<br>        System.<span class="hljs-keyword">out</span>.println(myPow(x, n));<br><br>        x = <span class="hljs-number">2.10000</span>;<br>        n = <span class="hljs-number">3</span>;<br>        System.<span class="hljs-keyword">out</span>.println(myPow(x, n));<br><br>        x = <span class="hljs-number">2.00000</span>;<br>        n = <span class="hljs-number">-2</span>;<br>        System.<span class="hljs-keyword">out</span>.println(myPow(x, n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1024</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">9</span>.<span class="hljs-number">261000000000001</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是递归和二分。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GroupAnagrams</title>
    <link href="/2021/03/16/GroupAnagrams/"/>
    <url>/2021/03/16/GroupAnagrams/</url>
    
    <content type="html"><![CDATA[<h4 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/16/GroupAnagrams/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/16/GroupAnagrams/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="字母异位词分组-1"><a href="#字母异位词分组-1" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出:<br>[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupAnagrams</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-built_in">String</span>[] strs) &#123;<br>        Map&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> : strs) &#123;<br>            <span class="hljs-type">char</span>[] array = <span class="hljs-built_in">str</span>.<span class="hljs-property">toCharArray</span>();<br>            Arrays.<span class="hljs-property">sort</span>(array);<br>            <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(array);<br>            List&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-built_in">map</span>.<span class="hljs-property">getOrDefault</span>(<span class="hljs-built_in">key</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;());<br>            list.<span class="hljs-property">add</span>(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">key</span>, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">map</span>.<span class="hljs-property">values</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-built_in">String</span>[] strs = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>[]&#123;<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>&#125;;<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-title function_">groupAnagrams</span>(strs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[eat, tea, ate], [bat], [tan, nat]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，没想到官方的思路这么简单，而且效率这么低。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RotateImage</title>
    <link href="/2021/03/14/RotateImage/"/>
    <url>/2021/03/14/RotateImage/</url>
    
    <content type="html"><![CDATA[<h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/14/RotateImage/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/14/RotateImage/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="旋转图像-1"><a href="#旋转图像-1" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">旋转图像</a></h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1]]</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-string">[[3,1],[4,2]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>matrix.length == n</code></li><li><code>matrix[i].length == n</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RotateImage</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">rotate</span>(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++j) &#123;<br>                <span class="hljs-type">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>                matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>                matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>                matrix[j][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br><br>        matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br><br>        matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br><br>        matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;=====&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.<span class="hljs-property">out</span>.<span class="hljs-property">print</span>(anInt);<br>            &#125;<br>            System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>();<br>        &#125;<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;=====&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">123</span><br><span class="hljs-number">456</span><br><span class="hljs-number">789</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">741</span><br><span class="hljs-number">852</span><br><span class="hljs-number">963</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">51911</span><br><span class="hljs-number">24810</span><br><span class="hljs-number">13367</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">132511</span><br><span class="hljs-number">34110</span><br><span class="hljs-number">6897</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">12</span><br><span class="hljs-number">34</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">31</span><br><span class="hljs-number">42</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，当成数学题就好了。然后用个变量承接需要翻转的值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PermutationsII</title>
    <link href="/2021/03/12/PermutationsII/"/>
    <url>/2021/03/12/PermutationsII/</url>
    
    <content type="html"><![CDATA[<h4 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/12/PermutationsII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/12/PermutationsII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="全排列-II-1"><a href="#全排列-II-1" class="headerlink" title="全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a></h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermutationsII</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] vis;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; perm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.sort(nums);<br>        backtrack(nums, ans, <span class="hljs-number">0</span>, perm);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-type">int</span> idx, List&lt;Integer&gt; perm)</span> &#123;<br>        <span class="hljs-keyword">if</span> (idx == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(perm));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-comment">// 从左往右第一个未被填过的数字</span><br>            <span class="hljs-keyword">if</span> (vis[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !vis[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            perm.add(nums[i]);<br>            vis[i] = <span class="hljs-literal">true</span>;<br><br>            backtrack(nums, ans, idx + <span class="hljs-number">1</span>, perm);<br><br>            vis[i] = <span class="hljs-literal">false</span>;<br>            perm.remove(idx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        System.out.println(permuteUnique(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(permuteUnique(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[1, 1, 2]</span>, <span class="hljs-comment">[1, 2, 1]</span>, <span class="hljs-comment">[2, 1, 1]</span>]</span><br><span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>, <span class="hljs-comment">[3, 2, 1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，使用回溯，排序然后排重。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Permutations</title>
    <link href="/2021/03/09/Permutations/"/>
    <url>/2021/03/09/Permutations/</url>
    
    <content type="html"><![CDATA[<h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/09/Permutations/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/09/Permutations/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h4><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Permutations</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        List&lt;Integer&gt; output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            output.add(num);<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(output, ans, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-type">int</span> first)</span> &#123;<br>        <span class="hljs-keyword">if</span> (first == output.size()) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(output));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> first; i &lt; output.size(); i++) &#123;<br>            Collections.swap(output, i, first);<br>            backtrack(output, ans, first + <span class="hljs-number">1</span>);<br>            Collections.swap(output, i, first);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(permute(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 2, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，使用回溯。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JumpGameII</title>
    <link href="/2021/03/06/JumpGameII/"/>
    <url>/2021/03/06/JumpGameII/</url>
    
    <content type="html"><![CDATA[<h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/06/JumpGameII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/06/JumpGameII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="跳跃游戏-II-1"><a href="#跳跃游戏-II-1" class="headerlink" title="跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为<span class="hljs-number"> 0 </span>跳到下标为<span class="hljs-number"> 1 </span>的位置，跳<span class="hljs-number"> 1 </span>步，然后跳<span class="hljs-number"> 3 </span>步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JumpGameII</span> &#123;<br><br>    <span class="hljs-comment">// 贪心算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 怎么样才能找到每一步的最大</span><br>        <span class="hljs-comment">// 倒过来，算到终点的最小跳数，然后返回第一个数字的值</span><br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] stepArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[length - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + i &gt;= length - <span class="hljs-number">1</span>) &#123;<br>                stepArray[i] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> value = nums[i];<br>                <span class="hljs-type">int</span> min = Integer.MAX_VALUE - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= value; j++) &#123;<br>                    min = Math.<span class="hljs-built_in">min</span>(min, stepArray[i + j]);<br>                &#125;<br>                stepArray[i] = min + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stepArray[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">jump</span>(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">jump</span>(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，我用的是反向贪心，效率一般。官方的反向贪心效率更差了。正向贪心效率会好一点，也很优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WildcardMatching</title>
    <link href="/2021/03/04/WildcardMatching/"/>
    <url>/2021/03/04/WildcardMatching/</url>
    
    <content type="html"><![CDATA[<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/04/WildcardMatching/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/04/WildcardMatching/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="通配符匹配-1"><a href="#通配符匹配-1" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h4><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27;?&#x27; 可以匹配任何单个字符。<br>&#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。<br></code></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;aa&quot;</span><br>p = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;aa&quot;</span><br>p = <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: &#x27;*&#x27; 可以匹配任意字符串。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入:<br>s = <span class="hljs-string">&quot;cb&quot;</span><br>p = <span class="hljs-string">&quot;?a&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释: <span class="hljs-string">&#x27;?&#x27;</span> 可以匹配 <span class="hljs-string">&#x27;c&#x27;</span>, 但第二个 <span class="hljs-string">&#x27;a&#x27;</span> 无法匹配 <span class="hljs-string">&#x27;b&#x27;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;adceb&quot;</span><br>p = <span class="hljs-string">&quot;*a*b&quot;</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;.</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;acdcb&quot;</span><br>p = <span class="hljs-string">&quot;a*c?b&quot;</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> WildcardMatching &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isMatch(String s, String p) &#123;<br>        <span class="hljs-type">int</span> m = s.length();<br>        <span class="hljs-type">int</span> n = p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;?&#x27;</span> || s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;aa&quot;, &quot;a&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;aa&quot;, &quot;*&quot;));//t<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;cb&quot;, &quot;?a&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;adceb&quot;, &quot;*a*b&quot;));//t<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;acdcb&quot;, &quot;a*c?b&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，效率一般，用的是递归。所以改用了官方的动态方程，其实效率还是一般。动态方程和边界条件写好了，答案也就出来了，不是很难。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MultiplyStrings</title>
    <link href="/2021/03/02/MultiplyStrings/"/>
    <url>/2021/03/02/MultiplyStrings/</url>
    
    <content type="html"><![CDATA[<h4 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/02/MultiplyStrings/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/02/MultiplyStrings/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="字符串相乘-1"><a href="#字符串相乘-1" class="headerlink" title="字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span><br>输出: <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span><br>输出: <span class="hljs-string">&quot;56088&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>num1 和 num2 的长度小于110。</code></li><li><code>num1 和 num2 只包含数字 0-9。</code></li><li><code>num1 和 num2 均不以零开头，除非是数字 0 本身。</code></li><li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MultiplyStrings &#123;<br><br>    <span class="hljs-built_in">public</span> String multiply1(String num1, String num2) &#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;<br>            <span class="hljs-keyword">return</span> &quot;0&quot;;<br>        &#125;<br>        <span class="hljs-type">int</span> m = num1.length(), n = num2.length();<br>        <span class="hljs-type">int</span>[] ansArr = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m + n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-type">int</span> x = num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j<span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-type">int</span> y = num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        StringBuffer ans = <span class="hljs-built_in">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; m + n) &#123;<br>            ans.append(ansArr[<span class="hljs-keyword">index</span>]);<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static String multiply(String num1, String num2) &#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;<br>            <span class="hljs-keyword">return</span> &quot;0&quot;;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">222</span>];<br>        Arrays.fill(result, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">char</span>[] chars1 = num1.toCharArray();<br>        <span class="hljs-type">char</span>[] chars2 = num2.toCharArray();<br><br>        <span class="hljs-type">int</span> length1 = chars1.length - <span class="hljs-number">1</span>;//<span class="hljs-number">456</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length1; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123; //123</span><br>            <span class="hljs-type">int</span> length2 = chars2.length - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = length2; j &gt;= <span class="hljs-number">0</span>; j<span class="hljs-comment">--) &#123;//456</span><br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = (chars1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (chars2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">index</span> = length1 - i + length2 - j;<br>                <span class="hljs-keyword">temp</span> += result[<span class="hljs-keyword">index</span>] + carry;<br><br>                result[<span class="hljs-keyword">index</span>] = <span class="hljs-keyword">temp</span> % <span class="hljs-number">10</span>;<br>                carry = <span class="hljs-keyword">temp</span> / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>               result[<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>] = carry;<br>            &#125;<br>        &#125;<br>        StringBuilder sb = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-type">boolean</span> first = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = result.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">if</span> (!first &amp;&amp; result[i] != <span class="hljs-number">0</span>) &#123;<br>                sb.append(result[i]);<br>                first = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first) &#123;<br>                sb.append(result[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(multiply(&quot;2&quot;, &quot;3&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(multiply(&quot;123&quot;, &quot;456&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(multiply(&quot;999&quot;, &quot;99999&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">6</span><br><span class="hljs-number">56088</span><br><span class="hljs-number">99899001</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，效率一般，类似于官方的乘法算法，比加法算法效率好一点。官方的乘法优化非常彻底，可以仔细品味。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TrappingRainWater</title>
    <link href="/2021/02/27/TrappingRainWater/"/>
    <url>/2021/02/27/TrappingRainWater/</url>
    
    <content type="html"><![CDATA[<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/27/TrappingRainWater/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/27/TrappingRainWater/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="接雨水-1"><a href="#接雨水-1" class="headerlink" title="接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></h4><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/rainwatertrap.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TrappingRainWater &#123;<br><br>    // 凹形槽的两个条件：一个是往右找，比自己高的，那就停止；一个是找最近接自己高度的<br>    // 也就是第二高的，记录位置<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> trap(<span class="hljs-type">int</span>[] height) &#123;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; height.length &amp;&amp; left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                left++;<br>                right = left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> tempMax = right;<br>            <span class="hljs-keyword">while</span> (right &lt; height.length &amp;&amp; height[left] &gt; height[right]) &#123;<br>                <span class="hljs-keyword">if</span> (height[right] &gt; height[tempMax]) &#123;<br>                    tempMax = right;<br>                &#125;<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right &lt; height.length &amp;&amp; height[right] &gt; height[tempMax]) &#123;<br>                tempMax = right;<br>            &#125;<br>            <span class="hljs-type">int</span> minHeight = Math.min(height[left], height[tempMax]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; tempMax; i++) &#123;<br>                area += minHeight - height[i];<br>            &#125;<br>            left = tempMax;<br>            right = left + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> trap1(<span class="hljs-type">int</span>[] height) &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rightMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                <span class="hljs-keyword">if</span> (height[left] &gt;= leftMax) &#123;<br>                    leftMax = height[left];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans += leftMax - height[left];<br>                &#125;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (height[right] &gt;= rightMax) &#123;<br>                    rightMax = height[right];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans += rightMax - height[right];<br>                &#125;<br>                right<span class="hljs-comment">--;</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] height = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(trap1(height));<br><br>        height = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(trap1(height));<br><br>        height = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(trap1(height));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>9<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，效率一般，也是双指针的变形，不过没有官方的优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FirstMissingPositive</title>
    <link href="/2021/02/25/FirstMissingPositive/"/>
    <url>/2021/02/25/FirstMissingPositive/</url>
    
    <content type="html"><![CDATA[<h4 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/25/FirstMissingPositive/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/25/FirstMissingPositive/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="缺失的第一个正数-1"><a href="#缺失的第一个正数-1" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></h4><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p><strong>进阶：</strong>你可以实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案吗？</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,0]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,4,-1,1]</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,8,9,11,12]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> FirstMissingPositive &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> firstMissingPositive1(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> length = nums.length;<br><br>        // 转成正数，注意用下标，否则不生效<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>                nums[i] = length + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> num = Math.abs(nums[i]);<br>            <span class="hljs-keyword">if</span> (num &lt;= length) &#123;<br>                nums[num - <span class="hljs-number">1</span>] = -Math.abs(nums[num - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length + <span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> firstMissingPositive(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; length &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[nums[i] - <span class="hljs-number">1</span>];<br>                nums[nums[i] - <span class="hljs-number">1</span>] = nums[i];<br>                nums[i] = <span class="hljs-keyword">temp</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        // <span class="hljs-number">3</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(firstMissingPositive(nums));<br><br>        // <span class="hljs-number">2</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(firstMissingPositive(nums));<br><br>        // <span class="hljs-number">1</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(firstMissingPositive(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，比hash方法的稍微好一点，比两两互换的差了些许。不过还是采纳了官方的解法。考察的其实还是数学功底，算法本身不难。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CombinationSumII</title>
    <link href="/2021/02/23/CombinationSumII/"/>
    <url>/2021/02/23/CombinationSumII/</url>
    
    <content type="html"><![CDATA[<h4 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/23/CombinationSumII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/23/CombinationSumII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="组合总和-II-1"><a href="#组合总和-II-1" class="headerlink" title="组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></h4><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>所求解集为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 2, 5]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2, 6]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 1, 6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,<br>所求解集为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CombinationSumII &#123;<br><br>    static List&lt;<span class="hljs-type">int</span> []&gt; freq = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    static List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">sequence</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum2(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;<br>        Arrays.sort(candidates);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candidate : candidates) &#123;<br>            <span class="hljs-keyword">if</span> (freq.isEmpty() || freq.<span class="hljs-keyword">get</span>(freq.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] != candidate) &#123;<br>                freq.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;candidate, <span class="hljs-number">1</span>&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++freq.<span class="hljs-keyword">get</span>(freq.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">sequence</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos == freq.size() || target &lt; freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        // 跳过<br>        dfs(pos + <span class="hljs-number">1</span>, target);<br><br>        <span class="hljs-type">int</span> most = Math.min(target / freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>], freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= most; i++) &#123;<br>            <span class="hljs-keyword">sequence</span>.<span class="hljs-keyword">add</span>(freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]);<br>            // 虽然每次都会循环，但是pos都不变，也就是每次从下一个为为孩子开始，但是重复数字会叠加<br>            dfs(pos + <span class="hljs-number">1</span>, target - i * freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= most; i++) &#123;<br>            <span class="hljs-keyword">sequence</span>.remove(<span class="hljs-keyword">sequence</span>.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> targe = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum2(candidates, targe));<br><br>        candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>        targe = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum2(candidates, targe));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[2, 6]</span>, <span class="hljs-comment">[1, 7]</span>, <span class="hljs-comment">[1, 2, 5]</span>, <span class="hljs-comment">[1, 1, 6]</span>]</span><br><span class="hljs-comment">[<span class="hljs-comment">[2, 6]</span>, <span class="hljs-comment">[1, 7]</span>, <span class="hljs-comment">[1, 2, 5]</span>, <span class="hljs-comment">[1, 1, 6]</span>, <span class="hljs-comment">[5]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是搜索回溯。注意的是，不能有重复。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CombinationSum</title>
    <link href="/2021/02/20/CombinationSum/"/>
    <url>/2021/02/20/CombinationSum/</url>
    
    <content type="html"><![CDATA[<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/20/CombinationSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/20/CombinationSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="组合总和-1"><a href="#组合总和-1" class="headerlink" title="组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></h4><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：candidates = <span class="hljs-comment">[2,3,6,7]</span>, target = 7,<br>所求解集为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,2,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8,<br>所求解集为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,2,2,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都是独一无二的。</li><li><code>1 &lt;= target &lt;= 500</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CombinationSum &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; element = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        dfs(result, element, candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> dfs(List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result, List&lt;<span class="hljs-type">Integer</span>&gt; element, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            // 注意因为会回溯，所以需要新建一个，回溯会改变集合<br>            result.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(element));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == candidates.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        // 跳过<span class="hljs-keyword">index</span><br>        dfs(result, element, candidates, target, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>);<br>        // 使用当前<span class="hljs-keyword">index</span><br>        <span class="hljs-keyword">if</span> (target - candidates[<span class="hljs-keyword">index</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>            element.<span class="hljs-keyword">add</span>(candidates[<span class="hljs-keyword">index</span>]);<br>            dfs(result, element, candidates, target - candidates[<span class="hljs-keyword">index</span>], <span class="hljs-keyword">index</span>);<br>            element.remove(element.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span> targe = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum(candidates, targe));<br><br>        candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        targe = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum(candidates, targe));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[7], [2, 2, 3]]</span><br><span class="hljs-string">[[3, 5], [2, 3, 3], [2, 2, 2, 2]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是搜索回溯。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CountAndSay</title>
    <link href="/2021/02/18/CountAndSay/"/>
    <url>/2021/02/18/CountAndSay/</url>
    
    <content type="html"><![CDATA[<h4 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/18/CountAndSay/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/18/CountAndSay/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="外观数列-1"><a href="#外观数列-1" class="headerlink" title="外观数列"></a><a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></h4><p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li></ul><p>前五项如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">1.     1<br>2.     11<br>3.     21<br>4.     1211<br>5.     111221<br>第一项是数字<span class="hljs-number"> 1 </span><br>描述前一项，这个数是<span class="hljs-number"> 1 </span>即 “ 一 个<span class="hljs-number"> 1 </span>”，记作 &quot;11&quot;<br>描述前一项，这个数是<span class="hljs-number"> 11 </span>即 “ 二 个<span class="hljs-number"> 1 </span>” ，记作 &quot;21&quot;<br>描述前一项，这个数是<span class="hljs-number"> 21 </span>即 “ 一 个<span class="hljs-number"> 2 </span>+ 一 个<span class="hljs-number"> 1 </span>” ，记作 &quot;1211&quot;<br>描述前一项，这个数是<span class="hljs-number"> 1211 </span>即 “ 一 个<span class="hljs-number"> 1 </span>+ 一 个<span class="hljs-number"> 2 </span>+ 二 个<span class="hljs-number"> 1 </span>” ，记作 &quot;111221&quot;<br></code></pre></td></tr></table></figure><p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><p>例如，数字字符串 <code>&quot;3322251&quot;</code> 的描述如下图：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/countandsay.jpg" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;1&quot;</span><br>解释：这是一个基本样例。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span><br>输出：<span class="hljs-string">&quot;1211&quot;</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span> = <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span> = 读 <span class="hljs-string">&quot;1&quot;</span> = 一 个 <span class="hljs-number">1</span> = <span class="hljs-string">&quot;11&quot;</span><br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span> = 读 <span class="hljs-string">&quot;11&quot;</span> = 二 个 <span class="hljs-number">1</span> = <span class="hljs-string">&quot;21&quot;</span><br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span> = 读 <span class="hljs-string">&quot;21&quot;</span> = 一 个 <span class="hljs-number">2</span> + 一 个 <span class="hljs-number">1</span> = <span class="hljs-string">&quot;12&quot;</span> + <span class="hljs-string">&quot;11&quot;</span> = <span class="hljs-string">&quot;1211&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CountAndSay &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String countAndSay(<span class="hljs-keyword">int</span> n) &#123;<br><br>        String result = <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            result = <span class="hljs-keyword">count</span>(result);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-keyword">count</span>(String s) &#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">char</span> comp = s.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(comp == c) &#123;<br>                <span class="hljs-keyword">count</span>++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stringBuilder.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">count</span>);<br>                stringBuilder.<span class="hljs-keyword">append</span>(comp);<br>                comp = c;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        stringBuilder.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">count</span>);<br>        stringBuilder.<span class="hljs-keyword">append</span>(comp);<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">1</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">2</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">3</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">4</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-number">11</span><br><span class="hljs-number">21</span><br><span class="hljs-number">1211</span><br><span class="hljs-number">111221</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是迭代每个数字，并且计算数字出现的次数。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SudokuSolver</title>
    <link href="/2021/02/16/SudokuSolver/"/>
    <url>/2021/02/16/SudokuSolver/</url>
    
    <content type="html"><![CDATA[<h4 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/16/SudokuSolver/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/16/SudokuSolver/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="解数独-1"><a href="#解数独-1" class="headerlink" title="解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a></h4><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需<strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>一个数独。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p><p>答案被标成红色。</p><p><strong>提示：</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SudokuSolver</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[][] line = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[][] column = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[][][] block = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> valid = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> List&lt;<span class="hljs-type">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    spaces.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> digit = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">1</span>;<br>                    line[i][digit] = column[j][digit] = block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == spaces.<span class="hljs-built_in">size</span>()) &#123;<br>            valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] space = spaces.<span class="hljs-built_in">get</span>(pos);<br>        <span class="hljs-comment">// 递归空间</span><br>        <span class="hljs-type">int</span> i = space[<span class="hljs-number">0</span>], j = space[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> digit = <span class="hljs-number">0</span>; digit &lt; <span class="hljs-number">9</span> &amp;&amp; !valid; ++digit) &#123;<br>            <span class="hljs-keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit]) &#123;<br>                line[i][digit] = column[j][digit] = block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-literal">true</span>;<br>                board[i][j] = (<span class="hljs-type">char</span>) (digit + <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">dfs</span>(board, pos + <span class="hljs-number">1</span>);<br>                line[i][digit] = column[j][digit] = block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;<br>                &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        <span class="hljs-built_in">solveSudoku</span>(board);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是递归。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidSudoku</title>
    <link href="/2021/02/14/ValidSudoku/"/>
    <url>/2021/02/14/ValidSudoku/</url>
    
    <content type="html"><![CDATA[<h4 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/14/ValidSudoku/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/14/ValidSudoku/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="有效的数独-1"><a href="#有效的数独-1" class="headerlink" title="有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">有效的数独</a></h4><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入:<br>[<br>  [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br>  [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br>  [<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br>]<br>输出: true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入:<br>[<br>  [<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br>  [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br>  [<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br>]<br>输出: false<br>解释: 除了第一行的第一个数字从 <span class="hljs-number">5</span> 改为 <span class="hljs-number">8</span> 以外，空格内其他数字均与 示例<span class="hljs-number">1</span> 相同。<br>     但由于位于左上角的 <span class="hljs-number">3</span>x3 宫内有两个 <span class="hljs-number">8</span> 存在, 因此这个数独是无效的。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ValidSudoku &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isValidSudoku(<span class="hljs-type">char</span>[][] board) &#123;<br><br>        // init data<br>        HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;[] <span class="hljs-keyword">rows</span> = <span class="hljs-built_in">new</span> HashMap[<span class="hljs-number">9</span>];<br>        HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;[] <span class="hljs-keyword">columns</span> = <span class="hljs-built_in">new</span> HashMap[<span class="hljs-number">9</span>];<br>        HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;[] boxes = <span class="hljs-built_in">new</span> HashMap[<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">rows</span>[i] = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>            <span class="hljs-keyword">columns</span>[i] = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>            boxes[i] = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>        &#125;<br><br>        // <span class="hljs-keyword">validate</span> a board<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-type">char</span> num = board[i][j];<br>                <span class="hljs-keyword">if</span> (num != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> n = num;<br>                    <span class="hljs-type">int</span> box_index = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;<br><br>                    // keep the <span class="hljs-keyword">current</span> cell <span class="hljs-keyword">value</span><br>                    <span class="hljs-keyword">rows</span>[i].put(n, <span class="hljs-keyword">rows</span>[i].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">columns</span>[j].put(n, <span class="hljs-keyword">columns</span>[j].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>                    // <span class="hljs-keyword">check</span> <span class="hljs-keyword">if</span> this <span class="hljs-keyword">value</span> has been already seen <span class="hljs-keyword">before</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">rows</span>[i].<span class="hljs-keyword">get</span>(n) &gt; <span class="hljs-number">1</span> || <span class="hljs-keyword">columns</span>[j].<span class="hljs-keyword">get</span>(n) &gt; <span class="hljs-number">1</span> || boxes[box_index].<span class="hljs-keyword">get</span>(n) &gt; <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[][]&#123;<br>                &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isValidSudoku(board));<br><br>        board = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[][]&#123;<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isValidSudoku(board));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是一次迭代，记录所有的数字。然后比对是否有大于1的记录。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchInsertPosition</title>
    <link href="/2021/02/12/SearchInsertPosition/"/>
    <url>/2021/02/12/SearchInsertPosition/</url>
    
    <content type="html"><![CDATA[<h4 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/12/SearchInsertPosition/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/12/SearchInsertPosition/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索插入位置-1"><a href="#搜索插入位置-1" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 0</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchInsertPosition</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span> || <span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> &gt; nums[length - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == nums[left]) &#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == nums[right]) &#123;<br>                <span class="hljs-keyword">return</span> right;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == nums[mid]) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> &gt; nums[mid]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 5</span><br>        <span class="hljs-comment">//输出: 2</span><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 2</span><br>        <span class="hljs-comment">//输出: 1</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">2</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 7</span><br>        <span class="hljs-comment">//输出: 4</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 0</span><br>        <span class="hljs-comment">//输出: 0</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//[1,3,5]</span><br>        <span class="hljs-comment">//4</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br>4<br>0<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是二分查找，不过官方的解答比较优雅。还有就是这个除法：((right−left)&gt;&gt;1)+left。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FindFirstAndLastPositionOfElementInSortedArray</title>
    <link href="/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/"/>
    <url>/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/</url>
    
    <content type="html"><![CDATA[<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="在排序数组中查找元素的第一个和最后一个位置-1"><a href="#在排序数组中查找元素的第一个和最后一个位置-1" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0&lt;&#x3D;nums.length&lt;&#x3D;105</li><li>10−9&lt;&#x3D;nums[i]&lt;&#x3D;109</li><li><code>nums</code> 是一个非递减数组</li><li>10−9&lt;&#x3D;target&lt;&#x3D;109</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> FindFirstAndLastPositionOfElementInSortedArray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-type">int</span>[] result;<br><br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                left = right = mid;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-comment">--left &gt;= 0 &amp;&amp; nums[left] == target) &#123;</span><br><br>                &#125;<br>                left++;<br>                <span class="hljs-keyword">while</span> (++right &lt; length &amp;&amp; nums[right] == target) &#123;<br><br>                &#125;<br>                right<span class="hljs-comment">--;</span><br>                result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;left, right&#125;;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        //nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">8</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(searchRange(nums, target)));<br><br>        //nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">6</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>        target = <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(searchRange(nums, target)));<br><br>        //nums = [], target = <span class="hljs-number">0</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>        target = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(searchRange(nums, target)));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[3, 4]<br>[<span class="hljs-string">-1</span>, <span class="hljs-string">-1</span>]<br>[<span class="hljs-string">-1</span>, <span class="hljs-string">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是二分查找，然后扩展边界。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchInRotatedSortedArray</title>
    <link href="/2021/02/07/SearchInRotatedSortedArray/"/>
    <url>/2021/02/07/SearchInRotatedSortedArray/</url>
    
    <content type="html"><![CDATA[<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/07/SearchInRotatedSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/07/SearchInRotatedSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索旋转排序数组-1"><a href="#搜索旋转排序数组-1" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h4><p>升序排列的整数数组 <code>nums</code> 在预先未知的某个点上进行了旋转（例如， <code>[0,1,2,4,5,6,7]</code> 经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> ）。</p><p>请你在数组中搜索 <code>target</code> ，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchInRotatedSortedArray</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(nums[mid] &lt; nums[right])</span> </span>&#123;<span class="hljs-comment">// 右边有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; <span class="hljs-keyword">target</span> &amp;&amp; <span class="hljs-keyword">target</span> &lt;= nums[right]) &#123; <span class="hljs-comment">// 落在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 落在左边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 左边有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &gt; <span class="hljs-keyword">target</span> &amp;&amp; <span class="hljs-keyword">target</span> &gt;= nums[left]) &#123; <span class="hljs-comment">// 落在左边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 落在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        System.out.println(search(nums, <span class="hljs-keyword">target</span>));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span>;<br>        System.out.println(search(nums, <span class="hljs-keyword">target</span>));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        System.out.println(search(nums, <span class="hljs-keyword">target</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">4<br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是旋转后，怎么判断数据在左边还是右边，然后结合二分查找。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestValidParentheses</title>
    <link href="/2021/02/06/LongestValidParentheses/"/>
    <url>/2021/02/06/LongestValidParentheses/</url>
    
    <content type="html"><![CDATA[<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/06/LongestValidParentheses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/06/LongestValidParentheses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最长有效括号-1"><a href="#最长有效括号-1" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a></h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span>xxxxxxxxxx 输入：s = <span class="hljs-string">&quot;&quot;</span>输出：<span class="hljs-number">0</span>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestValidParentheses</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[s.<span class="hljs-built_in">length</span>()];<br><br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt; <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.<span class="hljs-built_in">charAt</span>(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + (i - dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                max = Math.<span class="hljs-built_in">max</span>(max, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">print</span>(dp);<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : dp) &#123;<br>            System.out.<span class="hljs-built_in">print</span>(i);<br>        &#125;<br>        System.out.<span class="hljs-built_in">println</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-type">String</span> s = <span class="hljs-string">&quot;(()&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestValidParentheses</span>(s));<br>        s = <span class="hljs-string">&quot;)()())&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestValidParentheses</span>(s));<br>        s = <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestValidParentheses</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">002<br>2<br>002040<br>4<br><br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是dp，写出方程后，就简单了。不过，需要注意，只是求最大值，不是求每个dp位置上准确的数值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NextPermutation</title>
    <link href="/2021/02/05/NextPermutation/"/>
    <url>/2021/02/05/NextPermutation/</url>
    
    <content type="html"><![CDATA[<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/05/NextPermutation/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/05/NextPermutation/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="下一个排列-1"><a href="#下一个排列-1" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></h4><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,5]</span><br>输出：<span class="hljs-comment">[1,5,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NextPermutation &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> nextPermutation(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-type">int</span> i = nums.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i<span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> j = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt; i &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j<span class="hljs-comment">--;</span><br>            &#125;<br>            swap(nums, i, j);<br>        &#125;<br>        reverse(nums, i + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> reverse(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left) &#123;<br>        <span class="hljs-type">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left ++;<br>            right <span class="hljs-comment">--;</span><br>        &#125;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> swap(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = <span class="hljs-keyword">temp</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        // nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(num);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">132<br>123<br>151<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题没做出来。主要是需要证明一个算法有效性：就是从右往左扫描，分两次。第一次，需要判定某个数往右，是降序排列；然后，交换这个数字与右边从后往前第一个大于它的数字，然后将右边数字升序。这种算法是容易证明是正确的，但是需要意识到这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SubstringWithConcatenationOfAllWords</title>
    <link href="/2021/02/02/SubstringWithConcatenationOfAllWords/"/>
    <url>/2021/02/02/SubstringWithConcatenationOfAllWords/</url>
    
    <content type="html"><![CDATA[<h2 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/02/SubstringWithConcatenationOfAllWords/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/02/SubstringWithConcatenationOfAllWords/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="串联所有单词的子串-1"><a href="#串联所有单词的子串-1" class="headerlink" title="串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">串联所有单词的子串</a></h4><p>给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words。</strong>找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>  s = <span class="hljs-string">&quot;barfoothefoobarman&quot;</span>,<br>  words = [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">9</span>]<br>解释：<br>从索引 <span class="hljs-number">0</span> 和 <span class="hljs-number">9</span> 开始的子串分别是 <span class="hljs-string">&quot;barfoo&quot;</span> 和 <span class="hljs-string">&quot;foobar&quot;</span> 。<br>输出的顺序不重要, [<span class="hljs-number">9</span>,<span class="hljs-number">0</span>] 也是有效答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>  s = <span class="hljs-string">&quot;wordgoodgoodgoodbestword&quot;</span>,<br>  words = [<span class="hljs-string">&quot;word&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>,<span class="hljs-string">&quot;best&quot;</span>,<span class="hljs-string">&quot;word&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubstringWithConcatenationOfAllWords</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span> || words == <span class="hljs-literal">null</span> || words.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">one_word</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">word_num</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">all_len</span> <span class="hljs-operator">=</span> one_word * word_num;<br>        <span class="hljs-comment">// 统计单词出现次数</span><br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            map.put(word, map.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 母串从0到可以容纳的长度，循环匹配</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - all_len + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s.substring(i, i + all_len);<br>            Map&lt;String, Integer&gt; tmp_map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">// 每次截取字符串，最后判断是否相等</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; all_len; j += one_word) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> tmp.substring(j, j + one_word);<br>                tmp_map.put(w, tmp_map.getOrDefault(w, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.equals(tmp_map)) &#123;<br>                res.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring1</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Map&lt;String, Integer&gt; wordsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span> || words.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span> (String word: words) &#123;<br>            <span class="hljs-comment">// 主串s中没有这个单词，直接返回空</span><br>            <span class="hljs-keyword">if</span> (s.indexOf(word) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-comment">// map中保存每个单词，和它出现的次数</span><br>            wordsMap.put(word, wordsMap.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 每个单词的长度， 总长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oneLen</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length(), wordsLen = oneLen * words.length;<br>        <span class="hljs-comment">// 主串s长度小于单词总和，返回空</span><br>        <span class="hljs-keyword">if</span> (wordsLen &gt; s.length()) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 只讨论从0，1，...， oneLen-1 开始的子串情况，</span><br>        <span class="hljs-comment">// 每次进行匹配的窗口大小为 wordsLen，每次后移一个单词长度，由左右窗口维持当前窗口位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oneLen; ++i) &#123;<br>            <span class="hljs-comment">// 左右窗口</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i, count = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 统计每个符合要求的word</span><br>            Map&lt;String, Integer&gt; subMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">// 右窗口不能超出主串长度</span><br>            <span class="hljs-keyword">while</span> (right + oneLen &lt;= s.length()) &#123;<br>                <span class="hljs-comment">// 得到一个单词</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(right, right + oneLen);<br>                <span class="hljs-comment">// 有窗口右移</span><br>                right += oneLen;<br>                <span class="hljs-comment">// words[]中没有这个单词，那么当前窗口肯定匹配失败，直接右移到这个单词后面</span><br>                <span class="hljs-keyword">if</span> (!wordsMap.containsKey(word)) &#123;<br>                    left = right;<br>                    <span class="hljs-comment">// 窗口内单词统计map清空，重新统计</span><br>                    subMap.clear();<br>                    <span class="hljs-comment">// 符合要求的单词数清0</span><br>                    count = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 统计当前子串中这个单词出现的次数</span><br>                    subMap.put(word, subMap.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    ++count;<br>                    <span class="hljs-comment">// 如果这个单词出现的次数大于words[]中它对应的次数，又由于每次匹配和words长度相等的子串</span><br>                    <span class="hljs-comment">// 如 &quot;foobarfoobarfoothe&quot;  [&quot;foo&quot;,&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span><br>                    <span class="hljs-comment">// 第二个bar虽然是words[]中的单词，但是次数抄了，那么右移一个单词长度后 &quot;barfoobarfoothe&quot;</span><br>                    <span class="hljs-comment">// bar还是不符合，所以直接从这个不符合的bar之后开始匹配，也就是将这个不符合的bar和它之前的单词(串)全移出去</span><br>                    <span class="hljs-keyword">while</span> (subMap.getOrDefault(word, <span class="hljs-number">0</span>) &gt; wordsMap.getOrDefault(word, <span class="hljs-number">0</span>)) &#123;<br>                        <span class="hljs-comment">// 从当前窗口字符统计map中删除从左窗口开始到数量超限的所有单词(次数减一)</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> s.substring(left, left + oneLen);<br>                        subMap.put(w, subMap.getOrDefault(w, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                        <span class="hljs-comment">// 符合的单词数减一</span><br>                        --count;<br>                        <span class="hljs-comment">// 左窗口位置右移</span><br>                        left += oneLen;<br>                    &#125;<br>                    <span class="hljs-comment">// 当前窗口字符串满足要求</span><br>                    <span class="hljs-keyword">if</span> (count == words.length) res.add(left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaaaaaaaaaaaa&quot;</span>;<br>        String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>&#125;;<br>        System.out.println(findSubstring(s, words));<br><br>        s = <span class="hljs-string">&quot;wordgoodgoodgoodbestword&quot;</span>;<br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;word&quot;</span>, <span class="hljs-string">&quot;good&quot;</span>, <span class="hljs-string">&quot;best&quot;</span>, <span class="hljs-string">&quot;word&quot;</span>&#125;;<br>        System.out.println(findSubstring(s, words));<br><br>        s = <span class="hljs-string">&quot;barfoofoobarthefoobarman&quot;</span>;<br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br>        System.out.println(findSubstring(s, words));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题没做出来。本来以为是字符匹配。应该好好审题，子串长度都是一致的。算法大致有两种，hash存储子串和个数，最终比较；另一种，与之类似，只不过，用滑动窗口实现优化。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DivideTwoIntegers</title>
    <link href="/2021/02/01/DivideTwoIntegers/"/>
    <url>/2021/02/01/DivideTwoIntegers/</url>
    
    <content type="html"><![CDATA[<h2 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/01/DivideTwoIntegers/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/01/DivideTwoIntegers/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="两数相除-1"><a href="#两数相除-1" class="headerlink" title="两数相除"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/">两数相除</a></h4><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：truncate(8.345) &#x3D; 8<code>以及</code>truncate(-2.7335) &#x3D; -2</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: dividend = 10, divisor = 3</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: dividend = 7, divisor = <span class="hljs-string">-3</span><br>输出: <span class="hljs-string">-2</span><br>解释: 7/<span class="hljs-string">-3</span> = truncate(<span class="hljs-string">-2</span>.33333..) = <span class="hljs-string">-2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是[−231,231−1]。本题中，如果除法结果溢出，则返回231−1。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DivideTwoIntegers</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 越界后，只能返回-2147483648</span><br>        System.out.println(-(-<span class="hljs-number">2147483648</span>));<br>        System.out.println((-<span class="hljs-number">2147483648</span> - <span class="hljs-number">1</span>));<br><br>        System.out.println(<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            numLen++;<br>            num = num &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numLen;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getBit</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> pos)</span> &#123;<span class="hljs-comment">//获取从右到左的第pos位置的值1/0</span><br>        pos = pos - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; pos;<br>        <span class="hljs-keyword">if</span> ((num &amp; index) &gt;&gt; pos != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> &#123;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">minus</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 被除数是否是最大值</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">minValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> (dividend &lt; <span class="hljs-number">0</span> || divisor &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>) &#123;<br>                dividend = -dividend;<br>                divisor = -divisor;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dividend = dividend &lt; <span class="hljs-number">0</span> ? -dividend : dividend;<br>                divisor = divisor &lt; <span class="hljs-number">0</span> ? -divisor : divisor;<br>                minus = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (dividend == -<span class="hljs-number">2147483648</span>) &#123;<br>                minValue = <span class="hljs-literal">true</span>;<br>                dividend = dividend - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (divisor == -<span class="hljs-number">2147483648</span>) &#123;<br>                <span class="hljs-comment">// 被除数与除数相同</span><br>                <span class="hljs-keyword">if</span> (minValue)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 任何数除以最大值都是0，不区分符号了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dividend &lt; divisor)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (minus) &#123;<br>                <span class="hljs-comment">// 被除数为最大值</span><br>                <span class="hljs-keyword">if</span> (minValue)<br>                    <span class="hljs-keyword">return</span> -dividend - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> -dividend;<br>            &#125; <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> dividend;<br>        &#125;<br><br>        <span class="hljs-comment">// 二进制数头部可以除的数，每次用减法代替除，然后留下余数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">divide</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 目前除法或者说减法得到的结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getBits(dividend);<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从头部用二进制减去除数，余数留下来</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> getBit(dividend, index--);<br>            divide = (divide &lt;&lt; <span class="hljs-number">1</span>) + val;<br><br>            <span class="hljs-keyword">if</span> (divide &lt; divisor)<br>                res = res &lt;&lt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res = (res &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                divide = divide - divisor;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// -2147483648 2  因为最大数，转成正数后，少了1，所以如果余数加1能够被整除，当然加1</span><br>        <span class="hljs-keyword">if</span> (minValue &amp;&amp; (divide + <span class="hljs-number">1</span>) &gt;= divisor) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minus) &#123;<br>            <span class="hljs-keyword">return</span> -res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">-<span class="hljs-number">2147483648</span><br><span class="hljs-number">2147483647</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题没做出来。主要考察了怎么用减法代替除法，这个倒好理解。主要是最大最小值，这个边界问题，困扰一很久。</p><p>根据文档：</p><p>int数据类型是32位带符号的二进制补码整数。最小值为-2,147,483,648(0x80000000)，最大值为2,147,483,647(0x7FFFFFFF)(含)。</p><p>因此，当您将1加到整数的最大值时：</p><p>0x7FFFFFFF + 0x00000001 &#x3D; 0x80000000(-2,147,483,648)</p><p>也就是所谓的最大+1等于最小，最小-1等于最大。最小乘以-1还是最小，因为越界了，刚好是最大+1。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ImplementStrstr</title>
    <link href="/2021/01/31/ImplementStrstr/"/>
    <url>/2021/01/31/ImplementStrstr/</url>
    
    <content type="html"><![CDATA[<h2 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/31/ImplementStrstr/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/31/ImplementStrstr/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></p><p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;ll&quot;</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;aaaaa&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;bba&quot;</span><br>输出: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImplementStrstr</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(<span class="hljs-type">String</span> haystack, <span class="hljs-type">String</span> needle)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (needle == null || needle.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> hayLength = haystack.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> needleLength = needle.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= hayLength - needleLength; i++) &#123;<br>            <span class="hljs-keyword">if</span> (haystack.<span class="hljs-built_in">substring</span>(i, i + needleLength).<span class="hljs-built_in">equals</span>(needle)) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span> haystack = <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> needle = <span class="hljs-string">&quot;ll&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">strStr</span>(haystack, needle));<br><br>        haystack = <span class="hljs-string">&quot;aaaaa&quot;</span>;<br>        needle = <span class="hljs-string">&quot;bba&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">strStr</span>(haystack, needle));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">2<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是依次匹配。但是这里有个问题，我第一次用char挨个匹配，但是超时了；改用substring才能不超时。其二，官方的第二种算法，我也想到过，这里就不展示了，不过效率确实很好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedArray</title>
    <link href="/2021/01/29/RemoveDuplicatesFromSortedArray/"/>
    <url>/2021/01/29/RemoveDuplicatesFromSortedArray/</url>
    
    <content type="html"><![CDATA[<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/29/RemoveDuplicatesFromSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/29/RemoveDuplicatesFromSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></p><p>给定一个排序数组，你需要在**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">给定数组 nums </span>=<span class="hljs-string"> [1,1,2], </span><br><span class="hljs-string"></span><br><span class="hljs-string">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="hljs-string"></span><br><span class="hljs-string">你不需要考虑数组中超出新长度后面的元素。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">给定 nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,2,2,3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br><br>函数应该返回新的长度 <span class="hljs-number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>。<br><br>你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>为什么返回数值是整数，但输出的答案是数组呢?</li><li>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</li></ul><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    <span class="hljs-built_in">print</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> RemoveDuplicatesFromSortedArray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> removeDuplicates(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>        <span class="hljs-type">int</span> last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            start = i;<br>            <span class="hljs-keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                i++;<br>            &#125;<br>            last = i;<br>            <span class="hljs-keyword">if</span> (start == last) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            copyNums(nums, <span class="hljs-keyword">start</span>, last);<br>            i = <span class="hljs-keyword">start</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>            i++;<br>            length++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> copyNums(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> last) &#123;<br>        <span class="hljs-type">int</span> space = last - <span class="hljs-keyword">start</span>;<br>        <span class="hljs-keyword">for</span> (; <span class="hljs-keyword">start</span> &lt; nums.length - space; <span class="hljs-keyword">start</span>++, last++) &#123;<br>            nums[<span class="hljs-keyword">start</span>] = nums[last];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        print(nums, removeDuplicates(nums));<br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>        print(nums, removeDuplicates(nums));<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> length) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">12<br>01234<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单了，不过官方的双指针很优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ReverseNodesInKGroup</title>
    <link href="/2021/01/28/ReverseNodesInKGroup/"/>
    <url>/2021/01/28/ReverseNodesInKGroup/</url>
    
    <content type="html"><![CDATA[<h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/28/ReverseNodesInKGroup/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/28/ReverseNodesInKGroup/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></p><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。<em>k</em> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">给你这个链表：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br><br>当 k = <span class="hljs-number">2</span> 时，应当返回: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span><br><br>当 k = <span class="hljs-number">3</span> 时，应当返回: <span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseNodesInKGroup</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || k &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (length &lt; k &amp;&amp; cur != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            prev = cur;<br>            cur = cur.next;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span> (length &lt; k)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        prev.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> reverse(head, k);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> reverseKGroup(cur, k);<br>        left.next = right;<br><span class="hljs-comment">// prev此时是头结点</span><br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            prev = prev.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length &lt; k)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 两两翻转</span><br>        prev = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n1.next = n2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n2.next = n3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n3.next = n4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n4.next = n5;<br>        print(reverseKGroup(n1, <span class="hljs-number">3</span>));<br><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n1.next = n2;<br>        n3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n2.next = n3;<br>        n4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n3.next = n4;<br>        n5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n4.next = n5;<br>        print(reverseKGroup(n1, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(head.val);<br>            head = head.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">32145<br>21435<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题解法很简单，先分段反转，然后通过递归拼接。难点在于链表的指针，一不小心就指错了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SwapNodesInPairs</title>
    <link href="/2021/01/27/SwapNodesInPairs/"/>
    <url>/2021/01/27/SwapNodesInPairs/</url>
    
    <content type="html"><![CDATA[<h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/27/SwapNodesInPairs/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/27/SwapNodesInPairs/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwapNodesInPairs</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode swapPairs(ListNode head) &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode left = head;<br>        ListNode right = head.<span class="hljs-keyword">next</span>;<br>        ListNode <span class="hljs-keyword">next</span> = right.<span class="hljs-keyword">next</span>;<br>        ListNode prev = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-built_in">int</span> headIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 交换左右位置</span><br>            left.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>            right.<span class="hljs-keyword">next</span> = left;<br><br>            <span class="hljs-comment">// 保证链表不断</span><br>            prev.<span class="hljs-keyword">next</span> = right;<br>            prev = left;<br>            <span class="hljs-keyword">if</span> (headIndex == <span class="hljs-number">0</span>) &#123;<br>                head = right;<br>                headIndex ++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>                left = <span class="hljs-keyword">next</span>;<br>                right = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">next</span> = right.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        ListNode n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode n2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        n1.<span class="hljs-keyword">next</span> = n2;<br>        ListNode n3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        n2.<span class="hljs-keyword">next</span> = n3;<br>        ListNode n4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        n3.<span class="hljs-keyword">next</span> = n4;<br>        <span class="hljs-keyword">print</span>(swapPairs(n1));<br><br>        ListNode n5 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(swapPairs(n5));<br><br>        ListNode n6 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">print</span>(swapPairs(n6));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2143</span><br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题居然没有想到可以递归，递归的代码少到可怜；然后自己写出来的是迭代，当然和官方答案比，代码量还是稍显多。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeKSortedLists</title>
    <link href="/2021/01/26/MergeKSortedLists/"/>
    <url>/2021/01/26/MergeKSortedLists/</url>
    
    <content type="html"><![CDATA[<h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/26/MergeKSortedLists/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/26/MergeKSortedLists/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p>这里：元素为[]在java就是null，列表为空就是数组大小为空。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeKSortedLists</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode mergeKLists(ListNode[] lists) &#123;<br><br>        <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        ListNode head = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);<br>        ListNode cur = head;<br>        ListNode prev = cur;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (lists[i] == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">count</span> ++;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == lists.length &amp;&amp; <span class="hljs-keyword">index</span> &gt; <span class="hljs-number">-1</span>) &#123;<br>                        prev.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">return</span> head;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == lists.length) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (lists[i] != <span class="hljs-literal">null</span> &amp;&amp; lists[i].val &lt;= cur.val) &#123;<br>                    cur.val = lists[i].val;<br>                    <span class="hljs-keyword">index</span> = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lists[<span class="hljs-keyword">index</span>] != <span class="hljs-literal">null</span>) &#123;<br>                lists[<span class="hljs-keyword">index</span>] = lists[<span class="hljs-keyword">index</span>].<span class="hljs-keyword">next</span>;<br>            &#125;<br><br>            cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);<br>            prev = cur;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-comment">// lists = [[1,4,5],[1,3,4],[2,6]]</span><br>        ListNode a1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode a2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        a1.<span class="hljs-keyword">next</span> = a2;<br>        ListNode a3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        a2.<span class="hljs-keyword">next</span> = a3;<br><br>        ListNode a4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode a5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        a4.<span class="hljs-keyword">next</span> = a5;<br>        ListNode a6 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        a5.<span class="hljs-keyword">next</span> = a6;<br><br>        ListNode a7 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        ListNode a8 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">6</span>);<br>        a7.<span class="hljs-keyword">next</span> = a8;<br><br>        ListNode[] lists = <span class="hljs-keyword">new</span> ListNode[]&#123;a1, a4, a7&#125;;<br>        <span class="hljs-keyword">print</span>(mergeKLists(lists));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode node) &#123;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(node.val);<br>            node = node.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">11234456</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题依然想出了三种思路，大致对应了官方的三种思路。第一种：一个一个合并，直到结束；第二种思路，就是两两归并，没想到效率这么高，所以计算复杂度是需要考虑到的；第三种，也是自己给出的结果，效率不是很理想，参考了官方答案，没想到用了PriorityQueue，利用优先队列本身的排序机制（小顶堆），非常巧妙。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GenerateParentheses</title>
    <link href="/2021/01/25/GenerateParentheses/"/>
    <url>/2021/01/25/GenerateParentheses/</url>
    
    <content type="html"><![CDATA[<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/25/GenerateParentheses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/25/GenerateParentheses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java<span class="hljs-variable">.util</span><span class="hljs-variable">.ArrayList</span>;<br><span class="hljs-keyword">import</span> java<span class="hljs-variable">.util</span><span class="hljs-variable">.List</span>;<br><br>public <span class="hljs-keyword">class</span> GenerateParentheses &#123;<br><br>    <span class="hljs-comment">// n&lt;=8，所以最多也就64，因为开头结尾必须()</span><br>    <span class="hljs-keyword">static</span> ArrayList[] cache = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">100</span>];<br><br>    public <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-keyword">generate</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span> (cache[n] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cache[n];<br>        &#125;<br>        ArrayList&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 长度为0当然是空</span><br>            ans<span class="hljs-variable">.add</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// c表示几对，因为已经有了默认的一对，所以小于n</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; ++c) &#123;<br>                <span class="hljs-keyword">for</span> (String left : <span class="hljs-keyword">generate</span>(c)) &#123;<br>                    <span class="hljs-comment">// 最大也就n-1，因为已经有了默认的一对</span><br>                    <span class="hljs-keyword">for</span> (String right: <span class="hljs-keyword">generate</span>(n - <span class="hljs-number">1</span> - c)) &#123;<br>                        <span class="hljs-comment">// 一对默认的，和左边的一对，右边的一对</span><br>                        ans<span class="hljs-variable">.add</span>(<span class="hljs-string">&quot;(&quot;</span> + left + <span class="hljs-string">&quot;)&quot;</span> + right);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cache[n] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> List&lt;String&gt; generateParenthesis(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">generate</span>(n);<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        System<span class="hljs-variable">.out</span><span class="hljs-variable">.println</span>(<span class="hljs-keyword">generate</span>(<span class="hljs-number">3</span>));<br><br>        System<span class="hljs-variable">.out</span><span class="hljs-variable">.println</span>(<span class="hljs-keyword">generate</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[()()(), ()(()), (())(), (()()), ((()))]<br>[()]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>本来以为是很难的，官方的三种思路都想过，自己算了下复杂度，感觉不对，没想到三种都想到了。也就是，一个生成，一个校验，这是第一种；校验的过程再给个优化，括号数量配对，这是第二种；开头结尾必须是()这两个，这是第三种，然后通过拼接分割右括号的左右字符串完成。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeTwoSortedLists</title>
    <link href="/2021/01/24/MergeTwoSortedLists/"/>
    <url>/2021/01/24/MergeTwoSortedLists/</url>
    
    <content type="html"><![CDATA[<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/24/MergeTwoSortedLists/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/24/MergeTwoSortedLists/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/merge_ex1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeTwoSortedLists</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        ListNode head;<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            head = l1;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = l2;<br>            l2 = l2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                cur.<span class="hljs-keyword">next</span> = l1;<br>                cur = cur.<span class="hljs-keyword">next</span>;<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.<span class="hljs-keyword">next</span> = l2;<br>                cur = cur.<span class="hljs-keyword">next</span>;<br>                l2 = l2.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            cur.<span class="hljs-keyword">next</span> = l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            cur.<span class="hljs-keyword">next</span> = l1;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        ListNode node1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        node1.<span class="hljs-keyword">next</span> = node2;<br>        ListNode node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        node2.<span class="hljs-keyword">next</span> = node3;<br><br>        ListNode node4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode node5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        node4.<span class="hljs-keyword">next</span> = node5;<br>        ListNode node6 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        node5.<span class="hljs-keyword">next</span> = node6;<br><br>        <span class="hljs-keyword">print</span>(mergeTwoLists(node1, node4));<br><br>        node1 = <span class="hljs-literal">null</span>;<br>        node2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(mergeTwoLists(node1, node2));<br><br>        node1 = <span class="hljs-literal">null</span>;<br>        node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        node2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(mergeTwoLists(node1, node2));<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode node) &#123;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(node.val);<br>            node = node.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">112344<br><br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就是比较大小，顺序延展下去。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidParentheses</title>
    <link href="/2021/01/24/ValidParentheses/"/>
    <url>/2021/01/24/ValidParentheses/</url>
    
    <content type="html"><![CDATA[<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/24/ValidParentheses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/24/ValidParentheses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;(]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;([)]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidParentheses</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() &lt; <span class="hljs-number">2</span> || s.<span class="hljs-built_in">length</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;Character, Character&gt;()&#123;&#123;<br>            <span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>            <span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            <span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>        &#125;&#125;;<br><br>        <span class="hljs-type">char</span>[] chars = s.<span class="hljs-built_in">toCharArray</span>();<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> aChar : chars) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">get</span>(aChar) != null &amp;&amp; deque.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">1</span> &amp;&amp; deque.<span class="hljs-built_in">getLast</span>() == map.<span class="hljs-built_in">get</span>(aChar)) &#123;<br>                deque.<span class="hljs-built_in">pollLast</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                deque.<span class="hljs-built_in">add</span>(aChar);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-type">String</span> s = <span class="hljs-string">&quot;()&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br><br>        s = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br><br>        s = <span class="hljs-string">&quot;(]&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br><br>        s = <span class="hljs-string">&quot;)&#123;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就是栈。不过java的栈最好不要用stack类，用queue的实现比较好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveNthNodeFromEndOfList</title>
    <link href="/2021/01/23/RemoveNthNodeFromEndOfList/"/>
    <url>/2021/01/23/RemoveNthNodeFromEndOfList/</url>
    
    <content type="html"><![CDATA[<h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/23/RemoveNthNodeFromEndOfList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/23/RemoveNthNodeFromEndOfList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/remove_ex1.jpg" alt="1"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br>import java.util.HashMap;<br>import java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveNthNodeFromEndOfList</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br><br>        Map&lt;Integer, ListNode&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            map.put(<span class="hljs-keyword">index</span>, cur);<br>            <span class="hljs-keyword">index</span>++;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> addr = map.size() - n;<br>        <span class="hljs-keyword">if</span> (addr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> map.get(addr).<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ListNode prev = map.get(addr - <span class="hljs-number">1</span>);<br>            cur = map.get(addr);<br>            prev.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">return</span> map.get(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        ListNode h1 = <span class="hljs-keyword">new</span> ListNode();<br>        h1.val = <span class="hljs-number">1</span>;<br><br>        ListNode h2 = <span class="hljs-keyword">new</span> ListNode();<br>        h2.val = <span class="hljs-number">2</span>;<br>        h1.<span class="hljs-keyword">next</span> = h2;<br><br>        ListNode h3 = <span class="hljs-keyword">new</span> ListNode();<br>        h3.val = <span class="hljs-number">3</span>;<br>        h2.<span class="hljs-keyword">next</span> = h3;<br><br>        ListNode h4 = <span class="hljs-keyword">new</span> ListNode();<br>        h4.val = <span class="hljs-number">4</span>;<br>        h3.<span class="hljs-keyword">next</span> = h4;<br><br>        ListNode h5 = <span class="hljs-keyword">new</span> ListNode();<br>        h5.val = <span class="hljs-number">5</span>;<br>        h4.<span class="hljs-keyword">next</span> = h5;<br>        <span class="hljs-keyword">print</span>(removeNthFromEnd1(h1, <span class="hljs-number">2</span>));<br><br>        h1.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(removeNthFromEnd1(h1, <span class="hljs-number">1</span>));<br><br>        h1.<span class="hljs-keyword">next</span> = h2;<br>        h2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(removeNthFromEnd1(h1, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-built_in">int</span> val;<br>    ListNode <span class="hljs-keyword">next</span>;<br><br>    ListNode() &#123;<br>    &#125;<br><br>    ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br><br>    ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1235</span><br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是用存储获取位置。然后发现提交的效率不高，参考了官方的解题思路，又写了一版，这道题应该是不难的。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode removeNthFromEnd1(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        ListNode first = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        ListNode second = first;<br>        ListNode lamd = first;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (first.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">count</span>++;<br>            first = first.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> &gt; n) &#123;<br><span class="hljs-comment">//                1 2 3 4 5</span><br>                second = second.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        second.<span class="hljs-keyword">next</span> = second.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>       <span class="hljs-keyword">return</span> lamd.<span class="hljs-keyword">next</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是两个指针，一个提前n个位置去右移。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FourSum</title>
    <link href="/2021/01/22/FourSum/"/>
    <url>/2021/01/22/FourSum/</url>
    
    <content type="html"><![CDATA[<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/22/FourSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/22/FourSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[1, 0, -1, 0, -2, 2]</span>，和 target = 0。<br><br>满足要求的四元组集合为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1,  0, 0, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-2, -1, 1, 2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-2,  0, 0, 2]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FourSum</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists;<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[length - <span class="hljs-number">3</span>] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                        List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[j], nums[left], nums[right]);<br>                        lists.add(list);<br>                        <span class="hljs-comment">// 这一段优化很精妙</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                            left++;<br>                        &#125;<br>                        left++;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                            right--;<br>                        &#125;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        left++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        System.out.println(fourSum(nums, target));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[[<span class="hljs-string">-3</span>, <span class="hljs-string">-2</span>, 2, 3], [<span class="hljs-string">-3</span>, <span class="hljs-string">-1</span>, 1, 3], [<span class="hljs-string">-3</span>, 0, 0, 3], [<span class="hljs-string">-3</span>, 0, 1, 2], [<span class="hljs-string">-2</span>, <span class="hljs-string">-1</span>, 0, 3], [<span class="hljs-string">-2</span>, <span class="hljs-string">-1</span>, 1, 2], [<span class="hljs-string">-2</span>, 0, 0, 2], [<span class="hljs-string">-1</span>, 0, 0, 1]]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针。其实做出来后，虽然pass了，但是发现效率比较低。所以还是参考了官方的解答，最后一层循环的优化，确实比较厉害。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LetterCombinationsOfAPhoneNumber</title>
    <link href="/2021/01/22/LetterCombinationsOfAPhoneNumber/"/>
    <url>/2021/01/22/LetterCombinationsOfAPhoneNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/22/LetterCombinationsOfAPhoneNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/22/LetterCombinationsOfAPhoneNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/17_telephone_keypad.png" alt="17"></p><p><strong>示例 :</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>, <span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-string">&quot;af&quot;</span>, <span class="hljs-string">&quot;bd&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;bf&quot;</span>, <span class="hljs-string">&quot;cd&quot;</span>, <span class="hljs-string">&quot;ce&quot;</span>, <span class="hljs-string">&quot;cf&quot;</span>].<br></code></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LetterCombinationsOfAPhoneNumber</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; combinations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> combinations;<br>        &#125;<br>        backtrack(combinations, phoneMap, digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>());<br>        <span class="hljs-keyword">return</span> combinations;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>        put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>        put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>        put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>        put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>        put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>        put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap,</span><br><span class="hljs-params">                          String digits, <span class="hljs-type">int</span> index, StringBuffer combination)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            <span class="hljs-comment">// 已经到最后了，不需要递归</span><br>            combinations.add(combination.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> digits.charAt(index);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> phoneMap.get(first);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; letters.length(); i++) &#123;<br>                combination.append(letters.charAt(i));<br>                backtrack(combinations, phoneMap, digits, index + <span class="hljs-number">1</span>, combination);<br>                <span class="hljs-comment">// 上一步的拼装如果成功，for循环进行下一轮，需要删除这一层追加的同等级字母</span><br>                combination.deleteCharAt(index);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">digits</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;23&quot;</span>;<br>        System.out.println(letterCombinations(digits));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">[ad, ae, af, <span class="hljs-keyword">bd</span>, <span class="hljs-keyword">be</span>, <span class="hljs-keyword">bf</span>, <span class="hljs-keyword">cd</span>, <span class="hljs-keyword">ce</span>, <span class="hljs-keyword">cf</span>]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>递归。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreeSumClosest</title>
    <link href="/2021/01/21/ThreeSumClosest/"/>
    <url>/2021/01/21/ThreeSumClosest/</url>
    
    <content type="html"><![CDATA[<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/21/ThreeSumClosest/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/21/ThreeSumClosest/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例 :</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-4</span>], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (<span class="hljs-string">-1</span> + 2 + 1 = 2) 。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ThreeSumClosest &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> threeSumClosest(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> min = <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> k = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> == target) &#123;<br>                    <span class="hljs-keyword">return</span> target;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (Math.abs(<span class="hljs-keyword">temp</span> - target) &lt; Math.abs(min - target)) &#123;<br>                    min = <span class="hljs-keyword">temp</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> &gt; target) &#123;<br>                    <span class="hljs-type">int</span> k1 = k - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> (k1 &gt; j &amp;&amp; nums[k] == nums[k1]) &#123;<br>                        k1<span class="hljs-comment">--;</span><br>                    &#125;<br>                    k = k1;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> j1 = j + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> (j1 &lt; k &amp;&amp; nums[j] == nums[j1]) &#123;<br>                        j1++;<br>                    &#125;<br>                    j = j1;<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-4</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSumClosest(nums, target));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针思想。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreeSum</title>
    <link href="/2021/01/20/ThreeSum/"/>
    <url>/2021/01/20/ThreeSum/</url>
    
    <content type="html"><![CDATA[<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/20/ThreeSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/20/ThreeSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></p><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素<em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ThreeSum &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; threeSum(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                break;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> k = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; target) &#123;<br>                    break;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                // 缩小范围<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] + nums[j] &gt; target) &#123;<br>                    k<span class="hljs-comment">--;</span><br>                &#125;<br>                // 缩小范围<br>                <span class="hljs-keyword">if</span> (j == k) &#123;<br>                    break;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[k] + nums[j] == target) &#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; unit = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>                    unit.<span class="hljs-keyword">add</span>(nums[i]);<br>                    unit.<span class="hljs-keyword">add</span>(nums[j]);<br>                    unit.<span class="hljs-keyword">add</span>(nums[k]);<br>                    result.<span class="hljs-keyword">add</span>(unit);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main (String[]args)&#123;<br><br>            <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>&#125;;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSum(nums));<br><br>            nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSum(nums));<br><br>            nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSum(nums));<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[-1, -1, 2]</span>, <span class="hljs-comment">[-1, 0, 1]</span>]</span><br><span class="hljs-comment">[]</span><br><span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestCommonPrefix</title>
    <link href="/2021/01/19/LongestCommonPrefix/"/>
    <url>/2021/01/19/LongestCommonPrefix/</url>
    
    <content type="html"><![CDATA[<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/19/LongestCommonPrefix/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/19/LongestCommonPrefix/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestCommonPrefix</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(<span class="hljs-type">String</span>[] strs)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        StringBuilder s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-type">String</span> str = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">char</span> a = str.<span class="hljs-built_in">charAt</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= strs[j].<span class="hljs-built_in">length</span>() || a != strs[j].<span class="hljs-built_in">charAt</span>(i)) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            s.<span class="hljs-built_in">append</span>(a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span>[] strs = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[]&#123;<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestCommonPrefix</span>(strs));<br><br>        strs = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[]&#123;<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestCommonPrefix</span>(strs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fl</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就不说了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IntegerToRoman</title>
    <link href="/2021/01/12/IntegerToRoman/"/>
    <url>/2021/01/12/IntegerToRoman/</url>
    
    <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/12/RomanToInteger/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/12/RomanToInteger/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">字符          数值<br><span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><br><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><br><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><br><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><br><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><br><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><br><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: III</span><br><span class="hljs-section">输出: &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: IV</span><br><span class="hljs-section">输出: &quot;4&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: IX</span><br><span class="hljs-section">输出: &quot;9&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: LVIII</span><br><span class="hljs-section">输出: &quot;58&quot;</span><br><span class="hljs-section">解释: L = 50, V = 5, III = 3.</span><br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: MCMXCIV</span><br><span class="hljs-section">输出: &quot;1994&quot;</span><br><span class="hljs-section">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs sas">package algorithm;<br><br>import java.util.HashMap;<br>import java.util.Map;<br><br>public class RomanToInteger &#123;<br><br>    public static Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;()&#123;&#123;<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;I&#x27;</span>, 1);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;V&#x27;</span>, 5);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;X&#x27;</span>, 10);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;L&#x27;</span>, 50);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;C&#x27;</span>, 100);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;D&#x27;</span>, 500);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;M&#x27;</span>, 1000);<br>    &#125;&#125;;<br><br>    public static int romanTo<span class="hljs-meta">Int</span>(String s) &#123;<br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-meta">length</span>() &lt;= 1) &#123;<br>            <span class="hljs-keyword">return</span> map.get(s.charAt(0));<br>        &#125;<br><br>        int result = 0;<br>        for (int i = 0; i &lt; s.<span class="hljs-meta">length</span>() - 1; i++) &#123;<br>            int first = map.get(s.charAt(i));<br>            int next = map.get(s.charAt(i + 1));<br><br>            <span class="hljs-keyword">if</span> (first &lt; next) &#123;<br>                first <span class="hljs-comment">*= -1;</span><br>            &#125;<br>            result += first;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result + map.get(s.charAt(s.<span class="hljs-meta">length</span>() - 1));<br>    &#125;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br><br>        String s;<br><br>        s = <span class="hljs-string">&quot;III&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;IV&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;IX&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;LVIII&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;MCMXCIV&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">9</span><br><span class="hljs-number">58</span><br><span class="hljs-number">1994</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就不说了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis 如何存储上亿级别的用户状态？</title>
    <link href="/2021/01/11/Redis%20%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%8A%E4%BA%BF%E7%BA%A7%E5%88%AB%E7%9A%84%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%EF%BC%9F/"/>
    <url>/2021/01/11/Redis%20%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%8A%E4%BA%BF%E7%BA%A7%E5%88%AB%E7%9A%84%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-如何存储上亿级别的用户状态？"><a href="#Redis-如何存储上亿级别的用户状态？" class="headerlink" title="Redis 如何存储上亿级别的用户状态？"></a>Redis 如何存储上亿级别的用户状态？</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自[这篇博客](<a href="https://yangtzeshore.github.io/2021/01/11/Redis">https://yangtzeshore.github.io/2021/01/11/Redis</a> 如何存储上亿级别的用户状态&#x2F;<a href="http://www.jianshu.com/p/ee79ae681b74)%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%95%B4%E7%90%86%E5%92%8C%E6%94%B6%E5%BD%95%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%90%8E%E7%BB%AD%E6%9F%A5%E9%98%85%E3%80%82">www.jianshu.com/p/ee79ae681b74)，作为整理和收录，方便后续查阅。</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr><p>前段时间，在网上看到一道面试题：</p><p><strong>如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量。</strong></p><p>觉得很有意思，就仔细想了下 。并做了一系列实验，自己模拟了下 。还是有点收获的，现整理下来。和大家一起分享。</p><p>Redis是一个内存数据库，采用单线程和事件驱动的机制来处理网络请求。实际生产的QPS和TPS单台都能达到3,4W，读写性能非常棒。用来存储一些对核心业务弱影响的用户状态信息还是非常不错的。</p><p><strong>对于这题，有2个重要的点需要考虑：</strong></p><p>1.如何用合适的数据类型来存储1亿用户的数据，用普通的字符串来存储肯定不行。经过查看一个最简单的kv(key为aaa，value为1)的内存占用，发现为48byte。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi1.png" alt="图片"></p><p>假设每个用户每天登陆需要占据1对KV的话，那一亿就是(48*100000000)&#x2F;1024&#x2F;1024&#x2F;1024&#x3D;4.47G。这还是一天的量。</p><p>2.如何满足搜索，redis是一个键值对的内存结构，只能根据key来进行定位value值，无法做到像elastic search那样对文档进行倒排索引快速全文检索。</p><p>redis其实有这种数据结构的，可以以很少的空间来存储大量的信息。</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><hr><p>在redis 2.2.0版本之后，新增了一个位图数据，其实它不是一种数据结构。实际上它就是一个一个字符串结构，只不过value是一个二进制数据，每一位只能是0或者1。</p><p>redis单独对bitmap提供了一套命令。可以对任意一位进行设置和读取。</p><p>bitmap的核心命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SETBIT</span><br></code></pre></td></tr></table></figure><blockquote><p>语法：SETBIT key offset value</p><p>例如：</p><p>setbit abc 5 1 ——&gt; 00001</p><p>setbit abc 2 1 ——&gt; 00101</p></blockquote><p>GETBIT</p><blockquote><p>语法：GETBIT key offset</p><p>例如：</p><p>getbit abc 5 ——&gt; 1</p><p>getbit abc 1 ——&gt; 0</p></blockquote><p>bitmap的其他命令还有bitcount，bitcount，bitpos，bitop等命令。都是对位的操作。</p><p>因为bitmap的每一位只占据1bit的空间 ，所以利用这个特性我们可以把每一天作为key，value为1亿用户的活跃度状态。假设一个用户一天内只要登录了一次就算活跃。活跃我们就记为1，不活跃我们就记为0。把用户Id作为偏移量(offset)。这样我们一个key就可以存储1亿用户的活跃状态。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi2.png" alt="图片"></p><p>我们再来算下，这样一个位图结构的值对象占据多少空间。每一个位是1bit，一亿用户就是一亿bit。8bit&#x3D;1Byte</p><p>100000000&#x2F;8&#x2F;1024&#x2F;1024&#x3D;11.92M</p><p>我用测试工程往一个key里通过lua塞进了1亿个bit，然后用rdb tools对内存进行统计，实测如下：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi3.png" alt="图片"></p><p>一天1亿用户也就消耗12M的内存空间。这完全符合要求。1年的话也就4个G。几年下来的话，redis可以集群部署来进行扩容存储。我们也可以用位图压缩算法对bitmap进行压缩存储。例如WAH，EWAH，Roaring Bitmaps。这个以后可以单独拉出来聊聊。</p><p>我们把每一天1亿用户的登陆状态都用bitmap的形式存进了redis，那要获取某一天id为88000的用户是否活跃，直接使用<code>getbit</code>命令：</p><blockquote><p>getbit 2020-01-01 88000 [时间复杂度为O(1)]</p></blockquote><p>如果要统计某一天的所有的活跃用户数，使用<code>bitcount</code>命令，bitcount可以统计1的个数，也就是活跃用户数：</p><blockquote><p>bitcount 2019-01-01 [时间复杂度为O(N)]</p></blockquote><p>如果要统计某一段时间内的活跃用户数，需要用到bitop命令。这个命令提供四种位运算，<code>AND(与)</code>，<code>(OR)或</code>，<code>XOR(亦或)</code>，<code>NOT(非)</code>。我们可以对某一段时间内的所有key进行<code>OR(或)</code>操作，或操作出来的位图是0的就代表这段时间内一次都没有登陆的用户。那只要我们求出1的个数就可以了。以下例子求出了2019-01-01到2019-01-05这段时间内的活跃用户数。</p><blockquote><p>bitop or result 2019-01-01 2019-01-02 2019-01-03 2019-01-04 2019-01-05 [时间复杂度为O(N)]</p><p>bitcount result</p></blockquote><p>从时间复杂度上说，无论是统计某一天，还是统计一段时间。在实际测试时，基本上都是秒出的。符合我们的预期。</p><h3 id="bitmap使用场景"><a href="#bitmap使用场景" class="headerlink" title="bitmap使用场景"></a>bitmap使用场景</h3><hr><p>bitmap可以很好的满足一些需要记录大量而简单信息的场景。所占空间十分小。通常来说使用场景分2类：</p><p>1.某一业务对象的横向扩展，key为某一个业务对象的id，比如记录某一个终端的功能开关，1代表开，0代表关。基本可以无限扩展，可以记录2^32个位信息。不过这种用法由于key上带有了业务对象的id，导致了key的存储空间大于了value的存储空间，从空间使用角度上来看有一定的优化空间。</p><p>2.某一业务的纵向扩展，key为某一个业务，把每一个业务对象的id作为偏移量记录到位上。这道面试题的例子就是用此法来进行解决。十分巧妙的利用了用户的id作为偏移量来找到相对应的值。当业务对象数量超过2^32时（约等于42亿），还可以分片存储。</p><p>看起来bitmap完美的解决了存储和统计的问题。那有没有比这个更加省空间的存储吗？</p><p>答案是有的。</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><hr><p>redis从2.8.9之后增加了HyperLogLog数据结构。这个数据结构，根据redis的官网介绍，这是一个概率数据结构，用来估算数据的基数。能通过牺牲准确率来减少内存空间的消耗。</p><p>我们先来看看HyperLogLog的方法</p><blockquote><p>PFADD 添加一个元素，如果重复，只算作一个</p><p>PFCOUNT 返回元素数量的近似值</p><p>PFMERGE 将多个 HyperLogLog 合并为一个 HyperLogLog</p></blockquote><p>这很好理解，是不是。那我们就来看看同样是存储一亿用户的活跃度，HyperLogLog数据结构需要多少空间。是不是比bitmap更加省空间呢。</p><p>我通过测试工程往HyperLogLog里PFADD了一亿个元素。通过rdb tools工具统计了这个key的信息：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi4.png" alt="图片"></p><p>只需要14392 Bytes！也就是14KB的空间。对，你没看错。就是14K。bitmap存储一亿需要12M，而HyperLogLog只需要14K的空间。</p><p>这是一个很惊人的结果。我似乎有点不敢相信使用如此小的空间竟能存储如此大的数据量。</p><p>接下来我又放了1000w数据，统计出来还是14k。也就是说，无论你放多少数据进去，都是14K。</p><p>查了文档，发现HyperLogLog是一种概率性数据结构，在标准误差0.81%的前提下，能够统计2^64个数据。所以 HyperLogLog 适合在比如统计日活月活此类的对精度要不不高的场景。</p><p>HyperLogLog使用概率算法来统计集合的近似基数。而它算法的最本源则是伯努利过程。</p><p>伯努利过程就是一个抛硬币实验的过程。抛一枚正常硬币，落地可能是正面，也可能是反面，二者的概率都是 1&#x2F;2 。伯努利过程就是一直抛硬币，直到落地时出现正面位置，并记录下抛掷次数k。比如说，抛一次硬币就出现正面了，此时 k 为 1; 第一次抛硬币是反面，则继续抛，直到第三次才出现正面，此时 k 为 3。</p><p>对于 n 次伯努利过程，我们会得到 n 个出现正面的投掷次数值 k1, k2 … kn , 其中这里的最大值是k_max。</p><p>根据一顿数学推导，我们可以得出一个结论：2^{k_ max} 来作为n的估计值。也就是说你可以根据最大投掷次数近似的推算出进行了几次伯努利过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>虽然HyperLogLog数据类型这么牛逼，但终究不是精确统计。只适用于对精度要求不高的场景。而且这种类型无法得出每个用户的活跃度信息。毕竟只有14K嘛。也不可能存储下那么多数量的信息。</p><p>总结一下：对于文章开头所提到的面试题来说，用bitmap和HyperLogLog都可以解决。</p><p>bitmap的优势是：非常均衡的特性，精准统计，可以得到每个统计对象的状态，秒出。缺点是：当你的统计对象数量十分十分巨大时，可能会占用到一点存储空间，但也可在接受范围内。也可以通过分片，或者压缩的额外手段去解决。</p><p>HyperLogLog的优势是：可以统计夸张到无法想象的数量，并且占用小的夸张的内存。缺点是：建立在牺牲准确率的基础上，而且无法得到每个统计对象的状态。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[1. Redis 如何存储上亿级别的用户状态？](<a href="https://yangtzeshore.github.io/2021/01/11/Redis">https://yangtzeshore.github.io/2021/01/11/Redis</a> 如何存储上亿级别的用户状态&#x2F;<a href="http://www.jianshu.com/p/ee79ae681b74">www.jianshu.com/p/ee79ae681b74</a>)</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单点登录的三种实现方式</title>
    <link href="/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单点登录的三种实现方式"><a href="#单点登录的三种实现方式" class="headerlink" title="单点登录的三种实现方式"></a>单点登录的三种实现方式</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://yangtzeshore.github.io/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/cnblogs.com/yonghengzh/p/13712729.html">这篇博客</a>，作为整理和收录，方便后续查阅。</p><ul><li>引子</li><li>实现方式一：父域 Cookie</li><li>实现方式二：认证中心</li><li>实现方式三：LocalStorage 跨域</li><li>补充：域名分级</li></ul><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>在 B&#x2F;S 系统中，登录功能通常都是基于 Cookie 来实现的。当用户登录成功后，一般会将登录状态记录到 Session 中，或者是给用户签发一个 Token，无论哪一种方式，都需要在客户端保存一些信息（Session ID 或 Token ），并要求客户端在之后的每次请求中携带它们。</p><p>在这样的场景下，使用 Cookie 无疑是最方便的，因此我们一般都会将 Session 的 ID 或 Token 保存到 Cookie 中，当服务端收到请求后，通过验证 Cookie 中的信息来判断用户是否登录 。</p><p>单点登录（Single Sign On, SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。</p><p>举例来说，百度贴吧和百度地图是百度公司旗下的两个不同的应用系统，如果用户在百度贴吧登录过之后，当他访问百度地图时无需再次登录，那么就说明百度贴吧和百度地图之间实现了单点登录。</p><p>单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。</p><p>当然仅此是不够的，因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 Session ID 是往往保存在浏览器 Cookie 中的，因此存在作用域的限制，无法跨域名传递，也就是说当用户在 app1.com 中登录后，Session ID 仅在浏览器访问 app1.com 时才会自动在请求头中携带，而当浏览器访问 app2.com 时，Session ID 是不会被带过去的。实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。</p><h3 id="实现方式一：父域-Cookie"><a href="#实现方式一：父域-Cookie" class="headerlink" title="实现方式一：父域 Cookie"></a>实现方式一：父域 Cookie</h3><p>在将具体实现之前，我们先来聊一聊 Cookie 的作用域。</p><p>Cookie 的作用域由 domain 属性和 path 属性共同决定。domain 属性的有效值为当前域或其父域的域名&#x2F;IP地址，在 Tomcat 中，domain 属性默认为当前域的域名&#x2F;IP地址。path 属性的有效值是以“&#x2F;”开头的路径，在 Tomcat 中，path 属性默认为当前 Web 应用的上下文路径。</p><p>如果将 Cookie 的 domain 属性设置为当前域的父域，那么就认为它是父域 Cookie。Cookie 有一个特点，即父域中的 Cookie 被子域所共享，换言之，子域会自动继承父域中的Cookie。</p><p>利用 Cookie 的这个特点，不难想到，将 Session ID（或 Token）保存到父域中不就行了。没错，我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。</p><p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。</p><p>总结：此种实现方式比较简单，但不支持跨主域名。</p><h3 id="实现方式二：认证中心"><a href="#实现方式二：认证中心" class="headerlink" title="实现方式二：认证中心"></a>实现方式二：认证中心</h3><p>我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。</p><p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）</p><p>应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。</p><p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。</p><p>应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。</p><p>这里顺便介绍两款认证中心的开源实现：</p><ul><li>Apereo CAS 是一个企业级单点登录系统，其中 CAS 的意思是”Central Authentication Service“。它最初是耶鲁大学实验室的项目，后来转让给了 JASIG 组织，项目更名为 JASIG CAS，后来该组织并入了Apereo 基金会，项目也随之更名为 Apereo CAS。</li><li>XXL-SSO 是一个简易的单点登录系统，由大众点评工程师许雪里个人开发，代码比较简单，没有做安全控制，因而不推荐直接应用在项目中，这里列出来仅供参考。</li></ul><p>总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。</p><h3 id="实现方式三：LocalStorage-跨域"><a href="#实现方式三：LocalStorage-跨域" class="headerlink" title="实现方式三：LocalStorage 跨域"></a>实现方式三：LocalStorage 跨域</h3><p>前面，我们说实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。</p><p>父域 Cookie 确实是一种不错的解决方案，但是不支持跨域。那么有没有什么奇淫技巧能够让 Cookie 跨域传递呢？</p><p>很遗憾，浏览器对 Cookie 的跨域限制越来越严格。Chrome 浏览器还给 Cookie 新增了一个 SameSite 属性，此举几乎禁止了一切跨域请求的 Cookie 传递（超链接除外），并且只有当使用 HTTPs 协议时，才有可能被允许在 AJAX 跨域请求中接受服务器传来的 Cookie。</p><p>不过，在前后端分离的情况下，完全可以不使用 Cookie，我们可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID （或 Token ）放在响应体中传递给前端。</p><p>在这样的场景下，单点登录完全可以在前端实现。前端拿到 Session ID （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中。</p><p>关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 token</span><br><span class="hljs-keyword">var</span> token = result.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>;<br><br><span class="hljs-comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span><br><span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;iframe&quot;</span>);<br>iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://app1.com/localstorage.html&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(iframe);<br><span class="hljs-comment">// 使用postMessage()方法将token传递给iframe</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(token, <span class="hljs-string">&quot;http://app1.com&quot;</span>);<br>&#125;, <span class="hljs-number">4000</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    iframe.<span class="hljs-title function_">remove</span>();<br>&#125;, <span class="hljs-number">6000</span>);<br><br><span class="hljs-comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, event.<span class="hljs-property">data</span>)<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。</p><p>总结：此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域。</p><h3 id="补充：域名分级"><a href="#补充：域名分级" class="headerlink" title="补充：域名分级"></a>补充：域名分级</h3><p>从专业的角度来说（根据《计算机网络》中的定义），.com、.cn 为一级域名（也称顶级域名），.com.cn、baidu.com 为二级域名，sina.com.cn、tieba.baidu.com 为三级域名，以此类推，N 级域名就是 N-1 级域名的直接子域名。</p><p>从使用者的角度来说，一般把可支持独立备案的主域名称作一级域名，如 baidu.com、sina.com.cn 皆可称作一级域名，在主域名下建立的直接子域名称作二级域名，如 tieba.baidu.com 为二级域名。</p><p>为了避免歧义，本人将使用“主域名“替代”一级域名“的说法。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://yangtzeshore.github.io/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/cnblogs.com/yonghengzh/p/13712729.html">1. 单点登录的三种实现方式</a></p>]]></content>
    
    
    <categories>
      
      <category>登录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ContainerWithMostWater</title>
    <link href="/2021/01/10/ContainerWithMostWater/"/>
    <url>/2021/01/10/ContainerWithMostWater/</url>
    
    <content type="html"><![CDATA[<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/10/ContainerWithMostWater/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/10/ContainerWithMostWater/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p><p>给你 n 个非负整数 a1,a2,…,an，每个数代表坐标中的一个点 (i,ai) 。在坐标内画条垂直 n 线，垂直线 i 的两个端点分别为 (i,ai) 和 (i,0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ContainerWithMostWater.jpg" alt="ContainerWithMostWater"></p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,3,2,1,4]</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n = height.length</code></li><li><code>2 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li></ul><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题如果没想到双指针，也很简单，下面是自己写的一版。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerWithMostWater</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = height.length - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>                <span class="hljs-type">int</span> temp = (j - i) * Math.<span class="hljs-built_in">min</span>(height[i], height[j]);<br>                <span class="hljs-keyword">if</span> (temp &gt; max) &#123;<br>                    max = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] height = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>        height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>        height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>        height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">49<br>1<br>16<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是类似于暴力破解。</p><p>如果是双指针，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> area = Math.<span class="hljs-built_in">min</span>(height[l], height[r]) * (r - l);<br>            ans = Math.<span class="hljs-built_in">max</span>(ans, area);<br>            <span class="hljs-keyword">if</span> (height[l] &lt;= height[r]) &#123;<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                --r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针的思路需要数学证明的。</p><p><strong>证明</strong></p><p>为什么双指针的做法是正确的？</p><blockquote><p>双指针代表了什么？</p></blockquote><p>双指针代表的是 <strong>可以作为容器边界的所有位置的范围</strong>。在一开始，双指针指向数组的左右边界，表示 <strong>数组中所有的位置都可以作为容器的边界</strong>，因为我们还没有进行过任何尝试。在这之后，我们每次将 <strong>对应的数字较小的那个指针</strong> 往 <strong>另一个指针</strong> 的方向移动一个位置，就表示我们认为 <strong>这个指针不可能再作为容器的边界了</strong>。</p><blockquote><p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p></blockquote><p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p><p><strong>考虑第一步</strong>，假设当前左指针和右指针指向的数分别为 x 和 y ，不失一般性，我们假设 x&lt;y。同时，两个指针之间的距离为 t 。那么，它们组成的容器的容量为：</p><p>min(x,y)∗t&#x3D;x∗t</p><p>我们可以断定，<strong>如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 x∗t 了</strong>。注意这里右指针只能向左移动，因为 <strong>我们考虑的是第一步</strong>，也就是 <strong>指针还指向数组的左右边界的时候</strong>。</p><p>我们任意向左移动右指针，指向的数为 y1，两个指针之间的距离为 t1 ，那么显然有 t1&lt;t，并且 min(x,y1)≤min(x,y) ：</p><ul><li>如果 y1≤y，那么 min(x,y1)≤min(x,y)；</li><li>如果 y1&gt;y，那么 min(x,y1)&#x3D;x&#x3D;min(x,y)；</li></ul><p>因此有：</p><p>min(x,y1)∗t1&lt;min(x,y)∗t</p><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，<strong>这个左指针对应的数不会作为容器的边界了</strong>，那么我们就可以丢弃这个位置，<strong>将左指针向右移动一个位置</strong>，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p><p>这样以来，我们将问题的规模减小了 1 ，被我们丢弃的那个位置就相当于消失了。<strong>此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界</strong>，因此，我们可以继续像之前 <strong>考虑第一步</strong> 那样考虑这个问题：</p><ul><li>求出当前双指针对应的容器的容量；</li><li>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</li></ul><blockquote><p>最后的答案是什么？</p></blockquote><p>答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PalindromeNumber</title>
    <link href="/2021/01/09/PalindromeNumber/"/>
    <url>/2021/01/09/PalindromeNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/09/PalindromeNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/09/PalindromeNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 121</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: -121</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 10</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="hljs-section">进阶:</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题如果不考虑进阶，那很简单，下面是自己写的一版。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PalindromeNumber &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isPalindrome(<span class="hljs-type">int</span> x) &#123;<br>        String result = String.valueOf(x);<br>        <span class="hljs-keyword">if</span> (result.length() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (result.charAt(i) != result.charAt(result.length() - i - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isPalindrome(<span class="hljs-number">121</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isPalindrome(<span class="hljs-number">-121</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isPalindrome(<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是类似于暴力破解。</p><p>如果是进阶版，不需要用字符串：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isPalindrome1(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = x;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">temp</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> modNum = <span class="hljs-keyword">temp</span> % <span class="hljs-number">10</span>;<br>            result = result * <span class="hljs-number">10</span> + modNum;<br>            <span class="hljs-keyword">temp</span> /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == result;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>也很简单，无法是取模。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>StringToIntegerAtoi</title>
    <link href="/2021/01/08/StringToIntegerAtoi/"/>
    <url>/2021/01/08/StringToIntegerAtoi/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/08/StringToIntegerAtoi/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/08/StringToIntegerAtoi/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></p><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><ul><li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li><li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li><li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li></ul><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p><strong>提示：</strong></p><ul><li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li><li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [− 231, 231−1]。如果数值超过这个范围，请返回 INT_MAX ( 231−1 )或INT_MIN (− 231 ) 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。因此无法执行有效的转换。</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 20</li><li>0 &lt;&#x3D; p.length &lt;&#x3D; 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题没有做出来，参考了官方的解题思路，只要看懂了，写出自动机，解题并不难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringToIntegerAtoi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">Automaton</span> <span class="hljs-variable">automaton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Automaton</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            automaton.get(str.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (automaton.sign * automaton.ans);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;21474836460&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;   -42&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;4193 with words&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;words and 987&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;-91283472332&quot;</span>;<br>        System.out.println(myAtoi(s));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automaton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;start&quot;</span>;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String[]&gt; table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String[]&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        put(<span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        put(<span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        put(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        state = table.get(state)[get_col(c)];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;in_number&quot;</span>.equals(state)) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ans = sign == <span class="hljs-number">1</span> ? Math.min(ans, (<span class="hljs-type">long</span>) Integer.MAX_VALUE) : Math.min(ans, -(<span class="hljs-type">long</span>) Integer.MIN_VALUE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;signed&quot;</span>.equals(state)) &#123;<br>            sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_col</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">2147483647<br><span class="hljs-deletion">-42</span><br>4193<br>0<br><span class="hljs-deletion">-2147483648</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p><strong>自动机</strong></p><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。</p><p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p><p>我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。</p><p><strong>算法</strong></p><p>本题可以建立如下图所示的自动机：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/%E8%87%AA%E5%8A%A8%E6%9C%BA.png" alt="自动机"></p><p>我们也可以用下面的表格来表示这个自动机：</p><table><thead><tr><th align="center"></th><th align="center">‘ ‘</th><th align="center">+&#x2F;-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">in_number</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可。</p><p>另外自动机也需要记录当前已经输入的数字，只要在 s’ 为 in_number 时，更新我们输入的数字，即可最终得到输入的数字。</p><p>注意：只有5个状态是有效的。</p><p><strong>复杂度分析</strong></p><p><strong>时间复杂度</strong>：O(n)，其中 n为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</p><p><strong>空间复杂度</strong>：O(1)，自动机的状态只需要常数空间存储。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RegularExpressionMatching</title>
    <link href="/2021/01/07/RegularExpressionMatching/"/>
    <url>/2021/01/07/RegularExpressionMatching/</url>
    
    <content type="html"><![CDATA[<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/07/RegularExpressionMatching/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/07/RegularExpressionMatching/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></p><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span> p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span><br>输出：false<br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span> p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span> p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aab&quot;</span> p = <span class="hljs-string">&quot;c*a*b&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="hljs-string">&#x27;c&#x27;</span> 为 <span class="hljs-number">0</span> 个, <span class="hljs-string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="hljs-string">&quot;aab&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mississippi&quot;</span> p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mis*is*p*.&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 20</li><li>0 &lt;&#x3D; p.length &lt;&#x3D; 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题没有做出来，参考了官方的解题思路，只要看懂了，写出动态方程，解题并不难。如果是感性的字符匹配理解的话，很容易陷入死循环的理解和字符匹配泥沼。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegularExpressionMatching</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span> s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;aa&quot;</span>; p = <span class="hljs-string">&quot;a*&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;ab&quot;</span>; p = <span class="hljs-string">&quot;.*&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;aab&quot;</span>; p = <span class="hljs-string">&quot;c*a*b&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;mississippi&quot;</span>; p = <span class="hljs-string">&quot;mis*is*p*.&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-comment">// 注意初始化都是false</span><br>        <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 对着公式，这是缩减写法</span><br>                    f[i][j] = f[i][j - <span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matches</span>(s, p, i, j - <span class="hljs-number">1</span>)) &#123;<br>                        f[i][j] = f[i][j] || f[i - <span class="hljs-number">1</span>][j];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matches</span>(s, p, i, j)) &#123;<br>                        f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br><br>    <span class="hljs-comment">// 这里比较的一定是字符情况，所以不必考虑星号；且j一定是大于1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == p.<span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>题目中的匹配是一个「逐步匹配」的过程：我们每次从字符串 <code>p</code> 中取出一个字符或者「字符 + 星号」的组合，并在 <code>s</code> 中进行匹配。对于 <code>p</code> 中一个字符而言，它只能在<code>s</code>中匹配一个字符，匹配的方法具有唯一性；而对于 <code>p</code> 中字符 + 星号的组合而言，它可以在 <code>s</code> 中匹配任意自然数个字符，并不具有唯一性。因此我们可以考虑使用动态规划，对匹配的方案进行枚举。</p><p>我们用 <code>f[i][j]</code>表示 <code>s</code> 的前<code>i</code>个字符与<code>p</code> 中的前<code>j</code>个字符是否能够匹配。在进行状态转移时，我们考虑<code>p</code>的第<code>j</code>个字符的匹配情况：</p><ul><li>如果<code>p</code>的第<code>j</code>个字符是一个小写字母，那么我们必须在<code>s</code>中匹配一个相同的小写字母，即，，f[i][j]&#x3D;{f[i−1][j−1]，s[i]&#x3D;p[j]false，s[i]≠p[j]</li></ul><p>也就是说，如果s的第i个字符与p 的第j个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符，完整的匹配结果取决于两个字符串前面的部分。</p><ul><li>如果p 的第j个字符是 <code>*</code>，那么就表示我们可以对 p 的第j−1 个字符匹配任意自然数次。在匹配 0 次的情况下，我们有f[i][j]&#x3D;f[i][j−2]</li></ul><p>也就是我们「浪费」了一个字符 + 星号的组合，没有匹配任何 s中的字符。</p><p>在匹配 1,2,3,⋯ 次的情况下，类似地我们有</p><p>{f[i][j]&#x3D;f[i−1][j−1],ifs[i]&#x3D;p[j−1]f[i][j]&#x3D;f[i−2][j−1],ifs[i−1]&#x3D;s[i]&#x3D;p[j−1]f[i][j]&#x3D;f[i−3][j−1],ifs[i−2]&#x3D;s[i−1]&#x3D;s[i]&#x3D;p[j−1]…</p><p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了s中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p><ul><li>匹配 s末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</li><li>不匹配字符，将该组合扔掉，不再进行匹配。</li></ul><p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p><p>，，f[i][j]&#x3D;{f[i−1][j]orf[i][j−2]，s[i]&#x3D;p[j−1]f[i][j−2]，s[i]≠p[j]</p><p>右边的很好理解，就是没有匹配的情况。左边的需要结合实例，理解下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">aaaa*<br><span class="hljs-keyword">aaa</span><br><br><span class="hljs-keyword">aaa</span>*<br><span class="hljs-keyword">aaa</span><br><br><span class="hljs-keyword">aaa</span>*<br>aaaa<br></code></pre></td></tr></table></figure><ul><li>在任意情况下，只要p[j] 是 .，那么一定p[j]成功匹配中的任 s意一个小写字母。</li></ul><p>最终的状态转移方程如下：</p><p>，，，，f[i][j]&#x3D;{if(p[j]≠′∗′)&#x3D;{f[i−1][j−1]，matchs(s[i],p[j])false，otherwiseotherwise&#x3D;{f[i−1][j]orf[i][j−2]，matchs(s[i],p[j−1])f[i][j−2]，otherwise</p><p>其中 matches(x,y)判断两个字符是否匹配的辅助函数。只有当 y是 . 或者 x和y本身相同时，这两个字符才会匹配。</p><p><strong>细节</strong></p><p>动态规划的边界条件为 f[0][0]&#x3D;true，即两个空字符串是可以匹配的。最终的答案即为 f[m][n]，其中 m 和 n 分别是字符串 s和 p的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。</p><p>在上面的状态转移方程中，如果字符串 p中包含一个「字符 + 星号」的组合（例如 <code>a*</code> ），那么在进行状态转移时，会先将 a 进行匹配（当 p[j]为 a 时），再将<code>a*</code> 作为整体进行匹配（当 p[j]为 <code>*</code>时）。然而，在题目描述中，我们必须将 <code>a*</code> 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。这里我认为是不影响的，题目是解法的一个特例。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2021/01/04/Reverse/"/>
    <url>/2021/01/04/Reverse/</url>
    
    <content type="html"><![CDATA[<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/04/Reverse/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/04/Reverse/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 123</span><br><span class="hljs-section">输出: 321</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: -123</span><br><span class="hljs-section">输出: -321</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 120</span><br><span class="hljs-section">输出: 21</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这一版性能不是很好，可以参考下。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">Reverse</span> &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> reverse(<span class="hljs-type">int</span> x) &#123;<br><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        StringBuilder s = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            String will = String.valueOf(x).substring(<span class="hljs-number">1</span>);<br>            s.append(<span class="hljs-string">&#x27;-&#x27;</span>);<br>            <span class="hljs-type">boolean</span> flag0 = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = will.length() - <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-keyword">if</span> (will.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; flag0) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                s.append(will.charAt(i));<br>                flag0 = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String will = String.valueOf(x);<br>            <span class="hljs-type">boolean</span> flag0 = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = will.length() - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-keyword">if</span> (will.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; flag0) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                s.append(will.charAt(i));<br>                flag0 = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (checkOutOfRange(s.toString())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Integer</span>.parseInt(s.toString());<br>    &#125;<br><br>    private static <span class="hljs-type">boolean</span> checkOutOfRange(String will) &#123;<br>        String max = String.valueOf(<span class="hljs-type">Integer</span>.MAX_VALUE);<br>        String min = String.valueOf(<span class="hljs-type">Integer</span>.MIN_VALUE);<br><br>        <span class="hljs-keyword">if</span> (will.equals(&quot;0&quot;)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(will.startsWith(&quot;-&quot;)) &#123;<br>            <span class="hljs-keyword">if</span> (will.equals(min)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (will.length() &gt; min.length()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (will.length() &lt; min.length()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; will.length(); i++) &#123;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &gt; (<span class="hljs-type">int</span>) min.charAt(i)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &lt; (<span class="hljs-type">int</span>) min.charAt(i)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (will.equals(max)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (will.length() &gt; max.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (will.length() &lt; max.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; will.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &gt; (<span class="hljs-type">int</span>) max.charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &lt; (<span class="hljs-type">int</span>) max.charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span> test = <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">-123</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">120</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">1534236469</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">-2147483648</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">-2147483412</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">321<br><span class="hljs-deletion">-321</span><br>21<br>0<br>0<br><span class="hljs-deletion">-2143847412</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是类似暴力破解。</li></ul><p>比较优雅的一版如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> reverse1(<span class="hljs-keyword">int</span> x) &#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">pop</span> = x % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">// max == 2,147,483,647</span><br>            <span class="hljs-keyword">if</span> (ans &gt; Integer.MAX_VALUE <span class="hljs-regexp">/ 10 || (ans == Integer.MAX_VALUE /</span> <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-keyword">pop</span> &gt; <span class="hljs-number">7</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// min == 2,147,483,648</span><br>            <span class="hljs-keyword">if</span> (ans &lt; Integer.MIN_VALUE <span class="hljs-regexp">/ 10 || (ans == Integer.MIN_VALUE /</span> <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-keyword">pop</span> &lt; -<span class="hljs-number">8</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            ans = ans * <span class="hljs-number">10</span> + <span class="hljs-keyword">pop</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是拆解成取模算法，并且根据最大最小值做校验判断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——条分缕析分布式：因果一致性和相对论时空</title>
    <link href="/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%AE%BA%E6%97%B6%E7%A9%BA/"/>
    <url>/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%AE%BA%E6%97%B6%E7%A9%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——条分缕析分布式：因果一致性和相对论时空"><a href="#分布式系统原理——条分缕析分布式：因果一致性和相对论时空" class="headerlink" title="分布式系统原理——条分缕析分布式：因果一致性和相对论时空"></a>分布式系统原理——条分缕析分布式：因果一致性和相对论时空</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://mp.weixin.qq.com/s/wkXsRufVsbKqTwjzTgNqYQ">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p><p>  在上一篇文章《<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：浅析强弱一致性</a>》中，我们重点讨论了顺序一致性、线性一致性和最终一致性这几个概念。本文我们将继续深入，详细探讨另一种一致性模型——因果一致性，并在这个过程中逐步逼近分布式系统最深层的事件排序的本质。沿着这个方向，如果我们走得稍微再远一点，就会触达我们所生活的这个宇宙的时空本质，以及因果律的本质（这才是真正有意思的地方，希望你能一口气读到最后）。</p><p>  回到现实，《Designing Data-Intensive Applications》[1]一书的作者在他的书中提到，基于因果一致性构建分布式数据库系统，是未来一个非常有前景的研究方向。而且，估计很少有人注意到，我们经常使用的ZooKeeper，其实就在session维度上提供了因果一致性的保证[2]。理解「因果一致性」的概念，有助于我们对于分布式系统的认识更进一层。</p><h3 id="为什么要考虑因果一致性？"><a href="#为什么要考虑因果一致性？" class="headerlink" title="为什么要考虑因果一致性？"></a>为什么要考虑因果一致性？</h3><p>  结合<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>的讨论，我们再把一致性模型的来历简单梳理一下。</p><p>  早期的分布式系统设计者，为了让使用系统的开发者能够以比较简单的方式来使用系统，希望分布式系统能提供单一系统视图 (SSI，<em>single-system image</em>)[3]，即系统“表现得就好像只有一个单一的副本”。线性一致性和顺序一致性就是沿着这个思路设计的。满足线性一致性或顺序一致性的系统，对读写操作的排序呈现全局唯一的一种次序。</p><p>  然而，系统为了维持这种全局排序的一致性是有成本的，必然需要在副本节点之间做很多通信和协调工作。这降低了系统的可用性（<em>availability</em>）和性能。于是，在一致性、可用性、系统性能之间进行权衡的结果，就是降低系统提供的一致性保障，转向了最终一致性[4]。</p><p>  不过最终一致性提供的一致性保障是如此之弱，它放弃了所有的<em>safety</em>属性（具体讨论见<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261790&idx=1&sn=08449ee5b39d93b25442c1e583e3ba99&scene=21#wechat_redirect">上一篇文章</a>）。这给系统的使用带来了额外的困难。面向最终一致性系统进行编程，需要随时关注数据不一致的情况。加州大学伯克利分校在2013年发表了一篇非常不错的文章[3]，对于如何在最终一致性系统上构建应用，进行了非常深入的研究。文章指出了两种思路：</p><ul><li>针对可能出现的数据不一致情况实施补偿措施 (<em>compensation</em>)。这需要在分布式系统之上的应用层面进行额外的处理，是非常容易出错且费时费力的。</li><li>基于CALM定理和CRDTs，完全消除补偿操作。但这样做其实限制了应用编程能够使用的操作类型，也就限制了系统能力。</li></ul><p>  以上两种思路都涉及到了大量细节，我们不打算在这里深入讨论，有兴趣的读者可以仔细去阅读论文[3]。</p><p>  总之，为了提高系统可用性和系统性能，人们放弃了强一致性，采取了几乎最弱的一类一致性模型（最终一致性），但也同时牺牲了系统的能力或系统使用的便利性。那么，到底有没有必要一定采取这么「弱」的一致性模型呢？有没有可能在最终一致性的基础上增加一点<em>safety</em>属性，提供稍强一点的一致性，但同时也不至于对系统可用性和性能产生明显的损害呢？</p><p>  基于最新的研究，这是有可能的。这个问题的答案就是本文接下来要讨论的因果一致性 (<em>causal consistency</em>)。</p><p>  德克萨斯大学奥斯汀分校在2011年的一项研究表明[5]：</p><ul><li>不存在比因果一致性更强的一致性模型，能够在网络分区的情况下仍然可用。</li><li>在一个永远保持可用且单程收敛 (<em>always-available, one-way convergent</em>) 的系统里，因果一致性是可以被实现出来的。</li></ul><h3 id="因果一致性的直观解释"><a href="#因果一致性的直观解释" class="headerlink" title="因果一致性的直观解释"></a>因果一致性的直观解释</h3><p>  因果律是这个世界最基础的规律，物理法则决定了我们总是先看到事物的「因」，后看到事物的「果」。对于一个分布式系统来说，在数字世界中保持这种因果关系，当然也是一个最基本的要求。</p><p>  为了能比较通俗地理解因果一致性，我们这里引用一个假想的实例（来自论文[6]）。假设Billy是一个小男孩，Sally是他的妈妈。下面的故事发生在一个类似Facebook的社交网站上：</p><ol><li>有一天，Billy失踪了。Sally找不到他的儿子，很着急，于是在社交网站上发布了一条状态：“我儿子Billy丢了！”</li><li>过了一会，Sally突然接到了儿子的电话。Billy告诉妈妈，他跑到朋友家玩去了。Sally长出一口气，又重新修改了刚才发布的状态：“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”</li><li>Sally的一个朋友，叫James，看到了她发的最新的状态，在社交网站上回复了她：“太好了，总算松了一口气！”</li></ol><p>  假如这家社交网站的数据库系统没能保证因果一致性，那么我们就可能看到比较奇怪的事件次序。假设Sally的另外一个朋友，叫Henry，也在浏览这个社交网站。可能由于系统延迟，数据还未收敛到一致的状态，Henry可能会看到Sally发的第一条状态和James的回复，但却看不到Sally发的第二条状态。于是，在Henry看来：</p><ol><li>Sally说：“我儿子Billy丢了！”</li><li>James回复：“太好了，总算松了一口气！”</li></ol><p>  Henry可能会错误地认为，James满心希望Sally的儿子丢了（James肯定是恨透了Sally）！</p><p>  之所以发生这样的问题，就是因为因果倒置了。考虑两个事件：事件A，Sally发布第二条状态（称自己的儿子找到了）；事件B，James回复Sally表示安慰。显然，事件B是由事件A引发的，也就是说，事件A是事件B的「因」，事件B是事件A的「果」。但在Henry看来，却只看到了事件B，没有看到事件A，这违反了因果规律。（当然，这个例子隐藏了很多具体实现细节，你可能会产生一些疑问，但不妨碍我们讨论事件的因果关系）</p><p>  这里需要注意，如果分布式系统是满足线性一致性或者顺序一致性的，那么是不会发生这样的问题的。因为线性一致性和顺序一致性是能够保持因果关系的（下一章节我们还会继续讨论这个问题）。而只是满足最终一致性的系统，是没法总是保持因果关系的。但是，如果一个系统满足因果一致性，那么我们可以放心地认为，事件的因果关系是能够得到保证的。</p><p>  现在，让我们来尝试对因果一致性进行定义。我们先采取一种不那么严格，但比较直观的说法（下个章节再进行精确定义）。因果一致性遵守下面三条规则：</p><ol><li>单进程写操作有序。</li><li>“writes follow reads”规则。</li><li>因果关系可传递。</li></ol><p>  我们来分别解释一下：</p><ol><li>单进程写操作有序，指的是一个进程的多个写操作（可能是针对不同的数据对象的），在所有进程看来都是遵循同样的执行顺序。对应到前面的例子中，Sally的所有朋友都会看到，Sally是先发了一条状态“我儿子Billy丢了！”，然后又发了第二条状态“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”这条规则保证了没有人是先看到第二条状态然后才看到第一条状态的。对于这个次序的保证也是因果性的一种体现。</li><li>“writes follow reads”指的是，假设第一个进程先读取到了数据对象<em>x&#x3D;5</em>，后写入了另一个数据对象<em>y&#x3D;10</em>，然后第二个进程读到了<em>y&#x3D;10</em>，那么接下来如果这个进程读取数据对象<em>x</em>的值，那么不能读到一个比<em>x&#x3D;5</em>更旧的值。这条规则在不同进程的不同数据对象之间建立了因果关联。对应到前面的例子中，James看到了Sally发的最新状态：“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”（相当于读到了<em>x&#x3D;5</em>），然后回复说：“太好了，总算松了一口气！”（相当于写入了<em>y&#x3D;10</em>），再然后Henry看到了James的回复内容（相当于第二个进程读到了<em>y&#x3D;10</em>），这时候站在Henry的视角上看Sally发布的状态，他不能比James看到的数据版本更旧。前面的例子中出现的问题就在于，Henry比James看到了更旧的一个数据版本：“我儿子Billy丢了！”，致使因果关系混乱了。</li><li>因果关系是具有传递性的。如果操作A和操作B在因果关系上满足先后次序，而且操作B和操作C在因果关系上也满足先后次序，那么A和C在因果关系上必然是满足先后次序的。</li></ol><h3 id="因果一致性的精确定义"><a href="#因果一致性的精确定义" class="headerlink" title="因果一致性的精确定义"></a>因果一致性的精确定义</h3><p>  在前一章节我们讨论了因果一致性的直观解释，但我们还需要一个精确的定义。这样对于一个具体的包含读写操作的并发执行过程来说，我们才能知道如何判定它是否满足因果一致性。</p><p>  我们采用<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>的表示方法，还是先通过一个例子来看一个并发执行过程，如下图：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/5.webp" alt="图片"></p><p>  图中线段上面的符号表示具体的读写操作：</p><ul><li><em>A</em> —&gt; <em>w**i</em>(<em>x</em>)，表示一个写操作：第<em>i</em>个进程向数据对象<em>x</em>写入了值<em>A</em>。</li><li><em>r**i</em>(<em>x</em>) —&gt; <em>A</em>，表示一个读操作：第<em>i</em>个进程从数据对象<em>x</em>中读到了值<em>A</em>。</li></ul><p>  这个图表达了3个进程（<em>P</em>1、<em>P</em>2和<em>P</em>3）对于数据存储的读写执行过程。它是否满足因果一致性呢？</p><p>  跟线性一致性和顺序一致性的定义一样，因果一致性也是表达了系统对于读写操作的某种排序规则。为此我们首先需要定义清楚一个关键概念——<strong>因果顺序</strong> (causality order)，它表明了两个不同操作之间的排序是怎样规定的。</p><p>  <strong>因果顺序</strong>的定义：如果两个操作<em>o</em>1和<em>o</em>2满足下面三个条件之一，那么它们就是满足因果顺序的，记为<em>o</em>1→<em>o</em>2：</p><ul><li>(1) <em>o</em>1和<em>o</em>2属于同一个进程，且<em>o</em>1在<em>o</em>2前面执行。</li><li>(2) <em>o</em>1是个写操作，<em>o</em>2是个读操作，且<em>o</em>2读到的值是由<em>o</em>1写入的。</li><li>(3) 存在一个操作<em>o</em>‘满足<em>o</em>1→<em>o</em>‘→<em>o</em>2。</li></ul><p>  结合上图的例子，我们解释一下这三个条件：</p><ul><li>(1) 同一个进程内部先后执行的两个操作，不管他们是读操作还是写操作，都是满足因果顺序的。比如上图中<em>P</em>1进程的 <em>A</em> —&gt;<em>w**1</em>(<em>x</em>) 和 <em>B</em> —&gt; <em>w**1</em>(<em>x</em>) 两个操作就是满足因果顺序的；<em>P</em>2进程的<em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 和 <em>C</em> —&gt; <em>w**2</em>(<em>y</em>) 也是满足因果顺序的。这一条件表明，因果顺序遵从了进程的执行顺序。</li><li>(2) 如果一个读操作读到的值是由另一个写操作写入的（肯定是针对同一个数据对象），那么不管它们是不是属于同一个进程，这个写操作和读操作就是满足因果关系的。比如上图中的 <em>B</em> —&gt;<em>w**1</em>(<em>x</em>) 和 <em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 就是满足因果顺序的；<em>C</em> —&gt; <em>w**2</em>(<em>y</em>) 和 <em>r**3</em>(<em>y</em>) —&gt; <em>C</em> 也是满足因果顺序的。这个条件反映了读写操作之间的因果依赖关系。</li><li>(3) 这个条件表明因果顺序“→”满足传递关系 (<em>transitive relation</em>)。</li></ul><p>  从因果顺序的定义中，我们还能得到两个重要的结论：</p><ul><li>因果顺序是一种<strong>偏序关系</strong>。所谓偏序关系，就是说只有一部分操作是可以按照因果顺序进行比较的，而有一些操作之间是不能比较的。比如上图中的 <em>A</em> —&gt; <em>w**1</em>(<em>x</em>) 和 <em>D</em> —&gt; <em>w**3</em>(<em>x</em>) 这两个操作之间的关系，就不符合因果顺序三个条件中的任何一个。<em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 和 <em>D</em> —&gt; <em>w**3</em>(<em>x</em>) 之间也同样如此，它们之间不存在因果顺序。这具有很深刻的物理学和哲学内涵，因为现实世界的事件之间的因果关系就是偏序的（先不展开讨论）。分布式系统里对于读写操作之间的这种因果顺序的定义，正是对现实世界中这种现象的一种刻画。</li><li>因果顺序不能有循环依赖。假如操作<em>o</em>1→<em>o</em>2→<em>o</em>‘→…→<em>o</em>1，由传递关系就应该有：<em>o</em>1→<em>o</em>1。这表示一个操作是它自己的「因」，这是荒谬的。换句话说，如果把因果顺序用一个图来表示，那么它应该是一个有向无环图 (<em>directed acyclic graph</em>)。</li></ul><p>  现在基于<strong>因果顺序</strong>的定义，我们可以给出<strong>因果一致性</strong>的定义了。</p><p>  <strong>因果一致性</strong>定义[7]：在一个并发执行过程中，站在其中任意一个进程<em>P**i</em>的视角上，考虑这个进程的所有读、写操作和所有其它进程的所有写操作（注意不包含读操作），得到一个操作序列。如果站在任意一个进程的视角上得到的这个操作序列都能够重排成一个线性有序的序列，并且该序列满足以下两个条件，那么这个并发执行过程就是满足因果一致性的：</p><ul><li><strong>条件I</strong>：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</li><li><strong>条件II</strong>：重排后的序列遵从前面定义的因果顺序“→”。</li></ul><p>  对比<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中的顺序一致性定义，因果一致性的定义有两个不同：</p><ol><li>顺序一致性是对所有进程的所有读写操作进行统一的重排，而因果一致性是站在每个进程的视角各自进行局部重排。这表示顺序一致性要求系统的所有进程都对操作排序达成一致的看法，而因果一致性允许每个进程对操作的排序有不同的看法。</li><li>因果一致性与顺序一致性的<strong>条件II</strong>不同。顺序一致性的<strong>条件II</strong>只是要求遵从进程的执行顺序，而因果一致性则有更强的要求——遵从<strong>因果顺序</strong>（而进程的执行顺序只是因果顺序的一部分）。</li></ol><p>  以前面图示的并发执行过程为例，我们先以<em>P</em>1的视角，需要考虑把<em>P</em>1的所有读写操作和<em>P</em>2、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p><ol><li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li></ol><p>  再以<em>P</em>2的视角，需要考虑把<em>P</em>2的所有读写操作和<em>P</em>1、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p><ol><li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**2</em>(<em>x</em>) —&gt; <em>B</em></li><li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li></ol><p>  最后以<em>P</em>3的视角，需要考虑把<em>P</em>3的所有读写操作和<em>P</em>1、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p><ol><li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li><li><em>r**3</em>(<em>y</em>) —&gt; <em>C</em></li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  我们可以依次检查三个重排序列，会发现因果一致性的 <strong>条件I</strong>和<strong>条件II</strong>都是满足的（留给读者自己去检查，有疑问可以在评论区回复），所以前面图中的并发执行过程是满足因果一致性的。</p><p>  你可能会觉得因果一致性的定义有些复杂，那么它的设计初衷是什么呢？我们通过分析两个问题来做初步的解读：</p><ul><li>为什么因果一致性是站在各个进程的视角对部分操作进行排序，而不是对所有进程的操作进行全局排序？这是因为，因果顺序是一种偏序关系，这就允许站在不同进程的视角去观察各自所关心的部分操作，从而得到不同的观察结果（排序序列）且同时不违反因果律。假如因果顺序不是一种偏序，而是一种全局关系，那么就可以把所有操作按照同一个次序排序起来，那就变成跟顺序一致性一样了，每个进程也可以看到完全一样的排序序列了。所以说，这里隐含着一个结论：因果一致性是比顺序一致性更弱的一类一致性模型，而顺序一致性也意味着遵从了因果一致性。另外，也只有当站在不同进程的视角有不同的观察结果时，才可能在发生网络分区的时候，同时提供可用性。想象当一个节点同系统其它部分隔开了，这个节点不需要等待与其它节点联系，仍然可以使用旧版本的数据提供服务，同时不违反因果顺序即可。而如果像顺序一致性或者线性一致性那样，维持一个统一的全局排序，则需要在各个节点之间充分交换完数据才能达成一致。</li><li>为什么站在一个进程的视角要考虑所有其它进程的写操作呢？因为对于<strong>因果顺序</strong>来说，所有写操作都是潜在的「因」，而当前进程的读操作则代表了它的「看法」。进程的局部看法的形成，需要考虑所有的「因」，才能保证不违反因果律。</li></ul><p>  最后我们再来看一下，前一章节提到的因果一致性遵守的三条规则，是不是在因果一致性的定义中包含了：</p><ol><li>单进程写操作有序。因为每个进程进行局部重排的时候，都把所有进程的写操作考虑进去了，所以任何一个进程的多个写操作，在所有进程看来都是遵循同样的执行顺序。比如前面例子中<em>P</em>1的两个操作 <em>A</em> —&gt; <em>w**1</em>(<em>x</em>) 和 <em>B</em> —&gt; <em>w**1</em>(<em>x</em>)，在三次重排序列中都能保持次序。</li><li>“writes follow reads”规则。隐含在<strong>因果顺序</strong>的前两个条件里面。在前面例子中，进程<em>P</em>2先是读取到了<em>x&#x3D;B</em>，后写入了<em>y&#x3D;C</em>，然后进程<em>P</em>3先是读到了<em>y&#x3D;C</em>，接下来进程<em>P</em>3读取<em>x</em>的值，不能读到一个比<em>x&#x3D;B</em>更旧的值（满足）。</li><li>因果关系可传递。隐含在<strong>因果顺序</strong>的第三个条件里。</li></ol><p>  作为对比，下图是一个违反了“writes follow reads”的例子（因此不满足因果一致性）：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/6.webp" alt="图片"></p><h3 id="分布式系统事件排序"><a href="#分布式系统事件排序" class="headerlink" title="分布式系统事件排序"></a>分布式系统事件排序</h3><p>  因果一致性的概念[7]，是受到Lamport的经典论文[8]的启发而设计出来的。Lamport在1978年发表的经典论文《Time, Clocks, and the Ordering of Events in a Distributed System》，经常被认为是分布式领域中最重要的一篇论文。这篇论文定义了分布式系统中不同事件之间的一种偏序关系，称为“happened before”关系，即是对因果关系的一种刻画。</p><p>  Lamport定义了一种由不同进程组成的分布式系统模型，进程之间通过收发消息来传递信息。如下图：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/7.webp" alt="图片"></p><p>  在上图中，我们尝试对消息发送事件和消息接收事件进行排序（注意图中自下而上时间递增）。“happened before”关系也是用符号“→”来表示。</p><ul><li>在进程<em>Q</em>内部，<em>q</em>2表示一个消息接收事件，<em>q</em>4表示另一个消息发送事件，<em>q</em>2排在<em>q</em>4前面执行，所以<em>q</em>2→<em>q</em>4。</li><li><em>p</em>1和<em>q</em>2分别表示同一个消息的发送事件和接收事件，所以<em>p</em>1→<em>q</em>2；同理，<em>q</em>4→<em>r</em>3。</li><li>“happened before”满足传递关系。由<em>p</em>1→<em>q</em>2，<em>q</em>2→<em>q</em>4和<em>q</em>4→<em>r</em>3，可以推出<em>p</em>1→<em>r</em>3。</li></ul><p>  以上三种情况，与我们前面讨论的因果顺序定义中的三个条件，基本一一对应。因果一致性的概念应用在分布式存储系统上，相当于将“happened before”关系应用在了读写操作之上。</p><p>  可以看出，这里的“happened before”关系，也是一种偏序关系。比如<em>p</em>1和<em>q</em>1两个事件就是无法比较的，<em>q</em>4和<em>r</em>2也是无法比较的。无法比较的两个事件之间不满足“happened before”关系。</p><h3 id="因果一致性的难以理解之处"><a href="#因果一致性的难以理解之处" class="headerlink" title="因果一致性的难以理解之处"></a>因果一致性的难以理解之处</h3><p>  经过以上的讨论，相信你已经对因果一致性有了初步的理解了。现在我们来看一个稍显奇怪的例子（下图的例子出自论文[7]）。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/8.webp" alt="图片"></p><p>  上图表达了两个进程的并发执行过程。它是满足因果一致性的，因为站在进程<em>P</em>1和<em>P</em>2的视角，都能得到一个局部合理的排序（满足因果顺序）。</p><p>  站在<em>P</em>1视角，有：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>r**1</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  站在<em>P</em>2视角，有：</p><ol><li><em>B</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**2</em>(<em>x</em>) —&gt; <em>A</em></li></ol><p>  以上这些分析完全符合因果一致性的定义。但是，仔细看这个例子，如果接下来没有任何进程对数据对象<em>x</em>进行写操作了，那么<em>P</em>1永远读到的是<em>x&#x3D;B</em>，而<em>P</em>2永远读到的是<em>x&#x3D;A</em>。这似乎有些不可思议。</p><p>  发生这个现象的原因在于，进程<em>P</em>1和<em>P</em>2对于两个写操作的排序，「看法」不一致：</p><ul><li>在<em>P</em>1看来，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)发生在<em>B</em> —&gt; <em>w**2</em>(<em>x</em>)前面。</li><li>在<em>P</em>2看来，<em>B</em> —&gt; <em>w**2</em>(<em>x</em>)发生在<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)前面。</li></ul><p>  这就如同相对论难以理解一样：不同参照系的观察者对于不同事件的先后顺序，可能产生不同的看法。实际上，分别站在进程<em>P</em>1和<em>P</em>2的视角上，它们看到的都没有什么矛盾。矛盾发生在我们站在全局视角去看的时候。</p><p>  假设躲在进程<em>P</em>1和<em>P</em>2背后的两个用户，通过系统外的通信方式进行了交流，那么他们就会发现这个奇怪之处：他们竟然对于同一个数据对象<em>x</em>读到的值不同！但是站在因果一致性的分布式系统内部来看的话，不应该发生这种情况，因为进程之间的沟通，都应该在系统内发生。所谓发生在系统内的进程之间的沟通，必定是通过进程对于数据对象的读写操作进行的。如果进程<em>P</em>1或<em>P</em>2对数据对象<em>x</em>进行了写操作，那么它们就有机会对数据对象<em>x</em>的值达成同样的看法；或者很不走运，永远也达不成同样的看法，但它们如果不借助系统外的手段永远也发现不了这种不同（还是不违反因果律）。</p><p>  顺便提一句，如果要保证在系统外发生的因果联系也能在系统内永远被遵守，那么就要借助于Lamport在他的论文中提到的***Strong Clock Condition***了。</p><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>  我们前面提到，因果一致性对于分布式系统读写操作事件的排序，是对现实世界的事件之间因果关系的一种刻画。理解的难点在于，在我们所生活的这个宇宙中，事件之间的时间次序，只是一种偏序关系；对应的，事件之间的因果关系，也是一种偏序。</p><p>  在牛顿的绝对时空观中，时间是以某个固定速率向前流逝的绝对量，而不管我们站在哪个参照系的视角上。由此带来的推论是，宇宙中发生的任何一个事件，都可以根据它们发生的绝对时间点进行先后排序。也就是说，在绝对时空中的事件之间的排序是一种全序关系，任何两个事件都能比较先后。发生在前面的事件就有可能影响后面的事件，从而产生因果关系。试想一下，就在你读到这里的几秒之前，三体星系上发生了某个重大事件，按照绝对时空观的观点，它也可能对现在的你产生了影响。你大概会同意，这是不可能的，因为三体星系即使以最快的速度向地球传递信息，也要在4年之后才能到达。</p><p>  而在爱因斯坦的相对论中，这个问题就得到了解决。时间不再是一个绝对的量。不同参照系看到的时间流速可以快慢不同，甚至对两个事件的先后次序可以看法不同。但是，对于可能互相产生影响的事件，它们之间的先后次序，不管在什么参照系上看到的都应该是相同的，否则就违反了因果律。实际上，在相对论的时空中，结论是这样的：</p><ul><li>一个事件，和在它的「未来光锥」之内的任何其它事件，都是有偏序关系的。它们之间的先后次序，不管在什么参照系上看到的都应该是相同的。</li><li>一个事件，和在它的「未来光锥」之外的其它事件，是没有偏序关系的（也就不可能产生因果关系）。站在不同参照系上看这样的两个事件，它们的先后次序可能不同。</li></ul><p>  回到我们的分布式系统。一个分布式系统自成宇宙，它是对现实世界的一种刻画。分布式系统由不同的进程组成，而不同的进程分布在不同的空间，每个进程可以看成一个单独的参照系。因果一致性，本质上就是按照我们对于相对论宇宙的认识来进行系统建模的，这也是它的合理性的根基。然而，分布式系统毕竟只是一个模拟系统，它是服务于系统外的现实世界的。而在现实世界中，我们还可以有额外的传递信息的方式，这相当于在分布式系统自成体系的这个「宇宙」之外，可能存在更快的传递信息的维度。所以说，分布式系统只依靠自己的逻辑，是无法与现实世界完全达成一致的。而要做到对现实的完美刻画，就一定需要考虑现实世界的实时时钟（可以从Lamport的***Strong Clock Condition***入手）。</p><p>  到这里，我们已经触达到分布式系统（也包括这个宇宙时空）最深层的本质问题了。相信在这样的逻辑框架下，任何分布式系统的相关问题，都能很容易找到它在整个体系中的逻辑位置。至此，我们也完成了分布式一致性这个话题的「三部曲」了。其它两篇参见：</p><ul><li>《<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：到底什么是一致性？</a>》</li><li>《<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：浅析强弱一致性</a>》</li></ul><p>  当然，分布式相关的话题还远没有结束，还有更多有意思的问题等着我们去探究。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li>[1] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li><li>[2] Martin Kleppmann, “Please Stop Calling Databases CP or AP”, 2015.</li><li>[3] Peter Bailis, Ali Ghodsi, “Eventual Consistency Today: Limitations, Extensions, and Beyond”, 2013.</li><li>[4] Werner Vogels, “Eventually Consistent”, 2008.</li><li>[5] Prince Mahajan, Lorenzo Alvisi, Mike Dahlin, “Consistency, Availability, and Convergence”, 2011.</li><li>[6] Peter Bailis, Ali Ghodsi, et al, “Bolt-on Causal Consistency”, 2013.</li><li>[7] Mustaque Ahamad, Gil Neiger, James E. Burns, et al, “Causal Memory: Definitions, Implementation and Programming”, 1994.</li><li>[8] Leslie Lamport, “Time, Clocks, and the Ordering of Events in a Distributed System”, 1978.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——条分缕析分布式：浅析强弱一致性</title>
    <link href="/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——条分缕析分布式：浅析强弱一致性"><a href="#分布式系统原理——条分缕析分布式：浅析强弱一致性" class="headerlink" title="分布式系统原理——条分缕析分布式：浅析强弱一致性"></a>分布式系统原理——条分缕析分布式：浅析强弱一致性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261790&idx=1&sn=08449ee5b39d93b25442c1e583e3ba99&scene=21#wechat_redirect">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p><p>  当前这篇文章至少比计划拖后了两个月。在上一篇文章《<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：到底什么是一致性？</a>》中，我们仔细辨析了「一致性」相关的几个容易混淆的概念。而在本文中，我们会沿着逐步深入的思路，跟大家继续讨论顺序一致性、线性一致性、最终一致性等几个概念。</p><p>为了避免产生歧义，我们先明确一下这几个概念的英文表达：</p><ul><li>顺序一致性的英文是：<em>sequential consistency</em>。</li><li>线性一致性的英文是：<em>linearizability</em>。实际上，它就是CAP定理中的C，我们在<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中已经提到过。</li><li>最终一致性的英文是：<em>eventual consistency</em>。</li></ul><p>  在进行详细的技术性讨论之前，我们先把本文要讨论的几个重点问题和结论列出如下：</p><ul><li>线性一致性和顺序一致性，属于分布式系统的一致性模型 (<em>consistency model</em>)。这代表了分布式系统的一个非常非常重要的方面。</li><li>通常人们把线性一致性称为「强一致性」，把最终一致性称为「弱一致性」，但线性一致性和最终一致性其实存在本质的区别。严格来说，它们并不是一个范畴的概念。</li><li>一致性模型之间的「强弱」比较，是一个相对的概念。比如，线性一致性是比顺序一致性更强的一致性模型。当然，除了线性一致性和顺序一致性，也存在其它一些一致性模型（其中很多都比顺序一致性要弱）。</li><li>满足线性一致性的系统，也必定满足顺序一致性，但反过来不一定。这是由一致性模型之间的强弱关系决定的。</li></ul><p>  下面，我们就开始详细的解析。</p><h3 id="一致性模型的来历"><a href="#一致性模型的来历" class="headerlink" title="一致性模型的来历"></a>一致性模型的来历</h3><p>  我们之所以使用分布式系统，无非是因为分布式系统能带来一些「好处」，比如容错性、可扩展性等等。为了获得这些「好处」，分布式系统实现上常用的方法是复制 (<em>replication</em>) 和分片 (<em>sharding</em>)。而我们将要讨论的一致性模型 (<em>consistency model</em>)，主要是与复制有关。因此这里我们先关注一下复制的机制。</p><p>  复制指的是将同一份数据保存在多个网络节点上。而保存同一份数据拷贝的节点，被称为副本 (replica)。复制带来的具体「好处」主要是体现在两个方面：</p><ul><li>容错 (<em>fault tolerance</em>)。即使某些网络节点发生故障，由于原本保存着在故障节点上的数据在正常节点上还有备份，所以整个系统仍然可能是可用的。这也是我们期待分布式系统能够提供的「高可用」特性。</li><li>提升吞吐量。将一份数据复制多份并保存在多个副本节点上，还顺便带来一个好处：对于同一个数据对象的访问请求（至少是读请求）可以由多个副本节点分担，从而使得整个系统可以随着请求量的增加不断扩展。</li></ul><p>  一方面，复制带来了诸多好处；另一方面，它也带来了很多挑战，其中最重要的一个就是数据的一致性问题。由于同一份数据保存在了多个副本节点上，它们之间就存在数据不一致的风险。我们当然希望同一份数据的不同副本总是保持一致。换句话说，我们希望在其中一个副本上所做的修改，在其它副本上也能随时观察到（即读取到）。</p><p>  当然我们心里都清楚，让所有副本在任何时刻都保持一致，是不可能的。因为副本之间的数据同步即使速度再快，也是需要时间的。不过幸运的是，我们其实并不关心所有时刻的数据一致性情况。只要系统能够保证，每当我们去「观察」的时候（即读取数据副本的时候），系统表现出来的行为是一致的，就可以了。换句话说，即使在两次「观察」之间，系统内部出现了短暂的数据不一致的情况，只要系统保证外部用户无论如何都发现不了，我们也是可以满意的。</p><p>  这意味着，我们应该从系统用户（使用系统的开发者）的角度，来对数据一致性的要求进行定义。</p><p>实际上，早期的分布式系统设计者们对系统设计的要求，也是按照类似的思路进行的。在理想情况下，系统应该维持类似SSI (<em>single-system image</em>)[1]或<em>distribution transparency</em>[2]的特性。这两个概念要表达的核心意思是，系统内部有关分布式实现的复杂性应该对系统的外部用户透明；也就是说，对于系统的外部用户来说，系统应该表现得就好像只有一个单一的副本一样。如果系统能够提供这种「单一系统视图」或「透明性」，那么系统的使用者就能以比较简单的方式来使用系统；否则就可能带来很大的负担。</p><p>  系统“表现得就好像只有一个单一的副本”，这是一个相当「笼统」的说法。在此我们讨论3个具体的例子：</p><ol><li>我们先向一个副本节点写入<em>x</em>&#x3D;42，然后读取数据对象<em>x</em>的值。显然，不管我们从哪个副本节点上进行读取，我们都希望读到最新写入的值（也就是42）。只有这样才合理。</li><li>两个系统用户分别在两个副本节点上同时执行写操作。其中，用户A在第1个副本上执行<em>x</em>&#x3D;42；用户B在第2个副本上执行<em>x</em>&#x3D;43。然后用户C读取<em>x</em>的值。虽然两个写操作是「同时」进行的，但为了让系统“表现得像只有一个副本”，我们还是需要对它们进行一个先后排序。又因为它们是「同时」执行的，所以谁先谁后都有可能是合理的。如果我们认为<em>x</em>&#x3D;42在<em>x</em>&#x3D;43之前先执行，那么读取到的<em>x</em>的值就应该是43；反过来，如果我们认为<em>x</em>&#x3D;43在x&#x3D;42之前先执行，那么读取到的<em>x</em>的值就应该是42。</li><li>用户A先在第1个副本上执行<em>x</em>&#x3D;42，然后用户B再在第2个副本上执行<em>x</em>&#x3D;43，最后用户C在第3个副本上读取<em>x</em>的值。仍然为了让系统“表现得像只有一个副本”，直觉上看，用户C读取到的<em>x</em>的值似乎应该是43。但是，也不一定非要如此。因为两个写操作是分别由用户A和用户B发起的，他们并不知道彼此谁先谁后（虽然从时间上看用户A的写操作确实在先）。所以，我们也可以选择认为用户B执行<em>x</em>&#x3D;43在用户A执行<em>x</em>&#x3D;42之前。这样的话，用户C读取到的<em>x</em>的值就应该是42。当然，根据本文后面的讨论，这种排序就不满足线性一致性了，但却满足顺序一致性。</li></ol><p>  从这些例子不难看出，一个系统在数据一致性上的具体表现如何，取决于系统对关键事件（读写操作）的排序和执行采取什么样的规则和限制。比如在上面第3个例子中，出现了两种对于读写操作的排序。前一种排序是：</p><ol><li>用户A执行<em>x</em>&#x3D;42。</li><li>用户B执行<em>x</em>&#x3D;43。</li><li>用户C读取到<em>x</em>的值是43。</li></ol><p>而第3个例子中的后一种排序是：</p><ol><li>用户B执行<em>x</em>&#x3D;43。</li><li>用户A执行<em>x</em>&#x3D;42。</li><li>用户C读取到<em>x</em>的值是42。</li></ol><p>  虽然这两种排序结果不同，但它们都做到了让系统“表现得像只有一个副本”。它们的不同在于，前一种排序遵循了不同用户的操作的时间先后顺序，而后一种排序没有。实际上，如果我们要求系统满足线性一致性，就只能得到前一种排序结果；而如果只要求系统满足顺序一致性，就有可能得到后一种排序结果（等看完本文后面的讨论，你就能自己得到这些结论）。</p><p>  可以这么说，一个分布式系统对于读写操作的某种排序和执行规则，就定义了一种一致性模型 (<em>consistency model</em>)。当一个系统选定了某种特定的一致性模型（比如线性一致性或顺序一致性），那么你就只能看到这种一致性模型所允许的那些操作序列。还是拿前面第3个例子来说明：如果你选定了线性一致性模型，那么系统就不会向你呈现后一种排序，你只能看到前一种排序。</p><p>  另外，在前面的三个例子中，不管系统最终给出了哪种排序结果，所有系统的用户其实都对那种操作序列达成了一致的看法。还有一些一致性模型，并不要求所有用户对操作排序的结果达成唯一的一种看法。这样的一致性模型稍显复杂，我们会放在下一篇文章中再讨论（比如因果一致性）。</p><p>  接下来，为了更清晰地认识一致性模型，我们来深入到线性一致性和顺序一致性的一些细节中去。</p><h3 id="线性一致性和顺序一致性"><a href="#线性一致性和顺序一致性" class="headerlink" title="线性一致性和顺序一致性"></a>线性一致性和顺序一致性</h3><p>  在讨论之前，我们先把组成分布式系统的一些关键概念定义清楚：</p><ul><li>整个系统可以看成由多个<strong>进程</strong>和一个共享的<strong>数据存储</strong>组成。对于数据存储的读写操作由进程发起。这里的进程，相当于本文前面提到的系统用户或系统使用者。</li><li>同一个进程发起的读写操作是先后顺序执行的。注意，这里的「进程」概念跟我们平常编程时用到的进程有所不同，进程里面不再分多个线程了。</li><li>数据存储可能有多个副本，但我们在讨论一致性模型的时候，把它看成一个整体来看待，不区分读写操作提交到了具体哪个副本上。</li><li>每个操作的执行，从开始调用到执行结束，都需要花一定的时间。因此，一个进程发起的操作还没有执行完的时候，另一个进程的操作可能就已经开始了。</li></ul><p>  可见，系统的多个进程是并发执行的。下面我们通过一个例子来说明这种并发执行的情况，进而解释顺序一致性的概念。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/1.webp" alt="图片"></p><p>  上面是一个类似「时空图」的图像，表达了3个进程（<em>P</em>1、<em>P</em>2和<em>P</em>3）对于数据存储的读写执行过程。在这个图中，横向从左到右表示时间递增，黑色的线段表示每个操作的执行起止。线段上面的符号表示具体的读写操作：</p><ul><li><em>A</em> —&gt; <em>w**i</em>(<em>x</em>)，表示一个写操作：第<em>i</em>个进程向数据对象<em>x</em>写入了值<em>A</em>。</li><li><em>r**i</em>(<em>x</em>) —&gt; <em>A</em>，表示一个读操作：第<em>i</em>个进程从数据对象<em>x</em>中读到了值<em>A</em>。</li></ul><p>  现在我们要考察的问题是：上图的这样一个执行过程，是否满足顺序一致性？要回答这个问题，我们首先得知道顺序一致性的定义是什么。</p><p>  <strong>顺序一致性</strong>定义[3,4]：如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p><ul><li><strong>条件I</strong>：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</li><li><strong>条件II</strong>：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</li></ul><p>  以上图的执行过程为例，我们重排所有的6个读写操作，可以得到如下的有序序列：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li><li><em>C</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  很容易看出，这个序列是满足前面顺序一致性定义中的两个条件的：</p><ul><li>条件I：在这个重排后的序列中，每个读操作都返回了前面最近一次写入的值，比如第2个操作读到的值<em>A</em>，是前面第1个操作写入的；第4个操作读到的值<em>C</em>，是前面第3个操作写入的。</li><li>条件II：原来进程<em>P</em>1中的两个写操作，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)和<em>B</em> —&gt;<em>w**1</em>(<em>x</em>)，在这个重排后的序列中仍然保持了先后顺序。与此类似，原来进程<em>P</em>3中的3个读操作，在这个重排后的序列中也保持了原来的先后顺序。</li></ul><p>  所以现在我们可以回答前面的问题了：上图中的执行过程，是满足顺序一致性的。</p><p>  你可能会问，顺序一致性为什么会这样定义呢？这个定义的初衷是什么？</p><p>  我们可以试着这样理解：首先，重排成一个全局线性有序的序列，相当于系统对外表现出了一种「假象」，原本多进程并发执行的操作，好像是顺序执行的一样。本文前面提到过，理想情况下，分布式系统应该“表现得像只有一个副本”一样。顺序一致性正是遵循了这种「系统假象」，系统对外表现就好像在操作一个单一的副本，执行顺序也必然是可以看做顺序执行的。而条件I规定了系统的表现是合理的（即合乎逻辑的）；条件II则保证了以任何进程的视角来看，它所发起的操作执行顺序都是符合它原本的预期的。总之，一个满足顺序一致性的系统，对外表现就好像总是在操作一个副本一样。</p><p>  我们再通过一个例子来看一看这个问题的反面——不满足顺序一致性的执行过程是怎样的。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/2.webp" alt="图片"></p><p>  这个图中的执行过程，与前面第一个图的执行过程非常相似，只是进程<em>P</em>3的几个操作的执行顺序稍有变化。</p><p>  我们根据前面顺序一致性的定义再来试着对这个执行过程中的所有操作进行重排：首先根据条件II和进程<em>P</em>1的执行顺序，我们知道，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)一定要排在<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)前面；再根据条件I，进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)一定要排在进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>B</em>前面。最后，再结合条件II和进程<em>P</em>3的执行顺序，我们能够得出结论，进程<em>P</em>1和进程<em>P</em>3的所有操作，在最终重排后的完整序列中，必然保持以下的顺序：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li><li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li><li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li></ol><p>  我们会发现，上面的序列有两个地方不满足条件I：</p><ul><li>第4个操作读到了值<em>C</em>，而前面最近一次写操作（第2个操作）所写入的值是<em>B</em>。</li><li>第5个操作读到了值<em>A</em>，而前面最近一次写操作（也是第2个操作）所写入的值是<em>B</em>。</li></ul><p>  我们还剩一个进程<em>P</em>2的写操作，即<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，没有放到最后这个序列中。也许我们可以试着将它放置到第3和第4个操作之间，这样就能把前面第一个不满足条件I的地方修复掉。但无论如何，也无法得到一个完全符合条件I和条件II的完整序列了。因此，前面第二个图中的执行过程，是不满足顺序一致性的。进一步说，如果一个系统的执行呈现出了这样的一种执行过程（如前面第二个图所示），那我们可以肯定地说，这个系统是没有遵守顺序一致性的。</p><p>  我们再来考察一下线性一致性的概念。线性一致性的定义[5]，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件I和条件II之外，还要同时满足一个条件：</p><ul><li><strong>条件III</strong>：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</li></ul><p>  根据最新定义的条件III，我们来重新评判一下前面第一个图所展现出来的执行过程是不是满足它。为了阅读和讨论方便，我们把第一个图重新展示在下面：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/3.webp" alt="图片"></p><p>  针对条件III，我们分析一下各个操作之间的先后顺序：</p><ul><li>进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>2的<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，在执行时间上是重叠的，所以它们的排序不受条件III的约束。即，在重排后的序列中，这两个操作谁先谁后都可以。同样，进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>A</em>，也是如此。</li><li>进程<em>P</em>1的<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>2的<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，在执行时间上是不重叠的，即前一个操作都执行完了，后一个操作才开始执行。那么，这两个操作就必须满足条件III了：在重排后的序列中，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)必须排在<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)前面。</li><li>与上面同样的道理，在重排后的序列中，进程<em>P</em>2的<em>C</em> —&gt;<em>w**2</em>(<em>x</em>)必须排在进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>A</em>之前。</li></ul><p>  容易看出，在遵守这样的先后关系约束的前提下，不管怎么重排，都无法得到一个满足条件I的完整序列了。所以说，前面第一个图所示的满足顺序一致性的执行过程，是不满足线性一致性的。</p><p>  下面我们举一个满足线性一致性的例子：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/4.webp" alt="图片"></p><p>  上图的执行过程，所有操作重排后，可以得到如下的有序序列：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li><li><em>C</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  不难看出，这个序列是满足所有的条件I、条件II和条件III这三个条件的。因此，这个执行过程满足线性一致性。</p><p>  细心的你可能已经发现了，最后这个线性一致性的例子，得到的重排后的序列，与开始第一个顺序一致性的例子重排后的序列，完全相同。当然，这两个例子中原始的多进程并发执行过程，是不同的。这是符合预期的（没有什么可奇怪的）。</p><p>  现在我们可以仔细分析一下条件II和条件III，它们囊括了任意两个操作之间所有可能的先后关系：</p><ul><li>进程内的任意两个操作之间，总是先后顺序执行的（执行时间上不可能重叠）；而根据条件II，它们的先后顺序在最后重排后的序列中也会保持。</li><li>不同进程的不同操作之间，在执行时间上可能重叠（并发执行），也可能不重叠。根据条件III，不重叠的两个操作，它们在时间上的先后顺序，在最后重排后的序列中会得以保持。而对于执行时间上重叠的两个操作，它们在最后重排后的序列中的先后顺序没有规定。</li></ul><p>  最后，我们比较一下顺序一致性和线性一致性：</p><ul><li>它们都试图让系统“表现得像只有一个副本”一样。</li><li>它们都保证了程序执行顺序不会被打乱。体现在条件II对于进程内各个操作的排序保持上。</li><li>线性一致性考虑了时间先后顺序，而顺序一致性没有。</li><li>满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</li></ul><p>  注意一下上面第3点两者在时间先后顺序上的不同。这意味着：</p><ul><li>线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</li><li>在顺序一致性中，我们有可能读到旧版本的数据。比如，在本文第一个顺序一致性的例子中，在进程<em>P</em>2将数据对象<em>x</em>的值写成了<em>C</em>之后，进程<em>P</em>3仍然读到了旧的值（<em>A</em>）。</li></ul><h3 id="最终一致性和它的特殊性"><a href="#最终一致性和它的特殊性" class="headerlink" title="最终一致性和它的特殊性"></a>最终一致性和它的特殊性</h3><p>  我们在<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中提到过，CAP定理[6]中的C，指的就是线性一致性 (<em>linearizability</em>)。它也经常被称为「强一致性」。</p><p>  根据CAP定理，当存在网络分区的时候，我们必须在可用性 (<em>availability</em>) 和强一致性之间进行取舍。</p><p>  另外，即使在没有网络分区存在的情况下，我们也必须在延迟 (<em>latency</em>) 和强一致性之间进行取舍[7]。这是因为，系统维持强一致性是有成本的。想要维持越强的一致性，就需要在副本节点之间做更多的通信和协调工作，因此会降低操作的总延迟，进而降低整个系统的性能。</p><p>  从20世纪90年代中期开始，互联网开始蓬勃发展，系统的规模也变得越来越大。人们设计大型分布式系统的指导思想，也逐步开始更倾向于系统的高可用性和高性能。取舍的结果就是，降低系统提供的一致性保障。这其中非常重要的一条思路就是最终一致性[2]。</p><p>  最终一致性的设计思路，不再试图提供单一系统视图 (SSI)，即不再试图让系统“表现得像只有一个副本”一样。它允许读到旧版本的数据。最终一致性的原始出处是论文[2]，作者在论文中给出的最终一致性的定义如下：</p><blockquote><p>Eventual consistency. This is a specific form of weak consistency; the storage system guarantees that if no new updates are made to the object, eventually all accesses will return the last updated value.(译文：最终一致性是弱一致性的一种特殊形式；存储系统保证，如果对象没有新的修改操作，那么所有的访问最终都会返回最新写入的值。)</p></blockquote><p>  我们发现，虽然最终一致性和本文前面讨论的线性一致性或顺序一致性在命名上非常相似，但它的定义却与后两者存在非常大的差别。深层的原因在于，它们其实属于不同类别的系统属性 (<em>property</em>)。线性一致性和顺序一致性属于<em>safety property</em>（安全性）；而最终一致性属于<em>liveness property</em>（活性）[8]。</p><p>  一个并发程序或者一个分布式系统，它们的执行所展现出来的系统属性，可以分为两大类：</p><ul><li>***safety**<em>：它表示「坏事」永远不会发生。比如，一个系统如果遵守线性一致性或顺序一致性，那么就永远不会出现违反三个（对于顺序一致性来说是两个）条件的执行过程。而一旦系统出现问题，</em>safety*被违反了，我们也能明确指出是在哪个时间点上出现意外的。</li><li>**<em>liveness**<em>：它表示「好事」最终会发生。这种属性听起来会比较神奇：在任何一个时间点，你都无法判定</em>liveness*被违反了。因为，即使你期望的「好事」还没有发生，也不代表它未来不会发生。就像最终一致性一样，即使当前系统处于不一致的状态，也不代表未来系统就不会达到一致的状态。而只要系统存在“在未来某个时刻达到一致状态”的可能性，最终一致性就没有被违反。另外，可用性 (<em>availability</em>) 也属于</em>liveness*属性。</li></ul><p>  由此可见，我们在前一小节之所以能够将线性一致性和顺序一致性放在一起讨论和比较，是因为它们都属于<em>safety</em>属性。而最终一致性属于<em>liveness</em>属性，跟这两者存在本质的区别。实际上，最终一致性有点名不副实，它更好的名字可能是收敛性 (<em>convergence</em>)，表示所有副本最终都会收敛到相同的值[9]。</p><p>  通常来说，只有当<em>safety</em>和<em>liveness</em>这两种属性被同时考虑时，一个系统才能提供有意义的系统保证[1]。而当系统设计者遵循最终一致性的设计思路时，相当于放弃了所有的<em>safety</em>属性。这意味着，对于系统使用者来说，你必须针对数据不一致的可能性做好补偿措施 (<em>compensation</em>)。这也是最终一致性系统难用的地方。但不管怎么说，最终一致性仍然被认为是系统提供数据一致性的最低要求[1]。</p><h3 id="一致性的强弱关系"><a href="#一致性的强弱关系" class="headerlink" title="一致性的强弱关系"></a>一致性的强弱关系</h3><p>  在本文开头，我们提到过，通常人们把线性一致性称为「强一致性」，把最终一致性称为「弱一致性」。但对于指代特定的一种一致性模型来说，「强一致性」和「弱一致性」都不是一个好名字。因为强和弱，是个相对的概念。</p><p>  根据本文前面的讨论，从线性一致性，到顺序一致性，再到最终一致性，一致性的强度依次减弱。但是，一致性模型的强弱关系，其实是有更严格的定义的：</p><ul><li>当且仅当一个一致性模型所能接受的执行过程，都能被另一个一致性模型所接受时（前者的集合是后者集合的子集），我们就说前者是比后者「更强」(stronger) 的一致性模型。</li></ul><p>  按照这个更严格的强弱关系定义，线性一致性是比顺序一致性更强的一致性模型。这是因为，线性一致性比顺序一致性多了一个条件III，所以凡是满足线性一致性的执行过程，肯定也满足顺序一致性。</p><p>  我们仔细分析一下也能知道，一致性模型的强弱关系定义，是基于<em>safety</em>属性定义的。所以，将线性一致性或顺序一致性与最终一致性比较强弱，这并不是一个严格的做法。实际上，就像我们前一小节所讨论的，最终一致性在<em>safety</em>方面提供的保证为零，它是属于<em>liveness</em>的概念。一个系统可以在提供最终一致性的同时，也提供另外一种更强一点的带有<em>safety</em>属性的一致性（比如因果一致性）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  就如同我在之前另外一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261626&idx=1&sn=6b32cc7a7a62bee303a8d1c4952d9031&scene=21#wechat_redirect">漫谈分布式系统、拜占庭将军问题与区块链</a>》中所指出的，<strong>理解问题本身比知道问题的答案要重要的多</strong>。本文中，我们辨析了线性一致性、顺序一致性、最终一致性这些概念，以及他们的关系和区别。由此我们了解到了分布式系统的一些核心问题，但我们并未讨论怎么解决这些问题。比如，采用什么算法才能提供线性一致性；面对最终一致性的系统，应该怎样编程，包括怎样处理边界情况，等等。相对于理解问题本身而言，这些反而都是细节。</p><p>  在这个系列的下一篇文章中，我们将依然遵循这样的思路，具体解析因果一致性，以及分布式系统更深层的事件排序问题。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li>[1] Peter Bailis, Ali Ghodsi, “Eventual Consistency Today: Limitations, Extensions, and Beyond”, 2013.</li><li>[2] Werner Vogels, “Eventually Consistent”, 2008.</li><li>[3] Leslie Lamport, “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Progranm”, 1979.</li><li>[4] Mustaque Ahamad, Gil Neiger, James E. Burns, et al, “Causal Memory: Definitions, Implementation and Programming”, 1994.</li><li>[5] Maurice P. Herlihy, Jeannette M. Wing, “Linearizability: A Correctness Condition for Concurrent Objects”, 1990.</li><li>[6] Seth Gilbert, Nancy Lynch, “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web”, 2002.</li><li>[7] Peter Bailis, Ali Ghodsi, et al, “Bolt-on Causal Consistency”, 2013.</li><li>[8] Bowen Alpern, Fred B. Schneider, “Defining Liveness”, 1985.</li><li>[9] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li><li>[10] Prince Mahajan, Lorenzo Alvisi, Mike Dahlin, “Consistency, Availability, and Convergence”, 2011.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Z 字形变换</title>
    <link href="/2021/01/03/ZigzagConversion/"/>
    <url>/2021/01/03/ZigzagConversion/</url>
    
    <content type="html"><![CDATA[<h2 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a>Z 字形变换</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/03/ZigzagConversion/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/03/ZigzagConversion/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/submissions/">Z 字形变换</a></p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">L</span>   <span class="hljs-built_in">C</span>   <span class="hljs-built_in">I</span>   <span class="hljs-variable">R</span><br><span class="hljs-built_in">E</span> <span class="hljs-variable">T</span> <span class="hljs-built_in">O</span> <span class="hljs-built_in">E</span> <span class="hljs-variable">S</span> <span class="hljs-built_in">I</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">G</span><br><span class="hljs-built_in">E</span>   <span class="hljs-built_in">D</span>   <span class="hljs-variable">H</span>   <span class="hljs-built_in">N</span><br></code></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">convert</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> numRows</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>示例1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;LEETCODEISHIRING&quot;</span>, <span class="hljs-attr">numRows</span> = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">&quot;LCIRETOESIIGEDHN&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">输入<span class="hljs-operator">:</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LEETCODEISHIRING&quot;</span><span class="hljs-operator">,</span> <span class="hljs-variable">numRows</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出<span class="hljs-operator">:</span> <span class="hljs-string">&quot;LDREOEIIECIHNTSG&quot;</span><br>解释<span class="hljs-operator">:</span><br><br><span class="hljs-variable">L</span>     <span class="hljs-built_in">D</span>     <span class="hljs-variable">R</span><br><span class="hljs-built_in">E</span>   <span class="hljs-built_in">O</span> <span class="hljs-built_in">E</span>   <span class="hljs-built_in">I</span> <span class="hljs-built_in">I</span><br><span class="hljs-built_in">E</span> <span class="hljs-built_in">C</span>   <span class="hljs-built_in">I</span> <span class="hljs-variable">H</span>   <span class="hljs-built_in">N</span><br><span class="hljs-variable">T</span>     <span class="hljs-variable">S</span>     <span class="hljs-variable">G</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这一版性能不是很好，看了性能好的解法，是找出了z的排队规律，实现了性能提升。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ZigzagConversion &#123;<br><br>    <span class="hljs-built_in">public</span> static String convert(String s, <span class="hljs-type">int</span> numRows) &#123;<br>        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[][] result = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[numRows][s.length()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>                result[i][j] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> flip = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><br>            result[<span class="hljs-keyword">row</span>][col] = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (flip) &#123;<br>                <span class="hljs-keyword">row</span> <span class="hljs-comment">--;</span><br>                col ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">row</span> ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == numRows - <span class="hljs-number">1</span>) &#123;<br>                flip = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == <span class="hljs-number">0</span>) &#123;<br>                flip = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        StringBuilder stringBuilder = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (result[i][j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    stringBuilder.append(result[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        String s = &quot;LEETCODEISHIRING&quot;;<br>        <span class="hljs-type">int</span> numRows = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(convert(s, numRows));<br><br>        s = &quot;LEETCODEISHIRING&quot;;<br><br>        numRows = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(convert(s, numRows));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是一字排开，遍历字符串。还可以优化，不需要一个数组作为结果集，直接用拼接的方式承接结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——条分缕析分布式：到底什么是一致性？</title>
    <link href="/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——条分缕析分布式：到底什么是一致性？"><a href="#分布式系统原理——条分缕析分布式：到底什么是一致性？" class="headerlink" title="分布式系统原理——条分缕析分布式：到底什么是一致性？"></a>分布式系统原理——条分缕析分布式：到底什么是一致性？</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261779&idx=1&sn=9fb74c24f8863837d584a96536ba8189&scene=21#wechat_redirect">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p><p>  凡是做服务器开发的技术同学，估计都对分布式系统以及相关的理论感兴趣。而对于分布式理论，大家讨论的最多的恐怕就是「分布式一致性」问题了。然而，不管是学术界还是业界的发展历史上，对于「一致性」这个概念的理解，始终充满了混乱。</p><p>  如果你问一个技术同学，到底什么是分布式一致性，估计会得到五花八门的答案。这其中比较常见的说法可能是这样的：一致性就是多个服务器节点中的数据保持一致（至少百度百科上差不多就是这么说的）。而如果再讨论得深入一点，可能就会谈到所谓的分布式一致性协议，比如Paxos之类的；还有CAP定理，也跟「一致性」有关。</p><p>  但是，「一致性」这个词是非常有迷惑性的。如果用英文来表达的话，跟「一致性」有关的至少有两个词：<em>consistency</em>和<em>consensus</em>。它们经常都被翻译成「一致性」，这进一步加剧了这个概念被滥用的程度。为了接下来讨论方便，我们先简单地澄清一下：</p><ul><li>网上通常提到的诸如Paxos之类的分布式一致性协议，其实是<em>consensus</em>这个词。它如果被翻译成「共识」，可能会更好一些。为了表达清晰，本文后面在讨论<em>consensus</em>问题的时候，尽量使用「共识」这个词。</li><li>ACID或CAP里C，用的都是<em>consistency</em>这个词，但真实含义迥然不同。</li><li>此外，还经常会听到人们关于「强一致性」的说法，而且这种说法通常都会牵涉到CAP定理或者「分布式事务」的概念。「强一致性」与CAP定理确实关系密切，但与「分布式事务」的关系却不知从何而来。</li></ul><p>  下面，我们就对这些概念进行详细的解析。</p><h3 id="ACID中的一致性"><a href="#ACID中的一致性" class="headerlink" title="ACID中的一致性"></a>ACID中的一致性</h3><p>  ACID是数据库事务的四个特性，分别是原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)和持久性 (Durability)。</p><p>  我们现在关注的是其中的C，即一致性<em>Consistency</em>。它是什么意思呢？通俗地说，它指的是任何一个数据库事务的执行，都应该让整个数据库保持在「一致」的状态。那怎样的状态才算「一致」呢？举个例子，假设在银行账户之间进行转账。显然，「转账」这个操作应该确保在转账前后账户总额保持不变，这是任何一个转账操作必须要遵守的规定。现在假设要从账户A向账户B转账100元，于是我们启动了一个数据库事务。在这个事务中，可以先从账号A中减去100元，再往账户B中增加100元。这样的一个事务操作，满足了“转账前后账户总额保持不变”的规定，因此我们说：这个事务操作保持了数据库的「一致性」；同时，在这个事务执行前后，数据库都处于一种「一致」的状态。</p><p>  从上一段的描述中，我们容易看出：</p><ul><li>ACID中的「一致性」，是对于整个数据库的「一致」状态的维持。抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。</li><li>所谓状态是不是「一致」，其实是由业务层规定的。比如前面这个转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。</li></ul><p>  我们再来看一下，为了让事务总是能保持ACID的一致性，我们需要在实现上考虑哪些因素呢？</p><p>  至少两个方面需要考虑：一个是出错情况 (failure&#x2F;error)；一个是并发 (concurrency) 行为。</p><p>  首先，对于任何系统来说，错误都是在所难免的。而错误又可以细分为两类。</p><p>  第一类，事务本身的实现逻辑可能存在错误。比如，从账户A向账户B转账100元，在这个事务中，如果我们只从账号A中减去了100元，但忘记了往账户B中增加100元，那么这个事务就是错误的。显然，避免第一类错误，是保持一致性的前提，这需要应用层进行恰当的编码来保证。</p><p>  第二类，则是意想不到的各种软硬件错误。比如，还是从账户A向账户B转账100元，事务本身的实现逻辑没有问题，它先执行了从账号A中减去了100元，但在执行往账户B中增加100元之前，却发生了意想不到的错误，比如进程突然crash了，或是磁盘满了，或是网络突然不通了，或是其它任何可能的硬件错误。这时候，事务只执行了前一半，势必会破坏数据库整体状态的一致性。那怎么办呢？这其实就需要ACID中的A（原子性）来保障了。简言之，原子性保障了事务的执行要么全部成功，要么全部失败，而不允许出现“只执行了一半”这种“部分成功”的情况。</p><p>  其次，并发行为也可能会影响事务的一致性。在数据库系统中，并发行为体现在可能存在多个事务同时操作同一份数据的情况。还是拿前面转账的例子来说，假设有两个事务：事务1从账户A向账户B转账100元，事务2从账户A向账户C转账50元。如果两个事务先后顺序执行，自然没有问题。但如果两个事务同时执行了，那么可能会出现下面的执行序列（假设账号A的初始余额为x元）：</p><ol><li>&lt;事务1&gt;：读取账户A的余额，读到了x元；</li><li>&lt;事务2&gt;：读取账户A的余额，也读到了x元；</li><li>&lt;事务1&gt;：向账户A中写入(x-100)元；</li><li>&lt;事务2&gt;：向账户A中写入(x-50)元；</li><li>……</li></ol><p>  上面的执行过程，账户A中最后被写入的值是(x-50)元，显然是不对的（事务的一致性会被破坏）。如果两个转账的事务能正确执行完，那么账户A的余额应该是(x-150)元才对。</p><p>  这个并发的问题怎么处理呢？这就需要ACID中的I（隔离性）来保障了。什么是隔离性呢？它对于并发执行的多个事务进行合理的排序，保障了不同事务的执行互不干扰。换言之，隔离性这种特性，能够让并发执行的多个事务就好像是按照「先后顺序」执行的一样。</p><p>  经过上面的分析，现在关于ACID中的一致性，我们可以得到一些结论了：</p><ul><li>ACID中的一致性，是个很偏应用层的概念。这跟ACID中的原子性、隔离性和持久性有很大的不同。原子性、隔离性和持久性，都是数据库本身所提供的技术特性；而一致性，则是由特定的业务场景规定的。怪不得《Designing Data-Intensive Applications》[1]一书的作者在书中写道：”<em>The letter C doesn’t really belong in ACID</em>“。</li><li>要真正做到ACID中的一致性，它是要依赖数据库的原子性和隔离性的（应对错误和并发）。但是，就算数据库提供了所有你所需要的技术特性，也不一定能保证ACID的一致性。这还取决于你在应用层对于事务本身的实现逻辑是否正确无误。</li><li>最后，ACID中的一致性，甚至跟分布式都没什么直接关系。它跟分布式的唯一关联在于，在分布式环境下，它所依赖的数据库原子性和隔离性更难实现。</li></ul><p>  总之，ACID中的一致性，是一个非常特殊的概念。除了数据库事务处理，它很难扩展到其它场景，也跟分布式理论中的其它「一致性」概念没有什么关系。</p><h3 id="分布式事务与共识算法的关系"><a href="#分布式事务与共识算法的关系" class="headerlink" title="分布式事务与共识算法的关系"></a>分布式事务与共识算法的关系</h3><p>  先说共识问题 (consensus problem)。这是分布式系统中的一个十分基础而核心的问题，它表示如何在分布式系统中的多个节点之间就某事达成共识。</p><p>  网上通常提到的「分布式一致性协议」，或者「分布式一致性算法」，一般来说就是解决这里的共识问题的算法。用词的不同，是由于中英文翻译造成的。这些算法或协议，经常包含Paxos之类，但也可能包括两阶段提交协议(2PC)或三阶段提交协议(3PC)。</p><p>  人们既然经常将Paxos、2PC、3PC这些算法放在一起讨论，那么它们之间势必存在着某种相似性的。但这种相似性是怎么来的呢？我们仔细分析一下。Paxos，是解决共识问题的通用算法。它允许每个节点提出自己的提议(称为proposal），而Paxos算法能够不借助于任何中心化节点，保证各个节点之间对于提议最终达成一致。这里的proposal，是一个抽象的概念，它可以包含任何你想达成共识的数值。2PC和3PC，则是为了解决分布式事务提交问题的。</p><p>  这样从表面看起来，Paxos和2PC、3PC，这两类算法似乎没有多少相似性。2PC和3PC是跟分布式事务强相关的，而Paxos跟分布式事务没有什么特别的关系。为了分析更深层次的本质，我们探究一下2PC和3PC产生的背景。</p><p>  回到事务的概念。事务本来和分布式没什么直接关系的，就算在一个单节点的数据库上，要实现出事务的ACID特性，也不是那么容易的。只是，如同在前一章节的结尾我们提到的，在分布式环境下，事务的ACID特性更难实现。在前一章中我们主要关注ACID中的一致性，现在我们关注一下ACID中的原子性 (Atomicity)。</p><p>  ACID中的原子性，要求事务的执行要么全部成功，要么全部失败，而不允许出现“部分成功”的情况。在分布式事务中，这要求参与事务的所有节点，要么全部执行Commit操作，要么全部执行Abort操作。换句话说，参与事务的所有节点，需要在“执行Commit还是Abort”这一点上达成一致（其实就是共识）。这个问题在学术界被称为<strong>原子提交问题</strong>（Atomic Commitment Problem）[2]，而能够解决原子提交问题的算法，则被称为<strong>原子提交协议</strong>（Atomic Commitment Protocal，简称***ACP***）[3]。2PC和3PC，属于原子提交协议两种不同的具体实现。</p><p>  分析到这里，我们似乎发现了<strong>原子提交问题</strong>与<strong>共识问题</strong>的关联性：</p><ul><li>共识问题，解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。</li><li>原子提交问题，解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。</li><li>所以，原子提交问题是共识问题的一个特例。</li></ul><p>  这个酷似「三段论」式的论述，看起来“合情合理”。实际上，学术界在很长一段时间内都认为，分布式事务的原子提交问题是拜占庭将军问题（Byzantine Generals Problem）的一个退化形式[4]。什么是拜占庭将军问题呢？简单来说，它也是分布式系统的一种<strong>共识问题</strong>，而且是容错性要求最高的一种共识问题。我们在这里不展开讨论拜占庭将军问题了，如果你对细节感兴趣，欢迎阅读我之前的另一篇文章“<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261626&idx=1&sn=6b32cc7a7a62bee303a8d1c4952d9031&scene=21#wechat_redirect">漫谈分布式系统、拜占庭将军问题与区块链</a>”。总之，学术界以前的这种观点，跟我们刚刚分析得到的结论（原子提交问题是共识问题的一个特例）差不多。</p><p>  但是，分布式系统的诡异之处就要体现在这里，一些细节的不同，可能导致非常大的差异。如果你仔细看前文的描述，会发现这样一个细节：当我们描述共识问题的时候，我们说的是在<strong>多个节点</strong>之间达成共识；而当我们描述原子提交问题的时候，我们说的是在<strong>所有节点</strong>之间达成共识。这个细微的差别，让这两类问题，几乎变成了完全不同的问题（谁也替代不了谁）。</p><p>  从两类问题各自的应用场景来看，这个差异是合理的，也是容易理解的。以解决共识问题的Paxos协议为例，它只要求网络中的大部分节点达成共识就可以了，这样Paxos才能提供一定的容错性，只要网络中发生故障的节点不超过一半仍然能够正常工作（不会被阻塞）。然而，解决原子提交问题的2PC或3PC则不同。即使只有一个节点发生故障了，其它节点也不能擅自决策进行Commit操作。因为这样的话，这个事务就只是「部分地执行成功了」，违反了ACID原子性的要求。所以，原子提交协议必须保证在参与分布式事务的<strong>所有节点</strong>（包括故障的节点）上对于“执行Commit还是Abort”达成共识。</p><p>  故障的节点可能什么都做不了，如何参与达成共识呢？这里的意思是，等故障节点恢复之后，它的决策（Commit或是Abort）必须与其它所有节点保持一致。那么，这是不是意味着，只要有节点发生故障，原子提交协议就一定会阻塞呢？这里有点让人奇怪，答案是「不一定」。根源就在于Abort和Commit并不是对等的决策。假设有一个节点宕机了，其它节点大可以选择Abort决策（注意不能选择Commit），从而让整个事务Abort掉（没有被阻塞住，等待宕机的节点恢复）。等宕机的那个节点恢复了，它会发现相应的事务已经执行Abort了，那么它也按照Abort处理就好了。在这个过程中，参与分布式事务的<strong>所有节点</strong>（包括宕机的这个节点）对于“执行Commit还是Abort”也是达成了共识的（这个共识是Abort）。正是这些细微却至关重要的细节，让2PC和3PC这种看似简单的协议实现起来没有那么容易。</p><p>  论文[5]进一步澄清了这一问题，原子提交问题被抽象成一个新的一致性问题，称为uniform consensus问题，它是与通常的共识问题（consensus problem）不同的问题，而且是更难的问题。uniform consensus，要求所有节点（包括故障节点）都要达成共识；而consensus问题只关注没有发生故障的节点达成共识。</p><p>  至此，我们总结一下本章节的结论：</p><ul><li>共识问题（consensus problem），解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。它只关注没有发生故障的节点达成共识就可以了。</li><li>在分布式事务中，ACID中的原子性，引出了原子提交问题，它解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。原子提交问题属于uniform consensus问题，要求所有节点（包括故障节点）都要达成共识，是比consensus问题更难的一类问题。</li><li>Paxos和解决拜占庭将军问题的算法，解决的是consensus问题；2PC&#x2F;3PC，解决的是一个特定的uniform consensus问题。</li></ul><h3 id="CAP与线性一致性"><a href="#CAP与线性一致性" class="headerlink" title="CAP与线性一致性"></a>CAP与线性一致性</h3><p>  CAP的三个字母分别代表了分布式系统的三个特性：一致性（Consistency）、可用性（Availability）和分区容错性（Partition-tolerance）。而CAP定理指出：任何一个分布式系统只能同时满足三个特性中的两个。但是，这一描述曾经引发了非常多的误解。</p><p>  为了进一步展开讨论，我们先关注CAP中的C，也就是一致性。它是什么意思呢？在证明CAP定理的原始论文中[6]，C指的是<em>linearizable consistency</em>，也就是「线性一致性」。更精简的英文表达则是<em>linearizability</em>。</p><p>  这听起来可能稍微有点奇怪，但事实就是这样。<strong>线性一致性</strong>（<em>linearizability</em>）是CAP中的C的原始定义。而很多人在谈到CAP时，则会把这个C看成是<strong>强一致性</strong>（<em>strong consistency</em>）。这其实也没错，因为线性一致性的另一个名字，就是强一致性[1]。只不过，相比「线性一致性」来说，「强一致性」并不是一个好名字。因为，从这个名字你看不出来它真实的含义（到底「强」在哪？）。在下面的讨论中，我们统一使用线性一致性(<em>linearizability</em>)这个词汇。</p><p>  那线性一致性是什么意思呢？它精确的形式化定义[7]非常抽象，且难以理解。大体上是说，在一个并发执行的环境中，不同的操作之间可能是有严格的先后关系的（一个操作执行结束之后另一个操作才开始执行），也可能是并发执行的（一个操作还没执行结束，另一个操作就开始执行了）；如果能够把所有操作排列成一个「合法」的全局线性顺序，那么这些操作就是满足线性一致性的。当然，在这个重新排列的过程中，原来就存在的严格的先后关系，必须得以保持。</p><p>  但是，怎么才算合法呢？我们具体到一个存储系统中通过例子来说明。假如我们先往某个数据对象中写入了一个值（假设是1），然后在写入操作结束之后，我们再把这个数据对象读出来（在写入和读取操作之间没有其它的写入操作了）。如果我们发现读取到的值是1，那么就是合法的；而如果读出来的值不是1，那么就是非法的。再假设，我们又执行了一次读取操作，发现读出来的值仍然是1，那么就是合法的；否则就是非法的。也就是说，如果一个读操作已经读到了某个值，那么下一个对于同一个数据对象的读操作就必须读取到同样的值（除非在两次读操作之间还存在别的写入操作）。</p><p>  这些例子都比较容易理解，因为站在观察者的角度它们是符合逻辑的。因此，对于一个分布式存储系统来说，线性一致性的含义可以用一个具体的描述来取代：对于任何一个数据对象来说，<strong>系统表现得就像它只有一个副本一样</strong>[1]。“表现得像只有一个副本”，也就相当于满足了前面的「合法」条件。显然，如果系统对于每个数据对象真的只存一个副本，那么肯定是满足线性一致性的。但是单一副本不具有容错性，所以分布式存储系统一般都会对数据进行复制（replication），也就是保存多个副本。这时，在一个分布式多副本的存储系统中，要提供线性一致性的保证，就需要付出额外的成本了。</p><p>  网上对于CAP的一致性的通俗解释，通常有两种：</p><ol><li>一致性是指：在分布式系统完成某写操作后的任何读操作，都应该获取到该写操作写入的那个最新的值。显然，如果系统“表现得像只有一个副本”一样，这个描述是成立的。不过这只是描述了线性一致性的一个特例而已，有以偏概全的嫌疑。</li><li>一致性是指：保持所有节点在同一个时刻具有相同的、逻辑一致的数据。显然这种解释并不是从观察者的角度来描述的，而是试图从系统内部的行为（内部实现）来描述的。「所有节点」，可能指的是「所有副本」；至于“在同一个时刻具有相同的、逻辑一致的数据”这个说法，则似乎离线性一致性的本来含义偏离太远了。从逻辑上说，“表现得像只有一个副本”，并不一定需要系统“在同一个时刻具有相同的、逻辑一致的数据”。线性一致性可能有很多种实现方式，而这种解释规定了一种具体的系统实现，同样有以偏概全的嫌疑。</li></ol><p>  我们前面提到，线性一致性，也被称为强一致性。之所以这么说，大概是因为线性一致性要求多个副本上的数据必须保持如此之「强」的一致性，以至于“让系统表现得就像只有一个副本”。</p><p>  另外，网上的资料提到强一致性的时候，还有可能会关联到分布式事务上面，比如2PC&#x2F;3PC这些原子提交协议。但把它们关联到一起的说法，其深层次含义到底是什么，只能靠猜测。分布式事务处理的并不是同一个数据对象的多个副本的问题，而指的是将针对多个数据对象的各种操作组合起来，提供ACID的特性。将分布式事务看成是强一致性的保证，猜测可能实际上指的就是ACID的原子性。总之，「强一致性」这个词很容易产生误解，所以建议谨慎使用。</p><p>  在历史上，CAP定理具有巨大的知名度，但它实际的影响力却没有想象的那么大。随着分布式理论的发展，我们逐渐认识到，CAP并不是一个「大一统」的理论，远不能涵盖分布式系统设计中方方面面的问题。相反，CAP引发了很多误解和理解上的混乱（细节不讨论了）。因此，可以预见到，未来CAP定理的影响将会进一步被削弱。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本文我们辨析了分布式系统中的诸多被称为「一致性」的概念。但这个话题还没有完，我将在下一篇文章中跟大家继续讨论顺序一致性、线性一致性、最终一致性等概念。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li>[1] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li><li>[2] Vassos Hadzilacos, “On The Relationship Between The Atomic Commitment And Consensus Problems”, 1990.</li><li>[3] Philip A. Bernstein, Vassos Hadzilacos, Nathan Goodman, 《Concurrency Control And Recovery in Database Systems》, 1987.</li><li>[4] Jim Gray, “A Comparison Of The Byzantine Agreement Problem And The Transaction Commit Problem”, 1988.</li><li>[5] Bernadette Charron-Bost, André Schiper, “Uniform Consensus Is Harder Than Consensus”, 2001.</li><li>[6] Seth Gilbert, Nancy Lynch, “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web”, 2002.</li><li>[7] MAURICE P. HERLIHY, JEANNETTE M. WING, “Linearizability: A Correctness Condition for Concurrent Objects”, 1990.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestPalindrome</title>
    <link href="/2021/01/02/LongestPalindrome/"/>
    <url>/2021/01/02/LongestPalindrome/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p>示例 1:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bab&quot;</span><br>注意<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;aba&quot;</span> 也是一个有效答案。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>1、下面第一版自己写的，比较粗糙</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LongestPalindrome &#123;<br><br>    <span class="hljs-built_in">public</span> static String longestPalindrome(String s) &#123;<br><br>        <span class="hljs-keyword">if</span> (s.length() &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s.length() - <span class="hljs-number">1</span>; j &gt; i; j <span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-keyword">if</span> (checkPalindrome(s.substring(i, j + <span class="hljs-number">1</span>))) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>                        start = i;<br>                        end = j;<br>                        maxLength = j - i + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &lt;= maxLength) &#123;<br>                    break;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s.length() - i &lt;= maxLength) &#123;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> checkPalindrome(String s) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(s.length() - i - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        String s = &quot;bbabba&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;cbbd&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;bb&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bbabb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是多次循环判断找回文。</li></ul><p>2、第一版耗时太久，下面第二版就优化了一下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LongestPalindrome &#123;<br><br>    <span class="hljs-built_in">public</span> static String longestPalindrome(String s) &#123;<br><br>        <span class="hljs-keyword">if</span> (s.length() &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; s.length()) &#123;<br>            <span class="hljs-type">int</span> left = <span class="hljs-keyword">index</span>, right = <span class="hljs-keyword">index</span>;<br>            // 先找到字符一样的字符串<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; s.length() - <span class="hljs-number">1</span> &amp;&amp; s.charAt(<span class="hljs-keyword">index</span>) == s.charAt(<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">index</span> ++;<br>                right ++;<br>            &#125;<br>            // 从某个点开始，向两边扩散寻找最长串<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left <span class="hljs-comment">--;</span><br>                right ++;<br>            &#125;<br>            left ++;<br>            <br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>                maxLength = right - left +<span class="hljs-number">1</span>;right <span class="hljs-comment">--;</span><br>                start = left;<br>            &#125;<br>            <span class="hljs-keyword">index</span> ++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">start</span> + maxLength);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        String s = &quot;bbabba&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;cbbd&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;bb&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bbabb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是分两种情况，第一种，找最长相同字符串，第二种，就是从某个字符开始，向两边扩散，找回文。当然这两种是可以放在一起的，如代码。这样就解决了双重循环找回文的次数，耗时当然少了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FindMedianSortedArrays</title>
    <link href="/2021/01/01/FindMedianSortedArrays/"/>
    <url>/2021/01/01/FindMedianSortedArrays/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0.00000</span><br></code></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = []<br>输出：<span class="hljs-number">2.00000</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>1、下面第一版自己写的，比较粗糙</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> FindMedianSortedArrays &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">double</span> findMedianSortedArrays(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span> [] nums3 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nums1.length + nums2.length];<br>        <span class="hljs-keyword">if</span> (nums2.length == <span class="hljs-number">0</span> &amp;&amp; nums1.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums1.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> getMidNum(nums2);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums2.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> getMidNum(nums1);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; ;) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;<br>                nums3[k] = nums1[i];<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;<br>                nums3[k] = nums2[j];<br>                j++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] == nums2[j]) &#123;<br>                nums3[k] = nums2[j];<br>                j++;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == nums1.length) &#123;<br>                <span class="hljs-keyword">for</span> (; j &lt; nums2.length; j++, k++) &#123;<br>                    nums3[k] = nums2[j];<br>                &#125;<br>                break;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == nums2.length) &#123;<br>                <span class="hljs-keyword">for</span> (; i &lt; nums1.length; i++, k++) &#123;<br>                    nums3[k] = nums1[i];<br>                &#125;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(nums3));<br>        <span class="hljs-keyword">return</span> getMidNum(nums3);<br>    &#125;<br><br>    private static <span class="hljs-type">double</span> getMidNum(<span class="hljs-type">int</span>[] nums3) &#123;<br>        <span class="hljs-keyword">if</span>(nums3.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums3[(nums3.length - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (nums3[(nums3.length - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>] + nums3[(nums3.length)/<span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, nums2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums1, nums2));<br>        <span class="hljs-type">int</span>[] nums3 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, nums4 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums3, nums4));<br>        <span class="hljs-type">int</span>[] nums5 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;, nums6 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums5, nums6));<br>        <span class="hljs-type">int</span>[] nums7 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;, nums8 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums7, nums8));<br>        <span class="hljs-type">int</span>[] nums9 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>&#125;, nums10 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums9, nums10));<br>        <span class="hljs-type">int</span>[] nums11 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;, nums12 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums11, nums12));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-number">2.0</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-number">2.5</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><span class="hljs-number">0.0</span><br><span class="hljs-number">1.0</span><br><span class="hljs-number">2.0</span><br>[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><span class="hljs-number">0.0</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是将两个数组合成一个数组，但是考虑几种情况，然后做处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestSubstringWithoutRepeatingCharacters</title>
    <link href="/2020/12/29/LongestSubstringWithoutRepeatingCharacters/"/>
    <url>/2020/12/29/LongestSubstringWithoutRepeatingCharacters/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LongestSubstringWithoutRepeatingCharacters &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> lengthOfLongestSubstring(String s) &#123;<br>        // 记录字符上一次出现的位置<br>        <span class="hljs-type">int</span>[] last = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>            last[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n = s.length();<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; // 窗口开始位置<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            // 字符转数字<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = s.charAt(i);<br>            // 最主要的就是这一行，找到起始位置：分两种情况：<br>            // 一直都是不同的字符，那<span class="hljs-keyword">start</span>不变<br>            // 遇到重复的，也分两种情况，一种是和起始重复，从重复的字符+<span class="hljs-number">1</span>位<br>            // 一种是和后面的字符重复，也是从重复的字符+<span class="hljs-number">1</span>位<br>            start = Math.max(<span class="hljs-keyword">start</span>, last[<span class="hljs-keyword">index</span>] + <span class="hljs-number">1</span>);<br>            // 记录最长串长度<br>            result = Math.max(result, i - <span class="hljs-keyword">start</span> + <span class="hljs-number">1</span>);<br>            // 记录最新的该字符所在位置<br>            last[<span class="hljs-keyword">index</span>] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLongestSubstring(&quot;abcabcbb&quot;));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLongestSubstring(&quot;bbbbb&quot;));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLongestSubstring(&quot;cd&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>1<br>2<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>找到起始位置：分两种情况：一直都是不同的字符，那start不变；遇到重复的，也分两种情况，一种是和起始重复，从起始重复的字符+1位，一种是和后面的字符重复，也是从后面的字符重复的字符+1位。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——使用场景</title>
    <link href="/2020/10/30/Zookeeper%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2020/10/30/Zookeeper%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper——使用场景"><a href="#Zookeeper——使用场景" class="headerlink" title="Zookeeper——使用场景"></a>Zookeeper——使用场景</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  大致来说，zookeeper 的使用场景如下，举几个简单的：</p><ul><li>分布式协调</li><li>分布式锁</li><li>元数据&#x2F;配置信息管理</li><li>HA 高可用性</li></ul><h3 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h3><p>  这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上<strong>对某个节点的值注册个监听器</strong>，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-distributed-coordination.png" alt="zookeeper-distributed-coordination"></a></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>  举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-distributed-lock-demo.png" alt="zookeeper-distributed-lock-demo"></a></p><h3 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h3><p>  zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-meta-data-manage.png" alt="zookeeper-meta-data-manage"></a></p><h3 id="HA-高可用性"><a href="#HA-高可用性" class="headerlink" title="HA 高可用性"></a>HA 高可用性</h3><p>  这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个<strong>重要进程一般会做主备</strong>两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-active-standby.png" alt="zookeeper-active-standby"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md">1. zookeeper-application-scenarios</a></p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——CAP定理</title>
    <link href="/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CAP%E5%AE%9A%E7%90%86/"/>
    <url>/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CAP%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——CAP定理"><a href="#分布式系统原理——CAP定理" class="headerlink" title="分布式系统原理——CAP定理"></a>分布式系统原理——CAP定理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-cap.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="分布式系统-CAP-定理-P-代表什么含义"><a href="#分布式系统-CAP-定理-P-代表什么含义" class="headerlink" title="分布式系统 CAP 定理 P 代表什么含义"></a>分布式系统 CAP 定理 P 代表什么含义</h3><p>  作者之前在看 CAP 定理时抱有很大的疑惑，CAP 定理的定义是指在分布式系统中三者只能满足其二，也就是存在分布式 CA 系统的。作者在网络上查阅了很多关于 CAP 文章，虽然这些文章对于 P 的解释五花八门，但总结下来这些观点大多都是指 P 是不可缺少的，也就是说在分布式系统只能是 AP 或者 CP，这种理论与我之前所认识的理论（存在分布式 CA 系统）是冲突的，所以才有了疑惑。</p><blockquote><p>这个定理起源于加州大学柏克莱分校（University of California, Berkeley）的计算机科学家埃里克·布鲁尔在 2000 年的分布式计算原理研讨会（PODC）上提出的一个猜想。 在 2002 年，麻省理工学院（MIT）的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为一个定理。</p></blockquote><h4 id="什么是-CAP-定理（CAP-theorem）"><a href="#什么是-CAP-定理（CAP-theorem）" class="headerlink" title="什么是 CAP 定理（CAP theorem）"></a>什么是 CAP 定理（CAP theorem）</h4><p>  在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li><li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）</li></ul><h4 id="分区容错性（Partition-tolerance）"><a href="#分区容错性（Partition-tolerance）" class="headerlink" title="分区容错性（Partition tolerance）"></a>分区容错性（Partition tolerance）</h4><p>  理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。</p><ul><li>P 指的是分区容错性，分区现象产生后需要容错，容错是指在 A 与 C 之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况） 本身就没有分区 ，既然没有分区则就更没有分区容错性 P。</li><li>无论我设计的系统是 AP 还是 CP 系统如果没有出现不一致不可用。 则该系统就处于 CA 状态</li><li>P 的体现前提是得有分区情况存在</li></ul><blockquote><p>文章来源：<a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">维基百科 CAP 定理</a></p></blockquote><h3 id="几个常用的-CAP-框架对比"><a href="#几个常用的-CAP-框架对比" class="headerlink" title="几个常用的 CAP 框架对比"></a>几个常用的 CAP 框架对比</h3><table><thead><tr><th>框架</th><th>所属</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td></tr><tr><td>Zookeeper</td><td>CP</td></tr><tr><td>Consul</td><td>CP</td></tr></tbody></table><h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><blockquote><p>Eureka 保证了可用性，实现最终一致性。</p></blockquote><p>  Eureka 所有节点都是平等的所有数据都是相同的，且 Eureka 可以相互交叉注册。<br>  Eureka client 使用内置轮询负载均衡器去注册，有一个检测间隔时间，如果在一定时间内没有收到心跳，才会移除该节点注册信息；如果客户端发现当前 Eureka 不可用，会切换到其他的节点，如果所有的 Eureka 都跪了，Eureka client 会使用最后一次数据作为本地缓存；所以以上的每种设计都是他不具备<code>一致性</code>的特性。</p><p>  注意：因为 Eureka AP 的特性和请求间隔同步机制，在服务更新时候一般会手动通过 Eureka 的 api 把当前服务状态设置为<code>offline</code>，并等待 2 个同步间隔后重新启动，这样就能保证服务更新节点对整体系统的影响。</p><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><blockquote><p>强一致性</p></blockquote><p>  Zookeeper 在选举 leader 时会停止服务，只有成功选举 leader 成功后才能提供服务，选举时间较长；内部使用 paxos 选举投票机制，只有获取半数以上的投票才能成为 leader，否则重新投票，所以部署的时候最好集群节点不小于 3 的奇数个（但是谁能保证跪掉后节点也是基数个呢）；Zookeeper 健康检查一般是使用 tcp 长链接，在内部网络抖动时或者对应节点阻塞时候都会变成不可用，这里还是比较危险的。</p><h4 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h4><p>  和 Zookeeper 一样数据 CP。</p><p>  Consul 注册时候只有过半的节点都写入成功才认为注册成功；leader 挂掉时，重新选举期间整个 Consul 不可用,保证了强一致性但牺牲了可用性。<br>  有很多 blog 说 Consul 属于 ap，官方已经确认他为 CP 机制 原文地址：<a href="https://www.consul.io/docs/intro/vs/serf%E3%80%82">https://www.consul.io/docs/intro/vs/serf。</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-cap.md">1. distributed-system-cap</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——5. 分布式事务</title>
    <link href="/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%945.%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%945.%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——5-分布式事务"><a href="#分布式系统设计——5-分布式事务" class="headerlink" title="分布式系统设计——5. 分布式事务"></a>分布式系统设计——5. 分布式事务</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-transaction.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。</p><p>  分布式事务的实现主要有以下 6 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>SAGA 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="两阶段提交方案-XA-方案"><a href="#两阶段提交方案-XA-方案" class="headerlink" title="两阶段提交方案&#x2F;XA 方案"></a>两阶段提交方案&#x2F;XA 方案</h3><p>  所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>  这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>  这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>  如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>  如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-XA.png" alt="distributed-transacion-XA"></a></p><h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p>  TCC 的全称是： <code>Try</code> 、 <code>Confirm</code> 、 <code>Cancel</code> 。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>  这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个<strong>事务回滚</strong>实际上是<strong>严重依赖于你自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大，非常之恶心。</p><p>  比如说我们，一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>  而且最好是你的各个业务执行的时间都比较短。</p><p>  但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-TCC.png" alt="distributed-transacion-TCC"></a></p><h3 id="Saga-方案"><a href="#Saga-方案" class="headerlink" title="Saga 方案"></a>Saga 方案</h3><p>  金融核心等业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而对于更多的金融核心以上的业务系统 往往会选择补偿事务，补偿事务处理在 30 多年前就提出了 Saga 理论，随着微服务的发展，近些年才逐步受到大家的关注。目前业界比较公认的是采用 Saga 作为长事务的解决方案。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>  业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。下图左侧是正常的事务流程，当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程，反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-saga.png" alt="distributed-transacion-TCC"></a></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>  对于一致性要求高、短流程、并发高 的场景，如：金融核心系统，会优先考虑 TCC 方案。而在另外一些场景下，我们并不需要这么强的一致性，只需要保证最终一致性即可。</p><p>  比如 很多金融核心以上的业务（渠道层、产品层、系统集成层），这些系统的特点是最终一致即可、流程多、流程长、还可能要调用其它公司的服务。这种情况如果选择 TCC 方案开发的话，一来成本高，二来无法要求其它公司的服务也遵循 TCC 模式。同时流程长，事务边界太长，加锁时间长，也会影响并发性能。</p><p>  所以 Saga 模式的适用场景是：</p><ul><li>业务流程长、业务流程多；</li><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>一阶段提交本地事务，无锁，高性能；</li><li>参与者可异步执行，高吞吐；</li><li>补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不保证事务的隔离性。</li></ul><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>  本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>  这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>  这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-local-message-table.png" alt="distributed-transaction-local-message-table"></a></p><h3 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h3><p>  这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>  大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-reliable-message.png" alt="distributed-transaction-reliable-message"></a></p><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>  这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><h3 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h3><p>  如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>  你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>  友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>  当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-transaction.md">1. distributed-transaction</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——6. Dubbo服务治理</title>
    <link href="/2020/10/25/Dubbo%E2%80%94%E2%80%946.%20Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <url>/2020/10/25/Dubbo%E2%80%94%E2%80%946.%20Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——6-Dubbo服务治理"><a href="#Dubbo——6-Dubbo服务治理" class="headerlink" title="Dubbo——6. Dubbo服务治理"></a>Dubbo——6. Dubbo服务治理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  <strong>服务治理</strong>，这个问题如果问你，其实就是看看你有没有<strong>服务治理</strong>的思想，因为这个是做过复杂微服务的人肯定会遇到的一个问题。</p><p>  <strong>服务降级</strong>，这个是涉及到复杂分布式系统中必备的一个话题，因为分布式系统互相来回调用，任何一个系统故障了，你不降级，直接就全盘崩溃？那就太坑爹了吧。</p><p>  <strong>失败重试</strong>，分布式系统中网络请求如此频繁，要是因为网络问题不小心失败了一次，是不是要重试？</p><p>  <strong>超时重试</strong>，跟上面一样，如果不小心网络慢一点，超时了，如何重试？</p><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><h4 id="1-调用链路自动生成"><a href="#1-调用链路自动生成" class="headerlink" title="1. 调用链路自动生成"></a>1. 调用链路自动生成</h4><p>  一个大型的分布式系统，或者说是用现在流行的微服务架构来说吧，<strong>分布式系统由大量的服务组成</strong>。那么这些服务之间互相是如何调用的？调用链路是啥？说实话，几乎到后面没人搞的清楚了，因为服务实在太多了，可能几百个甚至几千个服务。</p><p>  那就需要基于 dubbo 做的分布式系统中，对各个服务之间的调用自动记录下来，然后自动将<strong>各个服务之间的依赖关系和调用链路生成出来</strong>，做成一张图，显示出来，大家才可以看到对吧。</p><p><a href="https://yangtzeshore.github.io/2020/10/25/Dubbo-6-Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-service-invoke-road.png" alt="dubbo-service-invoke-road"></a></p><h4 id="2-服务访问压力以及时长统计"><a href="#2-服务访问压力以及时长统计" class="headerlink" title="2. 服务访问压力以及时长统计"></a>2. 服务访问压力以及时长统计</h4><p>  需要自动统计<strong>各个接口和服务之间的调用次数以及访问延时</strong>，而且要分成两个级别。</p><ul><li>一个级别是接口粒度，就是每个服务的每个接口每天被调用多少次，TP50&#x2F;TP90&#x2F;TP99，三个档次的请求延时分别是多少；</li><li>第二个级别是从源头入口开始，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的 TP50&#x2F;TP90&#x2F;TP99，分别是多少。</li></ul><p>  这些东西都搞定了之后，后面才可以来看当前系统的压力主要在哪里，如何来扩容和优化啊。</p><h4 id="3-其它"><a href="#3-其它" class="headerlink" title="3. 其它"></a>3. 其它</h4><ul><li>服务分层（避免循环依赖）</li><li>调用链路失败监控和报警</li><li>服务鉴权</li><li>每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）</li></ul><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>  比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。</p><p>  举个栗子，我们有接口 <code>HelloService</code> 。 <code>HelloServiceImpl</code> 有该接口的具体实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">public interface HelloService &#123;<br>   void sayHello();<br>&#125;<br>public class HelloServiceImpl implements HelloService &#123;<br>    public void sayHello() &#123;<br>        System.out.println(&quot;hello world......&quot;);<br>    &#125;<br>&#125;<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo-provider&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.zhss.service.HelloService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;helloServiceImpl&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10000&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zhss.service.HelloServiceImpl&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo-consumer&quot;</span>  /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fooService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.test.service.FooService&quot;</span>  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10000&quot;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;return null&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  我们调用接口失败的时候，可以通过 <code>mock</code> 统一返回 null。</p><p>  mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+ <code>Mock</code> ” 后缀。然后在 Mock 类里实现自己的降级逻辑。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HelloServiceMock</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">HelloService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> sayHello() &#123;<br>        <span class="hljs-comment">// 降级逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="失败重试和超时重试"><a href="#失败重试和超时重试" class="headerlink" title="失败重试和超时重试"></a>失败重试和超时重试</h3><p>  所谓失败重试，就是 consumer 调用 provider 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。配置如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;dubbo:reference <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;xxxx&quot;</span> <span class="hljs-attribute">interface</span>=<span class="hljs-string">&quot;xx&quot;</span> <span class="hljs-attribute">check</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attribute">async</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attribute">retries</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attribute">timeout</span>=<span class="hljs-string">&quot;2000&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>  举个栗子。</p><p>  某个服务的接口，要耗费 5s，你这边不能干等着，你这边配置了 timeout 之后，我等待 2s，还没返回，我直接就撤了，不能干等你。</p><p>  可以结合你们公司具体的场景来说说你是怎么设置这些参数的：</p><ul><li><code>timeout</code> ：一般设置为 <code>200ms</code> ，我们认为不能超过 <code>200ms</code> 还没返回。</li><li><code>retries</code> ：设置 retries，一般是在读请求的时候，比如你要查询个数据，你可以设置个 retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">1. dubbo-service-management</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——5. Dubbo的 spi 思想</title>
    <link href="/2020/10/25/Dubbo%E2%80%94%E2%80%945.%20Dubbo%E7%9A%84%20spi%20%E6%80%9D%E6%83%B3/"/>
    <url>/2020/10/25/Dubbo%E2%80%94%E2%80%945.%20Dubbo%E7%9A%84%20spi%20%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——5-Dubbo的-spi-思想"><a href="#Dubbo——5-Dubbo的-spi-思想" class="headerlink" title="Dubbo——5. Dubbo的 spi 思想"></a>Dubbo——5. Dubbo的 spi 思想</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-spi.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="spi-是啥？"><a href="#spi-是啥？" class="headerlink" title="spi 是啥？"></a>spi 是啥？</h3><p>  spi，简单来说，就是 <code>service provider interface</code> ，说白了是什么意思呢，比如你有个接口，现在这个接口有 3 个实现类，那么在系统运行的时候对这个接口到底选择哪个实现类呢？这就需要 spi 了，需要<strong>根据指定的配置</strong>或者是<strong>默认的配置</strong>，去<strong>找到对应的实现类</strong>加载进来，然后用这个实现类的实例对象。</p><p>  举个栗子。</p><p>  你有一个接口 A。A1&#x2F;A2&#x2F;A3 分别是接口 A 的不同实现。你通过配置 <code>接口 A = 实现 A2</code> ，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p><p>  spi 机制一般用在哪儿？<strong>插件扩展的场景</strong>，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 spi 思想就用上了。</p><h3 id="Java-spi-思想的体现"><a href="#Java-spi-思想的体现" class="headerlink" title="Java spi 思想的体现"></a>Java spi 思想的体现</h3><p>  spi 经典的思想体现，大家平时都在用，比如说 jdbc。</p><p>  Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。</p><p>  但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要<strong>根据自己使用的数据库</strong>，比如 mysql，你就将 <code>mysql-jdbc-connector.jar</code> 引入进来；oracle，你就将 <code>oracle-jdbc-connector.jar</code> 引入进来。</p><p>  在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。</p><h3 id="dubbo-的-spi-思想"><a href="#dubbo-的-spi-思想" class="headerlink" title="dubbo 的 spi 思想"></a>dubbo 的 spi 思想</h3><p>  dubbo 也用了 spi 思想，不过没有用 jdk 的 spi 机制，是自己实现的一套 spi 机制。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Protocol protocol <span class="hljs-operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>  Protocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。</p><p>  它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。</p><p>  上面那行代码就是 dubbo 里大量使用的，就是对很多组件，都是保留一个接口和多个实现，然后在系统运行的时候动态根据配置去找到对应的实现类。如果你没配置，那就走默认的实现好了，没问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI(&quot;dubbo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Protocol</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultPort</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Adaptive</span><br>    &lt;T&gt; Exporter&lt;T&gt; <span class="hljs-title function_">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException;<br><br>    <span class="hljs-meta">@Adaptive</span><br>    &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  在 dubbo 自己的 jar 里，在 <code>/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code> 文件中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dubbo=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.DubboProtocol</span><br>http=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.HttpProtocol</span><br>hessian=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.hessian</span>.HessianProtocol<br></code></pre></td></tr></table></figure><p>  所以说，这就看到了 dubbo 的 spi 机制默认是怎么玩儿的了，其实就是 Protocol 接口， <code>@SPI(&quot;dubbo&quot;)</code> 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 <code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</code> 。</p><p>  如果想要动态替换掉默认的实现类，需要使用 <code>@Adaptive</code> 接口，Protocol 接口中，有两个方法加了 <code>@Adaptive</code> 注解，就是说那俩接口会被代理实现。</p><p>  啥意思呢？</p><p>  比如这个 Protocol 接口搞了俩 <code>@Adaptive</code> 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。</p><h3 id="如何自己扩展-dubbo-中的组件"><a href="#如何自己扩展-dubbo-中的组件" class="headerlink" title="如何自己扩展 dubbo 中的组件"></a>如何自己扩展 dubbo 中的组件</h3><p>  下面来说说怎么来自己扩展 dubbo 中的组件。</p><p>  自己写个工程，要是那种可以打成 jar 包的，里面的 <code>src/main/resources</code> 目录下，搞一个 <code>META-INF/services</code> ，里面放个文件叫： <code>com.alibaba.dubbo.rpc.Protocol</code> ，文件里搞一个 <code>my=com.bingo.MyProtocol</code> 。自己把 jar 弄到 nexus 私服里去。</p><p>  然后自己搞一个 <code>dubbo provider</code> 工程，在这个工程里面依赖你自己搞的那个 jar，然后在 spring 配置文件里给个配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;dubbo:protocol <span class="hljs-attribute">name</span>=”my” <span class="hljs-attribute">port</span>=”20000” /&gt;<br></code></pre></td></tr></table></figure><p>  provider 启动的时候，就会加载到我们 jar 包里的 <code>my=com.bingo.MyProtocol</code> 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了，这个就是简单说明一下，你通过上述方式，可以替换掉大量的 dubbo 内部的组件，就是扔个你自己的 jar 包，然后配置一下即可。</p><p>[<img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-spi.png" alt="dubbo-spi">](<a href="https://yangtzeshore.github.io/2020/10/25/Dubbo-5-Dubbo%E7%9A%84">https://yangtzeshore.github.io/2020/10/25/Dubbo-5-Dubbo的</a> spi 思想&#x2F;)</p><p>  dubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 <code>key=实现类</code> 。</p><p>  然后对于对应的组件，类似 <code>&lt;dubbo:protocol&gt;</code> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-spi.md">1. dubbo-spi</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——4. 分布式锁</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%944.%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%944.%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——4-分布式锁"><a href="#分布式系统设计——4-分布式锁" class="headerlink" title="分布式系统设计——4. 分布式锁"></a>分布式系统设计——4. 分布式锁</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-lock-redis-vs-zookeeper.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h3><p>  官方叫做 <code>RedLock</code> 算法，是 Redis 官方支持的分布式锁算法。</p><p>  这个分布式锁有 3 个重要的考量点：</p><ul><li>互斥（只能有一个客户端获取锁）</li><li>不能死锁</li><li>容错（只要大部分 Redis 节点创建了这把锁就可以）</li></ul><h4 id="Redis-最普通的分布式锁"><a href="#Redis-最普通的分布式锁" class="headerlink" title="Redis 最普通的分布式锁"></a>Redis 最普通的分布式锁</h4><p>  第一个最普通的实现方式，就是在 Redis 里使用 <code>SET key value [EX seconds] [PX milliseconds] NX</code> 创建一个 key，这样就算加锁。其中：</p><ul><li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功，如果此时 redis 中存在这个 <code>key</code>，那么设置失败，返回 <code>nil</code>。</li><li><code>EX seconds</code>：设置 <code>key</code> 的过期时间，精确到秒级。意思是 <code>seconds</code> 秒后锁自动释放，别人创建的时候如果发现已经有了就不能加锁了。</li><li><code>PX milliseconds</code>：同样是设置 <code>key</code> 的过期时间，精确到毫秒级。</li></ul><p>  比如执行以下命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> resource_name <span class="hljs-comment">my_random_value PX 30000 NX</span><br></code></pre></td></tr></table></figure><p>  释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(&quot;get&quot;,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(&quot;del&quot;,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p><p>  但是这样是肯定不行的。因为如果是普通的 Redis 单实例，那就是单点故障。或者是 Redis 普通主从，那 Redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p><h4 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h4><p>  这个场景是假设有一个 Redis cluster，有 5 个 Redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code> ；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li></ol><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/redis-redlock.png" alt="redis-redlock"></a></p><p>  <a href="https://redis.io/">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a> 。</p><h3 id="zk-分布式锁"><a href="#zk-分布式锁" class="headerlink" title="zk 分布式锁"></a>zk 分布式锁</h3><p>  zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能<strong>注册个监听器</strong>监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ZooKeeperSession</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZooKeeperSession</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CountDownLatch connectedSemaphore = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">private</span> ZooKeeper zookeeper;<br>    <span class="hljs-keyword">private</span> CountDownLatch latch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZooKeeperSession</span>()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.zookeeper = <span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;</span>, <span class="hljs-number">50000</span>, <span class="hljs-keyword">new</span> ZooKeeperWatcher());<br>            <span class="hljs-keyword">try</span> &#123;<br>                connectedSemaphore.<span class="hljs-keyword">await</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;ZooKeeper session established......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取分布式锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param productId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">acquireDistributedLock</span>(<span class="hljs-params">Long productId</span>)</span> &#123;<br>        String path = <span class="hljs-string">&quot;/product-lock-&quot;</span> + productId;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            zookeeper.create(path, <span class="hljs-string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span><br>                    Stat stat = zk.exists(path, <span class="hljs-literal">true</span>);<br><br>                    <span class="hljs-keyword">if</span> (stat != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">this</span>.latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>                        <span class="hljs-keyword">this</span>.latch.<span class="hljs-keyword">await</span>(waitTime, TimeUnit.MILLISECONDS);<br>                        <span class="hljs-keyword">this</span>.latch = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    zookeeper.create(path, <span class="hljs-string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ee) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放掉一个分布式锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param productId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseDistributedLock</span>(<span class="hljs-params">Long productId</span>)</span> &#123;<br>        String path = <span class="hljs-string">&quot;/product-lock-&quot;</span> + productId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zookeeper.delete(path, <span class="hljs-number">-1</span>);<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;release the lock for product[id=&quot;</span> + productId + <span class="hljs-string">&quot;]......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建立 zk session 的 watcher</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZooKeeperWatcher</span> <span class="hljs-title">implements</span> <span class="hljs-title">Watcher</span> &#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span>(<span class="hljs-params">WatchedEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Receive watched event: &quot;</span> + <span class="hljs-keyword">event</span>.getState());<br><br>            <span class="hljs-keyword">if</span> (KeeperState.SyncConnected == <span class="hljs-keyword">event</span>.getState()) &#123;<br>                connectedSemaphore.countDown();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.latch != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.latch.countDown();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装单例的静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ZooKeeperSession instance;<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            instance = <span class="hljs-keyword">new</span> ZooKeeperSession();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZooKeeperSession <span class="hljs-title">getInstance</span>()</span> &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取单例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZooKeeperSession <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Singleton.getInstance();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化单例的便捷方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        getInstance();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以采用另一种方式，创建临时顺序节点：</p><p>  如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 ZooKeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooKeeperDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ZooKeeper zk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">locksRoot</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/locks&quot;</span>;<br>    <span class="hljs-keyword">private</span> String productId;<br>    <span class="hljs-keyword">private</span> String waitNode;<br>    <span class="hljs-keyword">private</span> String lockNode;<br>    <span class="hljs-keyword">private</span> CountDownLatch latch;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">connectedLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">30000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZooKeeperDistributedLock</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.productId = productId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;</span>;<br>            zk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(address, sessionTimeout, <span class="hljs-built_in">this</span>);<br>            connectedLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;<br>            connectedLatch.countDown();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.latch != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.latch.countDown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireDistributedLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.tryLock()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                waitForLock(waitNode, sessionTimeout);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// 传入进去的locksRoot + “/” + productId</span><br>    <span class="hljs-comment">// 假设productId代表了一个商品id，比如说1</span><br>    <span class="hljs-comment">// locksRoot = locks</span><br>    <span class="hljs-comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span><br>            lockNode = zk.create(locksRoot + <span class="hljs-string">&quot;/&quot;</span> + productId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br><br>            <span class="hljs-comment">// 看看刚创建的节点是不是最小的节点</span><br>     <span class="hljs-comment">// locks：10000000000，10000000001，10000000002</span><br>            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="hljs-literal">false</span>);<br>            Collections.sort(locks);<br><br>            <span class="hljs-keyword">if</span>(lockNode.equals(locksRoot+<span class="hljs-string">&quot;/&quot;</span>+ locks.get(<span class="hljs-number">0</span>)))&#123;<br>                <span class="hljs-comment">//如果是最小的节点,则表示取得锁</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果不是最小的节点，找到比自己小1的节点</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">previousLockIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; locks.size(); i++) &#123;<br><span class="hljs-keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;<br>             previousLockIndex = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>   &#125;<br><br>   <span class="hljs-built_in">this</span>.waitNode = locks.get(previousLockIndex);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">waitForLock</span><span class="hljs-params">(String waitNode, <span class="hljs-type">long</span> waitTime)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException &#123;<br>        <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zk.exists(locksRoot + <span class="hljs-string">&quot;/&quot;</span> + waitNode, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (stat != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.latch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);<br>            <span class="hljs-built_in">this</span>.latch = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 删除/locks/10000000000节点</span><br>            <span class="hljs-comment">// 删除/locks/10000000001节点</span><br>            System.out.println(<span class="hljs-string">&quot;unlock &quot;</span> + lockNode);<br>            zk.delete(lockNode, -<span class="hljs-number">1</span>);<br>            lockNode = <span class="hljs-literal">null</span>;<br>            zk.close();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LockException</span><span class="hljs-params">(String e)</span> &#123;<br>            <span class="hljs-built_in">super</span>(e);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LockException</span><span class="hljs-params">(Exception e)</span> &#123;<br>            <span class="hljs-built_in">super</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="redis-分布式锁和-zk-分布式锁的对比"><a href="#redis-分布式锁和-zk-分布式锁的对比" class="headerlink" title="redis 分布式锁和 zk 分布式锁的对比"></a>redis 分布式锁和 zk 分布式锁的对比</h3><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li></ul><p>  另外一点就是，如果是 Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p><p>  Redis 分布式锁大家没发现好麻烦吗？遍历上锁，计算时间等等……zk 的分布式锁语义清晰实现简单。</p><p>  所以先不分析太多的东西，就说这两点，我个人实践认为 zk 的分布式锁比 Redis 的分布式锁牢靠、而且模型简单易用。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-lock-redis-vs-zookeeper.md">1. distributed-lock-redis-vs-zookeeper</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——3. RPC 框架简单设计</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%943.%20RPC%20%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%943.%20RPC%20%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——3-RPC-框架简单设计"><a href="#分布式系统设计——3-RPC-框架简单设计" class="headerlink" title="分布式系统设计——3. RPC 框架简单设计"></a>分布式系统设计——3. RPC 框架简单设计</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-rpc-design.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  举个栗子，说个最简单的回答思路：</p><ul><li>上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信息，可以用 zookeeper 来做，对吧。</li><li>然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上。</li><li>接着你就该发起一次请求了，咋发起？当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。</li><li>然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是。</li><li>接着找到一台机器，就可以跟它发送请求了，第一个问题咋发送？你可以说用 netty 了，nio 方式；第二个问题发送啥格式数据？你可以说用 hessian 序列化协议了，或者是别的，对吧。然后请求过去了。</li><li>服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。</li></ul><p>  这就是一个最最基本的 rpc 框架的思路。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-rpc-design.md">1. dubbo-rpc-design</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——2. 接口请求顺序性</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%942.%20%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%80%A7/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%942.%20%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——2-接口请求顺序性"><a href="#分布式系统设计——2-接口请求顺序性" class="headerlink" title="分布式系统设计——2. 接口请求顺序性"></a>分布式系统设计——2. 接口请求顺序性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-request-sequence.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是<strong>有时候</strong>可能确实是需要<strong>严格的顺序</strong>保证。给大家举个例子，你服务 A 调用服务 B，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。</p><p>  本来应该是 “先插入 -&gt; 再删除”，这条数据应该没了，结果现在 “先删除 -&gt; 再插入”，数据还存在，最后你死都想不明白是怎么回事。</p><p>  所以这都是分布式系统一些很常见的问题。</p><p>  首先，一般来说，个人建议是，你们从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，因为一旦引入顺序性保障，比如使用<strong>分布式锁</strong>，会<strong>导致系统复杂度上升</strong>，而且会带来<strong>效率低下</strong>，热点数据压力过大等问题。</p><p>  下面我给个我们用过的方案吧，简单来说，首先你得用 Dubbo 的一致性 hash 负载均衡策略，将比如某一个订单 id 对应的请求都给分发到某个机器上去，接着就是在那个机器上，因为可能还是多线程并发执行的，你可能得立即将某个订单 id 对应的请求扔一个<strong>内存队列</strong>里去，强制排队，这样来确保他们的顺序性。</p><p><a href="https://yangtzeshore.github.io/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-2-%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%80%A7/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/distributed-system-request-sequence.png" alt="distributed-system-request-sequence"></a></p><p>  但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成<strong>热点</strong>怎么办？解决这些问题又要开启后续一连串的复杂技术方案…… 曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？</p><p>  最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是其它什么，避免这种问题的产生。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-request-sequence.md">1. distributed-system-request-sequence</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——1. 接口幂等性</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%941.%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%941.%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——1-接口幂等性"><a href="#分布式系统设计——1-接口幂等性" class="headerlink" title="分布式系统设计——1. 接口幂等性"></a>分布式系统设计——1. 接口幂等性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-idempotency.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  一个分布式系统中的某个接口，该如何保证幂等性？这个事儿其实是你做分布式系统的时候必须要考虑的一个生产环境的技术问题。啥意思呢？</p><p>  你看，假如你有个服务提供一些接口供外部调用，这个服务部署在了 5 台机器上，接着有个接口就是<strong>付款接口</strong>。然后人家用户在前端上操作的时候，不知道为啥，总之就是一个订单<strong>不小心发起了两次支付请求</strong>，然后这俩请求分散在了这个服务部署的不同的机器上，好了，结果一个订单扣款扣两次。</p><p>  或者是订单系统调用支付系统进行支付，结果不小心因为<strong>网络超时</strong>了，然后订单系统走了前面我们看到的那个重试机制，咔嚓给你重试了一把，好，支付系统收到一个支付请求两次，而且因为负载均衡算法落在了不同的机器上，尴尬了。。。</p><p>  所以你肯定得知道这事儿，否则你做出来的分布式系统恐怕容易埋坑。</p><p>  这个不是技术问题，这个没有通用的一个方法，这个应该<strong>结合业务</strong>来保证幂等性。</p><p>  所谓<strong>幂等性</strong>，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</p><p>  其实保证幂等性主要是三点：</p><ul><li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。</li><li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。</li><li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li></ul><p>  实际运作过程中，你要结合自己的业务来，比如说利用 Redis，用 orderId 作为唯一键。只有成功插入这个支付流水，才可以执行实际的支付扣款。</p><p>  要求是支付一个订单，必须插入一条支付流水，order_id 建一个唯一键 <code>unique key</code> 。你在支付一个订单之前，先插入一条支付流水，order_id 就已经进去了。你就可以写一个标识到 Redis 里面去， <code>set order_id payed</code> ，下一次重复请求过来了，先查 Redis 的 order_id 对应的 value，如果是 <code>payed</code> 就说明已经支付过了，你就别重复支付了。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-idempotency.md">1. distributed-system-idempotenc</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——4. Dubbo负载均衡策略</title>
    <link href="/2020/10/25/Dubbo%E2%80%94%E2%80%944.%20Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/25/Dubbo%E2%80%94%E2%80%944.%20Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——4-Dubbo负载均衡策略"><a href="#Dubbo——4-Dubbo负载均衡策略" class="headerlink" title="Dubbo——4. Dubbo负载均衡策略"></a>Dubbo——4. Dubbo负载均衡策略</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-load-balancing.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="dubbo-负载均衡策略"><a href="#dubbo-负载均衡策略" class="headerlink" title="dubbo 负载均衡策略"></a>dubbo 负载均衡策略</h3><h4 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h4><p>  默认情况下，dubbo 是 RandomLoadBalance ，即<strong>随机</strong>调用实现负载均衡，可以对 provider 不同实例<strong>设置不同的权重</strong>，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。</p><p>  算法思想很简单。假设有一组服务器 servers &#x3D; <code>[A, B, C]</code>，他们对应的权重为 weights &#x3D; <code>[5, 3, 2]</code>，权重总和为 10。现在把这些权重值平铺在一维坐标值上，<code>[0, 5)</code> 区间属于服务器 A，<code>[5, 8)</code> 区间属于服务器 B，<code>[8, 10)</code> 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 <code>[0, 10)</code> 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字 3 会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为 5000 次，服务器 B 被选中的次数约为 3000 次，服务器 C 被选中的次数约为 2000 次。</p><h4 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h4><p>  这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。</p><p>举个栗子。</p><p>  跟运维同学申请机器，有的时候，我们运气好，正好公司资源比较充足，刚刚有一批热气腾腾、刚刚做好的虚拟机新鲜出炉，配置都比较高：8 核 + 16G 机器，申请到 2 台。过了一段时间，我们感觉 2 台机器有点不太够，我就去找运维同学说，“哥儿们，你能不能再给我一台机器”，但是这时只剩下一台 4 核 + 8G 的机器。我要还是得要。</p><p>  这个时候，可以给两台 8 核 16G 的机器设置权重 4，给剩余 1 台 4 核 8G 的机器设置权重 2。</p><h4 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h4><p>  官网对 <code>LeastActiveLoadBalance</code> 的解释是“<strong>最小活跃数负载均衡</strong>”，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求，那么此时请求会优先分配给该服务提供者。</p><p>  最小活跃数负载均衡算法的基本思想是这样的：</p><p>  每个服务提供者会对应着一个活跃数 <code>active</code>。初始情况下，所有服务提供者的 <code>active</code> 均为 0。每当收到一个请求，对应的服务提供者的 <code>active</code> 会加 1，处理完请求后，<code>active</code> 会减 1。所以，如果服务提供者性能较好，处理请求的效率就越高，那么 <code>active</code> 也会下降的越快。因此可以给这样的服务提供者优先分配请求。</p><p>  当然，除了最小活跃数，<code>LeastActiveLoadBalance</code> 在实现上还引入了权重值。所以准确的来说，<code>LeastActiveLoadBalance</code> 是基于加权最小活跃数算法实现的。</p><h4 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h4><p>  一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。<strong>如果你需要的不是随机负载均衡</strong>，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。</p><blockquote><p>关于 dubbo 负载均衡策略更加详细的描述，可以查看官网 <a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a> 。</p></blockquote><h3 id="dubbo-集群容错策略"><a href="#dubbo-集群容错策略" class="headerlink" title="dubbo 集群容错策略"></a>dubbo 集群容错策略</h3><h4 id="Failover-Cluster-模式"><a href="#Failover-Cluster-模式" class="headerlink" title="Failover Cluster 模式"></a>Failover Cluster 模式</h4><p>  失败自动切换，自动重试其他机器，<strong>默认</strong>就是这个，常见于读操作。（失败重试其它机器）</p><p>可以通过以下几种方式配置重试次数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>  或者</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;dubbo:<span class="hljs-keyword">reference</span> retries=<span class="hljs-string">&quot;2&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>  或者</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;dubbo:<span class="hljs-keyword">reference</span>&gt;<br>    &lt;dubbo:<span class="hljs-keyword">method</span> <span class="hljs-title function_">name</span>=&quot;<span class="hljs-title function_">findFoo</span>&quot; <span class="hljs-title function_">retries</span>=&quot;2&quot; /&gt;<br>&lt;/<span class="hljs-title function_">dubbo</span>:<span class="hljs-keyword">reference</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="Failfast-Cluster-模式"><a href="#Failfast-Cluster-模式" class="headerlink" title="Failfast Cluster 模式"></a>Failfast Cluster 模式</h4><p>  一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）</p><h4 id="Failsafe-Cluster-模式"><a href="#Failsafe-Cluster-模式" class="headerlink" title="Failsafe Cluster 模式"></a>Failsafe Cluster 模式</h4><p>  出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。</p><p>  配置示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>  或者</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&lt;dubbo:<span class="hljs-keyword">reference</span> <span class="hljs-keyword">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="Failback-Cluster-模式"><a href="#Failback-Cluster-模式" class="headerlink" title="Failback Cluster 模式"></a>Failback Cluster 模式</h4><p>  失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。</p><h4 id="Forking-Cluster-模式"><a href="#Forking-Cluster-模式" class="headerlink" title="Forking Cluster 模式"></a>Forking Cluster 模式</h4><p>  <strong>并行调用</strong>多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p><h4 id="Broadcast-Cluster-模式"><a href="#Broadcast-Cluster-模式" class="headerlink" title="Broadcast Cluster 模式"></a>Broadcast Cluster 模式</h4><p>  逐个调用所有的 provider。任何一个 provider 出错则报错（从 <code>2.1.0</code> 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><blockquote><p>关于 dubbo 集群容错策略更加详细的描述，可以查看官网 <a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html</a> 。</p></blockquote><h3 id="dubbo-动态代理策略"><a href="#dubbo-动态代理策略" class="headerlink" title="dubbo 动态代理策略"></a>dubbo 动态代理策略</h3><p>  默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-load-balancing.md">1. dubbo-load-balancing</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单点登录的三种实现方式</title>
    <link href="/2020/10/23/Dubbo%E2%80%94%E2%80%943.%20Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/10/23/Dubbo%E2%80%94%E2%80%943.%20Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——3-Dubbo序列化协议"><a href="#Dubbo——3-Dubbo序列化协议" class="headerlink" title="Dubbo——3. Dubbo序列化协议"></a>Dubbo——3. Dubbo序列化协议</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-serialization-protocol.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  <strong>序列化</strong>，就是把数据结构或者是一些对象，转换为二进制串的过程，而<strong>反序列化</strong>是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-3-Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/serialize-deserialize.png" alt="serialize-deserialize"></a></p><h3 id="dubbo-支持不同的通信协议"><a href="#dubbo-支持不同的通信协议" class="headerlink" title="dubbo 支持不同的通信协议"></a>dubbo 支持不同的通信协议</h3><ul><li>dubbo 协议</li></ul><p>  <strong>默认</strong>就是走 dubbo 协议，单一长连接，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。</p><p>  为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就 100 个连接。然后后面直接基于长连接 NIO 异步通信，可以支撑高并发请求。</p><p>  长连接，通俗点说，就是建立连接过后可以持续发送请求，无须再建立连接。</p><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-3-Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-keep-connection.png" alt="dubbo-keep-connection"></a></p><p>  而短连接，每次要发送请求之前，需要先重新建立一次连接。</p><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-3-Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-not-keep-connection.png" alt="dubbo-not-keep-connection"></a></p><ul><li>rmi 协议</li></ul><p>  走 Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</p><ul><li>hessian 协议</li></ul><p>  走 hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</p><ul><li>http 协议</li></ul><p>  走表单序列化。</p><ul><li>webservice</li></ul><p>  走 SOAP 文本序列化。</p><h3 id="dubbo-支持的序列化协议"><a href="#dubbo-支持的序列化协议" class="headerlink" title="dubbo 支持的序列化协议"></a>dubbo 支持的序列化协议</h3><p>  dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。但是 hessian 是其默认的序列化协议。</p><h3 id="说一下-Hessian-的数据结构"><a href="#说一下-Hessian-的数据结构" class="headerlink" title="说一下 Hessian 的数据结构"></a>说一下 Hessian 的数据结构</h3><p>  Hessian 的对象序列化机制有 8 种原始类型：</p><ul><li>原始二进制数据</li><li>boolean</li><li>64-bit date（64 位毫秒值的日期）</li><li>64-bit double</li><li>32-bit int</li><li>64-bit long</li><li>null</li><li>UTF-8 编码的 string</li></ul><p>  另外还包括 3 种递归类型：</p><ul><li>list for lists and arrays</li><li>map for maps and dictionaries</li><li>object for objects</li></ul><p>  还有一种特殊的类型：</p><ul><li>ref：用来表示对共享对象的引用。</li></ul><h3 id="为什么-PB-的效率是最高的？"><a href="#为什么-PB-的效率是最高的？" class="headerlink" title="为什么 PB 的效率是最高的？"></a>为什么 PB 的效率是最高的？</h3><p>  其实 PB 之所以性能如此好，主要得益于两个：<strong>第一</strong>，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 <code>XML</code> 和 <code>JSON</code> 快上了 <code>20~100</code> 倍；<strong>第二</strong>，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-serialization-protocol.md">1. dubbo-serialization-protocol</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——2. Dubbo工作原理</title>
    <link href="/2020/10/23/Dubbo%E2%80%94%E2%80%942.%20Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/23/Dubbo%E2%80%94%E2%80%942.%20Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——2-Dubbo工作原理"><a href="#Dubbo——2-Dubbo工作原理" class="headerlink" title="Dubbo——2. Dubbo工作原理"></a>Dubbo——2. Dubbo工作原理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="dubbo-工作原理"><a href="#dubbo-工作原理" class="headerlink" title="dubbo 工作原理"></a>dubbo 工作原理</h3><ul><li>第一层：service 层，接口层，给服务提供者和消费者来实现的</li><li>第二层：config 层，配置层，主要是对 dubbo 进行各种配置的</li><li>第三层：proxy 层，服务代理层，无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信</li><li>第四层：registry 层，服务注册层，负责服务的注册与发现</li><li>第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li><li>第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控</li><li>第七层：protocal 层，远程调用层，封装 rpc 调用</li><li>第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步</li><li>第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口</li><li>第十层：serialize 层，数据序列化层</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>第一步：provider 向注册中心去注册</li><li>第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务</li><li>第三步：consumer 调用 provider</li><li>第四步：consumer 和 provider 都异步通知监控中心</li></ul><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-2-Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-operating-principle.png" alt="dubbo-operating-principle"></a></p><h3 id="注册中心挂了可以继续通信吗？"><a href="#注册中心挂了可以继续通信吗？" class="headerlink" title="注册中心挂了可以继续通信吗？"></a>注册中心挂了可以继续通信吗？</h3><p>  可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息<strong>拉取到本地缓存</strong>，所以注册中心挂了可以继续通信。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md">1. dubbo-operating-principle</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——1. 引入Dubbo</title>
    <link href="/2020/10/23/Dubbo%E2%80%94%E2%80%941.%20%E5%BC%95%E5%85%A5Dubbo/"/>
    <url>/2020/10/23/Dubbo%E2%80%94%E2%80%941.%20%E5%BC%95%E5%85%A5Dubbo/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——1-引入Dubbo"><a href="#Dubbo——1-引入Dubbo" class="headerlink" title="Dubbo——1. 引入Dubbo"></a>Dubbo——1. 引入Dubbo</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/why-dubbo.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  为什么要进行系统拆分？如何进行系统拆分？拆分后不用 dubbo 可以吗？</p><p>  其实为啥会这样呢？这就是因为整个大行业技术发展的原因。</p><p>  早些年，印象中在 2010 年初的时候，整个 IT 行业，很少有人谈分布式，更不用说微服务，虽然很多 BAT 等大型公司，因为系统的复杂性，很早就是分布式架构，大量的服务，只不过微服务大多基于自己搞的一套框架来实现而已。</p><p>  但是确实，那个年代，大家很重视 ssh2，很多中小型公司几乎大部分都是玩儿 struts2、spring、hibernate，稍晚一些，才进入了 spring mvc、spring、mybatis 的组合。那个时候整个行业的技术水平就是那样，当年 oracle 很火，oracle 管理员很吃香，oracle 性能优化啥的都是 IT 男的大杀招啊。连大数据都没人提，当年 OCP、OCM 等认证培训机构，火的不行。</p><p>  但是确实随着时代的发展，慢慢的，很多公司开始接受分布式系统架构了，这里面尤为对行业有至关重要影响的，是阿里的 dubbo，<strong>某种程度上而言，阿里在这里推动了行业技术的前进</strong>。</p><p>  正是因为有阿里的 dubbo，很多中小型公司才可以基于 dubbo，来把系统拆分成很多的服务，每个人负责一个服务，大家的代码都没有冲突，服务可以自治，自己选用什么技术都可以，每次发布如果就改动一个服务那就上线一个服务好了，不用所有人一起联调，每次发布都是几十万行代码，甚至几百万行代码了。</p><h3 id="为什么要将系统进行拆分？"><a href="#为什么要将系统进行拆分？" class="headerlink" title="为什么要将系统进行拆分？"></a>为什么要将系统进行拆分？</h3><p>  网上查查，答案极度零散和复杂，很琐碎，原因一大坨。但是我这里给大家直观的感受：</p><p>  要是<strong>不拆分</strong>，一个大系统几十万行代码，20 个人维护一份代码，简直是悲剧啊。代码经常改着改着就冲突了，各种代码冲突和合并要处理，非常耗费时间；经常我改动了我的代码，你调用了我的，导致你的代码也得重新测试，麻烦的要死；然后每次发布都是几十万行代码的系统一起发布，大家得一起提心吊胆准备上线，几十万行代码的上线，可能每次上线都要做很多的检查，很多异常问题的处理，简直是又麻烦又痛苦；而且如果我现在打算把技术升级到最新的 spring 版本，还不行，因为这可能导致你的代码报错，我不敢随意乱改技术。</p><p>  假设一个系统是 20 万行代码，其中 A 在里面改了 1000 行代码，但是此时发布的时候是这个 20 万行代码的大系统一块儿发布。就意味着 20 万上代码在线上就可能出现各种变化，20 个人，每个人都要紧张地等在电脑面前，上线之后，检查日志，看自己负责的那一块儿有没有什么问题。</p><p>  A 就检查了自己负责的 1 万行代码对应的功能，确保 ok 就闪人了；结果不巧的是，A 上线的时候不小心修改了线上机器的某个配置，导致另外 B 和 C 负责的 2 万行代码对应的一些功能，出错了。</p><p>  几十个人负责维护一个几十万行代码的单块应用，每次上线，准备几个礼拜，上线 -&gt; 部署 -&gt; 检查自己负责的功能。</p><p>  <strong>拆分了以后</strong>，整个世界清爽了，几十万行代码的系统，拆分成 20 个服务，平均每个服务就 1~2 万行代码，每个服务部署到单独的机器上。20 个工程，20 个 git 代码仓库，20 个开发人员，每个人维护自己的那个服务就可以了，是自己独立的代码，跟别人没关系。再也没有代码冲突了，爽。每次就测试我自己的代码就可以了，爽。每次就发布我自己的一个小服务就可以了，爽。技术上想怎么升级就怎么升级，保持接口不变就可以了，真爽。</p><p>  所以简单来说，一句话总结，如果是那种代码量多达几十万行的中大型项目，团队里有几十个人，那么如果不拆分系统，<strong>开发效率极其低下</strong>，问题很多。但是拆分系统之后，每个人就负责自己的一小部分就好了，可以随便玩儿随便弄。分布式系统拆分之后，可以大幅度提升复杂系统大型团队的开发效率。</p><p>  但是同时，也要<strong>提醒</strong>的一点是，系统拆分成分布式系统之后，大量的分布式系统面临的问题也是接踵而来，所以后面的问题都是在<strong>围绕分布式系统带来的复杂技术挑战</strong>在说。</p><h3 id="如何进行系统拆分？"><a href="#如何进行系统拆分？" class="headerlink" title="如何进行系统拆分？"></a>如何进行系统拆分？</h3><p>  这个问题说大可以很大，可以扯到领域驱动模型设计上去，说小了也很小。</p><p>  系统拆分为分布式系统，拆成多个服务，拆成微服务的架构，是需要拆很多轮的。并不是说上来一个架构师一次就给拆好了，而以后都不用拆。</p><p>  第一轮；团队继续扩大，拆好的某个服务，刚开始是 1 个人维护 1 万行代码，后来业务系统越来越复杂，这个服务是 10 万行代码，5 个人；第二轮，1 个服务 -&gt; 5 个服务，每个服务 2 万行代码，每人负责一个服务。</p><p>  如果是多人维护一个服务，最理想的情况下，几十个人，1 个人负责 1 个或 2~3 个服务；某个服务工作量变大了，代码量越来越多，某个同学，负责一个服务，代码量变成了 10 万行了，他自己不堪重负，他现在一个人拆开，5 个服务，1 个人顶着，负责 5 个人，接着招人，2 个人，给那个同学带着，3 个人负责 5 个服务，其中 2 个人每个人负责 2 个服务，1 个人负责 1 个服务。</p><p>  个人建议，一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>  大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等吧。</p><p>  但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。</p><p>  扯深了实在很深，所以这里先给大家举个例子，你自己感受一下，<strong>核心意思就是根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆</strong>。你根据自己负责系统的例子，来考虑一下就好了。</p><h3 id="拆分后不用-dubbo-可以吗？"><a href="#拆分后不用-dubbo-可以吗？" class="headerlink" title="拆分后不用 dubbo 可以吗？"></a>拆分后不用 dubbo 可以吗？</h3><p>  当然可以了，大不了最次，就是各个系统之间，直接基于 spring mvc，就纯 http 接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为 http 接口通信维护起来成本很高，你要考虑<strong>超时重试</strong>、<strong>负载均衡</strong>等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了 5 台机器，你怎么把请求均匀地甩给那 5 台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p><p>  所以 dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡、服务实例上下线自动感知、超时重试等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/why-dubbo.md">1. why-dubbo</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AddTwoNumbers</title>
    <link href="/2020/10/23/AddTwoNumbers/"/>
    <url>/2020/10/23/AddTwoNumbers/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTwoNumbers</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span> || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l1Val</span> <span class="hljs-operator">=</span> l1 != <span class="hljs-literal">null</span> ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l2Val</span> <span class="hljs-operator">=</span> l2 != <span class="hljs-literal">null</span> ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sumVal</span> <span class="hljs-operator">=</span> l1Val + l2Val + carry;<br>            carry = sumVal / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">sumNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sumVal % <span class="hljs-number">10</span>);<br>            cursor.next = sumNode;<br>            cursor = sumNode;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> l1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        cursor.next = next;<br>        cursor = next;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        cursor.next = next;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        cursor = l2;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">6</span>);<br>        cursor.next = next;<br>        cursor = next;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        cursor.next = next;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> addTwoNumbers(l1, l2);<br>        print(listNode);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode listNode)</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            System.out.println(listNode.val);<br>            listNode = listNode.next;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != listNode);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">7<br>0<br>8<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>链路是从个位到最高位，所以可以用最简单的加进位就可以解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主流扫码登录技术原理</title>
    <link href="/2020/10/22/%E4%B8%BB%E6%B5%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/22/%E4%B8%BB%E6%B5%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="主流扫码登录技术原理"><a href="#主流扫码登录技术原理" class="headerlink" title="主流扫码登录技术原理"></a>主流扫码登录技术原理</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://my.oschina.net/u/4231722/blog/3154805">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="1、基本技术原理"><a href="#1、基本技术原理" class="headerlink" title="1、基本技术原理"></a>1、基本技术原理</h3><h4 id="1-1-扫码登录功能到底是什么样的？"><a href="#1-1-扫码登录功能到底是什么样的？" class="headerlink" title="1.1 扫码登录功能到底是什么样的？"></a>1.1 扫码登录功能到底是什么样的？</h4><p>  首先介绍下什么是扫码登录。现在大部分同学手机上都装有微信、qq和淘宝这一类的软件。而这些app都有他们相对应的网页端。为了让用户在使用他们的网页时登录更加方便和安全，使用手机扫一扫就可以登录的服务，就显的自然而然了。</p><p>  有很多小伙伴可能会感到很神奇，网页上只是显示了个二维码，它怎么就知道是哪个手机扫到了二维码，并且进行登录的呢？而且，登录完成以后，还能直接把用户信息显示给用户，真的是很神奇啊。</p><h4 id="1-2-扫码登录功能的完整技术逻辑"><a href="#1-2-扫码登录功能的完整技术逻辑" class="headerlink" title="1.2 扫码登录功能的完整技术逻辑"></a>1.2 扫码登录功能的完整技术逻辑</h4><h5 id="1）网页端与服务器的配合逻辑："><a href="#1）网页端与服务器的配合逻辑：" class="headerlink" title="1）网页端与服务器的配合逻辑："></a><strong>1）网页端与服务器的配合逻辑：</strong></h5><p>  接下来就是对于这个服务的详细实现。</p><p>  首先用户打开网站的登录页面的时候，向浏览器的服务器发送获取登录二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，再过期后，用户登录二维码需要进行刷新重新获取。</p><p>  同时，将这个key值和本公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片（二维码生成，网上有很多现成的接口和源码，这里不再介绍）。然后，将二维码图片和uuid一起返回给用户浏览器。</p><p>  浏览器拿到二维码和uuid后，会每隔一秒向浏览器发送一次，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。这里有的同学就会奇怪了，服务器只存了个uuid在redis中作为key值，怎么会有用户的id信息呢？</p><p>  这里确实会有用户的id信息，这个id信息是由手机服务器存入redis中的。具体请继续阅读“手机端与服务器的配合逻辑”。</p><h5 id="2）手机端与服务器的配合逻辑："><a href="#2）手机端与服务器的配合逻辑：" class="headerlink" title="2）手机端与服务器的配合逻辑："></a>2）手机端与服务器的配合逻辑：</h5><p>  话说，浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：请掏出您的手机，打开扫一扫进行登录。</p><p>  用户拿出手机扫描二维码，就可以得到一个验证信息和一个uuid（扫描二维码获取字符串的功能在网上同样有很多demo，这里就不详细介绍了）。</p><p>  由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都回携带一个用户的token，手机端服务器可以从中解析到用户的userId（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多）。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登录请求（这里的服务器是手机服务器，手机端的服务器跟网页端服务器不是同一台服务器）。</p><p>  服务器收到请求后，首先对比参数中的验证信息，确定是否为用户登录请求接口。如果是，返回一个确认信息给手机端。</p><p>  手机端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到uuId和userId后，将用户的userid作为value值存入redis中以uuid作为key的键值对中。</p><h5 id="3）登录成功时的逻辑："><a href="#3）登录成功时的逻辑：" class="headerlink" title="3）登录成功时的逻辑："></a><strong>3）登录成功时的逻辑：</strong></h5><p>  然后，浏览器再次发送请求的时候，浏览器端的服务器就可以得到一个用户Id，并调用登录的方法，声成一个浏览器端的token，再浏览器再次发送请求的时候，将用户信息返回给浏览器，登录成功。这里存储用户id而不是直接存储用户信息是因为，手机端的用户信息，不一定是和浏览器端的用户信息完全一致。</p><h5 id="4）详细的技术原理总结如下图所示："><a href="#4）详细的技术原理总结如下图所示：" class="headerlink" title="4）详细的技术原理总结如下图所示："></a><strong>4）详细的技术原理总结如下图所示：</strong><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133020067-530842155.png" alt="img"></h5><h3 id="2、淘宝的扫码登录技术实现"><a href="#2、淘宝的扫码登录技术实现" class="headerlink" title="2、淘宝的扫码登录技术实现"></a>2、淘宝的扫码登录技术实现</h3><p>  本节我们以淘宝的扫码登录为例，来实际研究分析一下淘宝的扫码登录实现逻辑。</p><p>  <strong>登录界面 <a href="https://login.taobao.com/member/login.jhtml">https://login.taobao.com/member/login.jhtml</a> 传回来的参数为：</strong></p><p><strong><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133034248-917120898.png" alt="img"></strong></p><p>  <strong>然后请求(GET)报文是这样的:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">https://qrlogin.taobao.com/qrcodelogin/qrcodeLoginCheck.<span class="hljs-keyword">do</span>?lgToken=2c3b4d53ef0513787bf4ce711ea5ba53<span class="hljs-variable">&amp;defaulturl</span>=<span class="hljs-variable">&amp;_ksTS</span>=1540106757739_2804<span class="hljs-variable">&amp;callback</span>=jsonp2805<br></code></pre></td></tr></table></figure><p>  关键的就是lgToken，是网页的唯一ID，当打开了二维码登录的时候，网页在轮询(应该是长轮询long polling)调用接口去请求服务器。</p><p>  <strong>如果没有扫码，返回的为：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133115512-1195606596.png" alt="img"></p><p>  <strong>如果扫了的话则会返回：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10001&quot;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mobile scan QRCode success&quot;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  长时间没有扫码的话，网页端会停止轮询，二维码失效！</p><p>  <strong>当手机端确认登录后，接口返回的是：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10006&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://login.taobao.com/member/loginByIm.do?uid=cntaobaoxxx&amp;token=ff82fc0d1d395a33d3b38ec5a4981336&amp;time=1530179143250&amp;asker=qrcodelogin&amp;ask_version=1.0.0&amp;defaulturl=https://www.taobao.com&amp;webpas=0b7aed2d43f01825183e4a49c6cae47d1479929926&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  表示登录成功，当然手机端与服务端在点击”确认登录”之间的交互可能就是这样：网页端生成的lgToken去请求服务端，服务端记住了这个lgToken并认为登录了，当网页端再次轮询请求接口时，就返回真正的登录态Token，网页端此时就可以凭着这个Token来登录了。</p><p>  <strong>详细的技术逻辑如下图所示：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133133018-1177752969.png" alt="img"></p><h3 id="3、微信的扫码登录技术实现"><a href="#3、微信的扫码登录技术实现" class="headerlink" title="3、微信的扫码登录技术实现"></a>3、微信的扫码登录技术实现</h3><h4 id="3-1-技术原理流程图"><a href="#3-1-技术原理流程图" class="headerlink" title="3.1 技术原理流程图"></a>3.1 技术原理流程图</h4><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133146058-1514561154.png" alt="img"></p><p>  微信的网页版访问地址是：<a href="https://wx.qq.com/%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%82">https://wx.qq.com/，有兴趣也可以自行深入研究。</a></p><h4 id="3-2-实际的技术实现逻辑"><a href="#3-2-实际的技术实现逻辑" class="headerlink" title="3.2 实际的技术实现逻辑"></a>3.2 实际的技术实现逻辑</h4><h5 id="1）获取唯一的uuid-以及包含uid信息的二维码："><a href="#1）获取唯一的uuid-以及包含uid信息的二维码：" class="headerlink" title="1）获取唯一的uuid, 以及包含uid信息的二维码："></a><strong>1）获取唯一的uuid, 以及包含uid信息的二维码：</strong></h5><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133203183-678380281.jpg" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取uuid</span><br><br><span class="hljs-attr">getUUID</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>  vare = t.<span class="hljs-title function_">defer</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span> = &#123;&#125;,<br><br>  $.<span class="hljs-title function_">ajax</span>(&#123;<br><br>    <span class="hljs-attr">url</span>: i.<span class="hljs-property">API_jsLogin</span>,<br><br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;script&quot;</span><br><br>  &#125;).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-number">200</span> == <span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span>.<span class="hljs-property">code</span> ? e.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span>.<span class="hljs-property">uuid</span>) : e.<span class="hljs-title function_">reject</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span>.<span class="hljs-property">code</span>)<br><br>  &#125;).<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    e.<span class="hljs-title function_">reject</span>()<br><br>  &#125;),<br><br>  e.<span class="hljs-property">promise</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）浏览器轮询服务器，获取扫码状态："><a href="#2）浏览器轮询服务器，获取扫码状态：" class="headerlink" title="2）浏览器轮询服务器，获取扫码状态："></a><strong>2）浏览器轮询服务器，获取扫码状态：</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 查看扫码状态</span><br><br><span class="hljs-attr">checkLogin</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e, a</span>) &#123;<br><br>  varn = t.<span class="hljs-title function_">defer</span>()<br><br>    , a = a || <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">code</span> = <span class="hljs-number">0</span>,<br><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">checkLoginPromise</span> = $.<span class="hljs-title function_">ajax</span>(&#123;<br><br>    <span class="hljs-attr">url</span>: i.<span class="hljs-property">API_login</span> + <span class="hljs-string">&quot;?loginicon=true&amp;uuid=&quot;</span>+ e + <span class="hljs-string">&quot;&amp;tip=&quot;</span>+ a + <span class="hljs-string">&quot;&amp;r=&quot;</span>+ ~newDate,<br><br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;script&quot;</span>,<br><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">35e3</span><br><br>  &#125;).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;/&quot;</span>+ location.<span class="hljs-property">host</span> + <span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/&quot;</span>+ location.<span class="hljs-property">host</span> + <span class="hljs-string">&quot;/&quot;</span>) &lt; <span class="hljs-number">0</span>)<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">void</span> (location.<span class="hljs-property">href</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span>);<br><br>    vare = &#123;<br><br>      <span class="hljs-attr">code</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">code</span>,<br><br>      <span class="hljs-attr">redirect_uri</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span>,<br><br>      <span class="hljs-attr">userAvatar</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">userAvatar</span><br><br>    &#125;;<br><br>    n.<span class="hljs-title function_">resolve</span>(e)<br><br>  &#125;).<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    n.<span class="hljs-title function_">reject</span>()<br><br>  &#125;),<br><br>  n.<span class="hljs-property">promise</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）根据服务器返回的扫码状态，进行相应的操作："><a href="#3）根据服务器返回的扫码状态，进行相应的操作：" class="headerlink" title="3）根据服务器返回的扫码状态，进行相应的操作："></a><strong>3）根据服务器返回的扫码状态，进行相应的操作：</strong></h5><p><strong>408 扫码超时</strong>： 如果手机没有扫码或没有授权登录，服务器会阻塞约25s，然后返回状态码 408 -&gt; 前端继续轮询</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133232664-619837065.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133238085-2012989280.jpg" alt="img"></p><p><strong>400 二维码失效</strong>：大约5分钟的时间内不扫码，二维码失效</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133253419-957680642.jpg" alt="img"></p><p><strong>201 已扫码</strong>：如果手机已经扫码，服务器立即返回状态码和用户的基本信息 （window.code&#x3D;201,window.code.userAvator&#x3D;”…”），-&gt; 前端继续轮询</p><p><img src="https://github.com/yangtzeshore/images/blob/main/%E7%99%BB%E5%BD%95/848699-20200108133307430-591182141.jpg?raw=true" alt="img"></p><p><strong>200 已授权</strong>：如果手机点击了确认登录，服务器返回200及token -&gt; 前端停止轮询, 获取到token，重定向到目标页</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133317300-545669571.jpg" alt="img"></p><p><strong>具体的代码示例如下：</strong></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">// 根据服务器返回的扫码状态，进行相应的操作<br><br>functiono(c) &#123;<br><br>  <span class="hljs-attribute">switch(c.code) &#123;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case200</span>:<br><br>    t<span class="hljs-variable">.newLoginPage</span>(c<span class="hljs-variable">.redirect_uri</span>)<span class="hljs-variable">.then</span>(function(t) &#123;<br><br>      varo = t<span class="hljs-variable">.match</span>(/&lt;ret&gt;(.*)&lt;\/ret&gt;/)<br><br>        , r = t<span class="hljs-variable">.match</span>(/&lt;script&gt;(.*)&lt;\/script&gt;/)<br><br>        , c = t<span class="hljs-variable">.match</span>(/&lt;skey&gt;(.*)&lt;\/skey&gt;/)<br><br>        , s = t<span class="hljs-variable">.match</span>(/&lt;wxsid&gt;(.*)&lt;\/wxsid&gt;/)<br><br>        , l = t<span class="hljs-variable">.match</span>(/&lt;wxuin&gt;(.*)&lt;\/wxuin&gt;/)<br><br>        , d = t<span class="hljs-variable">.match</span>(/&lt;pass_ticket&gt;(.*)&lt;\/pass_ticket&gt;/)<br><br>        , f = t<span class="hljs-variable">.match</span>(/&lt;message&gt;(.*)&lt;\/message&gt;/)<br><br>        , u = t<span class="hljs-variable">.match</span>(/&lt;redirecturl&gt;(.*)&lt;\/redirecturl&gt;/);<br><br>      <span class="hljs-attribute">returnu ? void (window.location.href = u[1])</span> : o &amp;&amp; &quot;0&quot;!= o[1] ? (alert(f &amp;&amp; f[1] || &quot;登录失败&quot;),<br><br>      i<span class="hljs-variable">.report</span>(i<span class="hljs-variable">.AUTH_FAIL_COUNT</span>, 1),<br><br>      void location<span class="hljs-variable">.reload</span>()) : (e.$emit(&quot;newLoginPage&quot;, &#123;<br><br>        Ret: o &amp;&amp; o[1],<br><br>        SKey: c &amp;&amp; c[1],<br><br>        Sid: s &amp;&amp; s[1],<br><br>        Uin: l &amp;&amp; l[1],<br><br>        Passticket: d &amp;&amp; d[1],<br><br>        Code: r<br><br>      &#125;),<br><br>      void (a<span class="hljs-variable">.getCookie</span>(&quot;webwx_data_ticket&quot;) || n<span class="hljs-variable">.report</span>(n<span class="hljs-variable">.ReportType</span><span class="hljs-variable">.cookieError</span>, &#123;<br><br>        text: &quot;webwx_data_ticket 票据丢失&quot;,<br><br>        cookie: document<span class="hljs-variable">.cookie</span><br><br>      &#125;)))<br><br>    &#125;);<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case201</span>:<br><br>    e<span class="hljs-variable">.isScan</span> = !0,<br><br>    n<span class="hljs-variable">.report</span>(n<span class="hljs-variable">.ReportType</span><span class="hljs-variable">.timing</span>, &#123;<br><br>      timing: &#123;<br><br>        scan: Date<span class="hljs-variable">.now</span>()<br><br>      &#125;<br><br>    &#125;),<br><br>    t<span class="hljs-variable">.checkLogin</span>(e<span class="hljs-variable">.uuid</span>)<span class="hljs-variable">.then</span>(o, function(t) &#123;<br><br>      !t &amp;&amp; window<span class="hljs-variable">.checkLoginPromise</span> &amp;&amp; (e<span class="hljs-variable">.isBrokenNetwork</span> = !0)<br><br>    &#125;);<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case408</span>:<br><br>    t<span class="hljs-variable">.checkLogin</span>(e<span class="hljs-variable">.uuid</span>)<span class="hljs-variable">.then</span>(o, function(t) &#123;<br><br>      !t &amp;&amp; window<span class="hljs-variable">.checkLoginPromise</span> &amp;&amp; (e<span class="hljs-variable">.isBrokenNetwork</span> = !0)<br><br>    &#125;);<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case400</span>:<br><br>  case500:<br><br>  case0:<br><br>    vars = a<span class="hljs-variable">.getCookie</span>(&quot;refreshTimes&quot;) || 0;<br><br>    <span class="hljs-attribute">s &lt; 5 ? (s++,</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">    a.setCookie(&quot;refreshTimes&quot;, s, .5),</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">    document.location.reload())</span> : e<span class="hljs-variable">.isNeedRefresh</span> = !0;<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case202</span>:<br><br>    e<span class="hljs-variable">.isScan</span> = !1,<br><br>    e<span class="hljs-variable">.isAssociationLogin</span> = !1,<br><br>    a<span class="hljs-variable">.setCookie</span>(&quot;login_frequency&quot;, 0, 2),<br><br>    window<span class="hljs-variable">.checkLoginPromise</span> &amp;&amp; (window<span class="hljs-variable">.checkLoginPromise</span><span class="hljs-variable">.abort</span>(),<br><br>    window<span class="hljs-variable">.checkLoginPromise</span> = null),<br><br>    r()<br><br>  &#125;<br><br>  e<span class="hljs-variable">.code</span> = c<span class="hljs-variable">.code</span>,<br><br>  e<span class="hljs-variable">.userAvatar</span> = c<span class="hljs-variable">.userAvatar</span>,<br><br>  a<span class="hljs-variable">.log</span>(&quot;get code&quot;, c<span class="hljs-variable">.code</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>  微信网页端扫码登录时，轮询的数据返回采用的是JSONP的形式，这是为了解决跨域问题。</p><p>  微信网页端扫码登录时，轮询采用了后台根据扫码情况阻塞前台请求，优化轮询及减少前端的无效轮询。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://my.oschina.net/u/4231722/blog/3154805">1. 主流的扫码登录技术原理</a></p>]]></content>
    
    
    <categories>
      
      <category>登录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TwoSum</title>
    <link href="/2020/10/22/TwoSum/"/>
    <url>/2020/10/22/TwoSum/</url>
    
    <content type="html"><![CDATA[<h2 id="TwoSum"><a href="#TwoSum" class="headerlink" title="TwoSum"></a>TwoSum</h2><ul><li><a href="https://yangtzeshore.github.io/2020/10/19/TwoSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2020/10/19/TwoSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9<br><br>因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9<br>所以返回 <span class="hljs-comment">[0, 1]</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] indexs = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br>        // k 数值, v 下标<br>        Map&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt; hashMap = <span class="hljs-built_in">new</span> HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hashMap.containsKey(nums[i])) &#123;<br>                indexs[<span class="hljs-number">0</span>] = hashMap.<span class="hljs-keyword">get</span>(nums[i]);<br>                indexs[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>            hashMap.put(target - nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> indexs;<br>    &#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>利用隐藏的条件，必定有两个数满足target。</li><li>那么遍历数字，将补数作为key存入hashmap，如果后面遍历到补数自然就能返回下标。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——5. 读写分离</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%945.%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%945.%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——5-读写分离"><a href="#分库分表——5-读写分离" class="headerlink" title="分库分表——5. 读写分离"></a>分库分表——5. 读写分离</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="实现-MySQL-读写分离"><a href="#实现-MySQL-读写分离" class="headerlink" title="实现 MySQL 读写分离"></a>实现 MySQL 读写分离</h3><p>  其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h3 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h3><p>  主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-5-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/mysql-master-slave.png" alt="mysql-master-slave"></a></p><p>  这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>  而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>  所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><p>  这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p><p>  所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p><h3 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h3><p>  以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p><p>  是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000&#x2F;s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p><p>  我们通过 MySQL 命令：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">show</span> <span class="hljs-built_in">status</span><br></code></pre></td></tr></table></figure><p>  查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p><p>  一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li><li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000&#x2F;s，并行复制还是没意义。</li><li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li><li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md">1. mysql-read-write-separation</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——4. 主键生成策略</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%944.%20%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%944.%20%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——4-主键生成策略"><a href="#分库分表——4-主键生成策略" class="headerlink" title="分库分表——4. 主键生成策略"></a>分库分表——4. 主键生成策略</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="基于数据库的实现方案"><a href="#基于数据库的实现方案" class="headerlink" title="基于数据库的实现方案"></a>基于数据库的实现方案</h3><h4 id="数据库自增-id"><a href="#数据库自增-id" class="headerlink" title="数据库自增 id"></a>数据库自增 id</h4><p>  这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p><p>  这个方案的好处就是方便简单，谁都会用；<strong>缺点就是单库生成</strong>自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是<strong>无论如何都是基于单个数据库</strong>。</p><p>  <strong>适合的场景</strong>：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你<strong>并发不高，但是数据量太大</strong>导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p><h4 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h4><p>  可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p><p>  比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-4-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-id-sequence-step.png" alt="database-id-sequence-step"></a></p><p>  <strong>适合的场景</strong>：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>  好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><p>  适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">UUID.randomUUID<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span>.<span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)</span> -&gt;</span> sfsdf23423rr234sfdaf<br></code></pre></td></tr></table></figure><h3 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h3><p>  这个就是获取当前时间即可，但是问题是，<strong>并发很高的时候</strong>，比如一秒并发几千，<strong>会有重复的情况</strong>，这个是肯定不合适的。基本就不用考虑了。</p><p>  适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h3 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a>snowflake 算法</h3><p>  snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号。</p><ul><li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li><li>41 bits：表示的是时间戳，单位是毫秒。41 bits 可以表示的数字多达 <code>2^41 - 1</code> ，也就是可以标识 <code>2^41 - 1</code> 个毫秒值，换算成年就是表示 69 年的时间。</li><li>10 bits：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bits 里 5 个 bits 代表机房 id，5 个 bits 代表机器 id。意思就是最多代表 <code>2^5</code> 个机房（32 个机房），每个机房里可以代表 <code>2^5</code> 个机器（32 台机器）。</li><li>12 bits：这个是用来记录同一个毫秒内产生的不同 id，12 bits 可以代表的最大正整数是 <code>2^12 - 1 = 4096</code> ，也就是说可以用这个 12 bits 代表的数字来区分<strong>同一个毫秒内</strong>的 4096 个不同的 id。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> | <span class="hljs-number">0001100</span> <span class="hljs-number">10100010</span> <span class="hljs-number">10111110</span> <span class="hljs-number">10001001</span> <span class="hljs-number">01011100</span> <span class="hljs-number">00</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">1</span> <span class="hljs-number">1001</span> | <span class="hljs-number">0000</span> <span class="hljs-number">00000000</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdWorker</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> workerId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> datacenterId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> sequence;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IdWorker</span><span class="hljs-params">(<span class="hljs-type">long</span> workerId, <span class="hljs-type">long</span> datacenterId, <span class="hljs-type">long</span> sequence)</span> &#123;<br>        <span class="hljs-comment">// sanity check for workerId</span><br>        <span class="hljs-comment">// 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0</span><br>        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    String.format(<span class="hljs-string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    String.format(<span class="hljs-string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));<br>        &#125;<br>        System.out.printf(<br>                <span class="hljs-string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,<br>                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);<br><br>        <span class="hljs-built_in">this</span>.workerId = workerId;<br>        <span class="hljs-built_in">this</span>.datacenterId = datacenterId;<br>        <span class="hljs-built_in">this</span>.sequence = sequence;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">twepoch</span> <span class="hljs-operator">=</span> <span class="hljs-number">1288834974657L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">workerIdBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">5L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">datacenterIdBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">// 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxWorkerId</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);<br><br>    <span class="hljs-comment">// 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxDatacenterId</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; datacenterIdBits);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequenceBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">12L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">workerIdShift</span> <span class="hljs-operator">=</span> sequenceBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">datacenterIdShift</span> <span class="hljs-operator">=</span> sequenceBits + workerIdBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">timestampLeftShift</span> <span class="hljs-operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequenceMask</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastTimestamp</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getWorkerId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> workerId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDatacenterId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> datacenterId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTimestamp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这儿就是获取当前时间戳，单位是毫秒</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> timeGen();<br><br>        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<br>                    <span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;<br>            <span class="hljs-comment">// 这个意思是说一个毫秒内最多只能有4096个数字</span><br>            <span class="hljs-comment">// 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span><br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>                timestamp = tilNextMillis(lastTimestamp);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sequence = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span><br>        lastTimestamp = timestamp;<br><br>        <span class="hljs-comment">// 这儿就是将时间戳左移，放到 41 bit那儿；</span><br>        <span class="hljs-comment">// 将机房 id左移放到 5 bit那儿；</span><br>        <span class="hljs-comment">// 将机器id左移放到5 bit那儿；将序号放最后12 bit；</span><br>        <span class="hljs-comment">// 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型</span><br>        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift)<br>                | (workerId &lt;&lt; workerIdShift) | sequence;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">tilNextMillis</span><span class="hljs-params">(<span class="hljs-type">long</span> lastTimestamp)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> timeGen();<br>        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;<br>            timestamp = timeGen();<br>        &#125;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">timeGen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-comment">// ---------------测试---------------</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IdWorker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdWorker</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(worker.nextId());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个<strong>机房</strong> id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的<strong>机器</strong> id（但是最大只能是 32 以内），剩下的那个 12 bit 序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p><p>  所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p><p>  利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p><p>  这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md">1. database-shard-global-id-generate</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——3. 动态扩容缩容方案</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%943.%20%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%943.%20%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——3-动态扩容缩容方案"><a href="#分库分表——3-动态扩容缩容方案" class="headerlink" title="分库分表——3. 动态扩容缩容方案"></a>分库分表——3. 动态扩容缩容方案</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>  这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然<strong>分库分表</strong>就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p><p>  从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1 小时数据就导完了。这没有问题。</p><p>  如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p><h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>  一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p><p>  这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题。</p><p>  每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 32 <em>1000 &#x3D; 32000 的写并发，如果每个库承载 1500 的写并发，32</em> 1500 &#x3D; 48000 的写并发，接近 5 万每秒的写入并发，前面再加一个 MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p><p>  有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128 个库，256 个库，512 个库。</p><p>  1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p><p>  每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p><p>  谈分库分表的扩容，<strong>第一次分库分表，就一次性给他分个够</strong>，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p><p>  一个实践是利用 <code>32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p><table><thead><tr><th>orderId</th><th>id % 32 (库)</th><th>id &#x2F; 32 % 32 (表)</th></tr></thead><tbody><tr><td>259</td><td>3</td><td>8</td></tr><tr><td>1189</td><td>5</td><td>5</td></tr><tr><td>352</td><td>0</td><td>11</td></tr><tr><td>4593</td><td>17</td><td>15</td></tr></tbody></table><p>  刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个 MySQL 服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 MySQL 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p><p>  比如说最多可以扩展到 32 个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是 1024 个表。</p><p>  这么搞，是不用自己写代码做数据迁移的，都交给 DBA 来搞好了，但是 DBA 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p><p>  哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p><p>  这里对步骤做一个总结：</p><ol><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32 库 * 32 表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 &#x3D; 库，orderId &#x2F; 32 模 32 &#x3D; 表。</li><li>扩容的时候，申请增加更多的数据库服务器，装好 MySQL，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md">1. database-shard-dynamic-expand</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——2. 迁移方案</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%942.%20%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%942.%20%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——2-迁移方案"><a href="#分库分表——2-迁移方案" class="headerlink" title="分库分表——2. 迁移方案"></a>分库分表——2. 迁移方案</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表<strong>动态切换</strong>到分库分表上？</p><h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>  我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p><p>  接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个<strong>导数的一次性工具</strong>，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p><p>  导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p><p>  验证一下，ok 了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。</p><p>  但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-shard-method-1.png" alt="database-shard-method-1"></a></p><h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p> 1. 将新的库配置为源库的从库用来同步数据；如果需要将数据同步到多库多表，那么可以使用一些第三方工具获取 Binlog 的增量日志（比如开源工具 Canal），在获取增量日志之后就可以按照分库分表的逻辑写入到新的库表中了。</p><p> 2. 同时我们需要改造业务代码，在数据写入的时候不仅要写入旧库也要写入新库。当然，基于性能的考虑，我们可以异步地写入新库，只要保证旧库写入成功即可。但是我们需要注意的是，需要将写入新库失败的数据记录在单独的日志中，这样方便后续对这些数据补写，保证新库和旧库的数据一致性。</p><p> 3. 然后我们就可以开始校验数据了。由于数据库中数据量很大，做全量的数据校验不太现实。你可以抽取部分数据，具体数据量依据总体数据量而定，只要保证这些数据是一致的就可以。</p><p> 4. 双写时加开关，默认关闭双写，上线完成后关闭同步，同时打开开关，在低峰期的话数据丢失的概率不高。再配合数据校验的工作，是可以保证一致性的。</p><p> 5. 如果一切顺利，我们就可以将读流量切换到新库了。由于担心一次切换全量读流量可能会对系统产生未知的影响，所以这里最好采用灰度的方式来切换，比如开始切换 10% 的流量，如果没有问题再切换到 50% 的流量，最后再切换到 100%。</p><p> 6. 由于有双写的存在，所以在切换的过程中出现任何的问题都可以将读写流量随时切换到旧库去，保障系统的性能。</p><p> 7. 在观察了几天发现数据的迁移没有问题之后，就可以将数据库的双写改造成只写新库，数据的迁移也就完成了。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-shard-method-2.webp" alt="database-shard-method-2"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md">1. database-shard-method</a></p><p><a href="https://www.jianshu.com/p/ab2efddfafbd">2. 数据迁移之同步双写方案</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——1. 基本了解</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%941.%20%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%941.%20%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——1-基本了解"><a href="#分库分表——1-基本了解" class="headerlink" title="分库分表——1. 基本了解"></a>分库分表——1. 基本了解</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h3><p>  说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。</p><p>  假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20 万，每天活跃用户就 1 万，每天单表数据量就 1000，然后高峰期每秒钟并发请求最多就 10 个。我的天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p><p>  结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p><p>  好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是 1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢……</p><p>  再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p><p>  但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的 <code>5000~8000</code> ！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p><p>  好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>  比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大</strong>，会极大影响你的 sql <strong>执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>  分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>  分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p><p>  这就是所谓的<strong>分库分表</strong>，为啥要分库分表？你明白了吧。</p><table><thead><tr><th align="center"></th><th align="left">分库分表前</th><th align="left">分库分表后</th></tr></thead><tbody><tr><td align="center">并发支撑情况</td><td align="left">MySQL 单机部署，扛不住高并发</td><td align="left">MySQL 从单机到多机，能承受的并发增加了多倍</td></tr><tr><td align="center">磁盘使用情况</td><td align="left">MySQL 单机磁盘容量几乎撑满</td><td align="left">拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td align="center">SQL 执行性能</td><td align="left">单表数据量太大，SQL 越跑越慢</td><td align="left">单表数据量减少，SQL 执行效率明显提升</td></tr></tbody></table><h3 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h3><p>  这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p><p>比较常见的包括：</p><ul><li>Cobar</li><li>TDDL</li><li>Atlas</li><li>Sharding-jdbc</li><li>Mycat</li></ul><h4 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h4><p>  阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p><h4 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h4><p>  淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p><h4 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h4><p>  360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p><h4 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h4><p>  当当开源的，属于 client 层方案，是<a href="https://shardingsphere.apache.org/"> <code>ShardingSphere</code> </a>的 client 层方案，<a href="https://shardingsphere.apache.org/"> <code>ShardingSphere</code> </a>还提供 proxy 层的方案 Sharding-Proxy。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</p><h4 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h4><p>  基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。</p><p>  Sharding-jdbc 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖；</p><p>  Mycat 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</p><p>  通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。</p><h3 id="垂直拆分和水平拆分"><a href="#垂直拆分和水平拆分" class="headerlink" title="垂直拆分和水平拆分"></a>垂直拆分和水平拆分</h3><p>  <strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-split-horizon.png" alt="database-split-horizon"></a></p><p>  <strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-split-vertically.png" alt="database-split-vertically"></a></p><p>  这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p><p>  还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是<strong>让每个表的数据量控制在一定范围内</strong>，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的 SQL 越复杂，就最好让单表行数越少。</p><p>  好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，<strong>中间件可以根据你指定的某个字段值</strong>，比如说 userid，<strong>自动路由到对应的库上去，然后再自动路由到对应的表里去</strong>。</p><p>  你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p><p>  而且这儿还有两种<strong>分库分表的方式</strong>：</p><ul><li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li><li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。</li></ul><p>   range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p><p>  hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md">1. database-shard</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高并发系统设计</title>
    <link href="/2020/10/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/10/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/high-concurrency-design.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？</p><p>  我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较 low，结果业务发展太快，有的时候系统扛不住压力就挂了。</p><p>  当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒 5000&#x2F;8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。</p><p>  所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。</p><p>  那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：</p><p>可以分为以下 6 点：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><a href="https://yangtzeshore.github.io/2020/10/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E9%AB%98%E5%B9%B6%E5%8F%91/high-concurrency-system-design.png" alt="high-concurrency-system-design"></a></p><h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>  将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>  缓存，必须得用缓存。大部分的高并发场景，都是<strong>读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的<strong>读场景，怎么用缓存来抗高并发</strong>。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>  MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>  分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表<strong>拆分为多个表</strong>，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>  读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，<strong>主库写</strong>入，<strong>从库读</strong>取，搞一个读写分离。<strong>读流量太多</strong>的时候，还可以<strong>加更多的从库</strong>。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>  Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><p>  上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p><p>  说句实话，毕竟你真正厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是无比复杂的，一旦做过一次，并且做好了，你在这个市场上就会非常的吃香。</p><p>  其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/high-concurrency-design.md">1. high-concurrency-design</a></p>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
